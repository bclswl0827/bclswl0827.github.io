<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Orange Pi 使用 mmap 控制 GPIO</title>
    <url>/OrangePi-MMAP_20230520/</url>
    <content><![CDATA[<p>博主曾经接手的一个项目，主控板连续好几年使用的一直是 Rapsberry Pi，但是随着 Raspberry Pi 价格长期居高不下，让人直呼伤不起，只能考虑把板子换成更便宜的方案，再三权衡之下，博主最后选了 Orange Pi One。</p>
<p>Orange Pi One 使用了 Allwinner H3 作为 CPU，内建 512 MB 运存，对于博主的项目来说绰绰有余，另外，Orange Pi One 的 GPIO 定义和 Raspberry Pi 相同，而且闲鱼上的售价普遍 70 左右，和树莓派现在的售价比起来，直接少了个 0，让人很难不心动。</p>
<p>悲催的是，这个项目恰好就用到了 Raspberry Pi 的 GPIO，而且原本的代码中并没有用外部库去操作 GPIO，只是使用了<strong>内存映射</strong>的方式，透过读写内存来操作 GPIO。</p>
<p>我们知道，不同的 CPU 之间，内部的寄存器集合与地址也都会有所不同，所以在博主想碰碰运气，尝试过直接换板子，发现果然运行不了之后，博主只能很不情愿地改代码去了。</p>
<p>这篇文章将会介绍博主如何理解 mmap 的概念，如何看懂 Allwinner H3 提供的 Datasheet，以及如何成功编写程序控制 GPIO 的一整套流程，希望能对您有所帮助。</p>
<p><img data-src="https://c.ibcl.us/OrangePi-MMAP_20230520/1.jpg" alt="博主的 Orange Pi One"></p>
<span id="more"></span>

<h1 id="为什么要用-mmap"><a href="#为什么要用-mmap" class="headerlink" title="为什么要用 mmap"></a>为什么要用 mmap</h1><p>简单来说，mmap 可以透过将一片物理内存空间映射到应用的虚拟内存空间，这样一来，我们就能直接在应用层就能操作 CPU 的寄存器。</p>
<p>在常规的开发中，我们通常会用 Linux 通用的 sysfs 方式去控制 GPIO，使 GPIO 输出指定的电平，或是从 GPIO 读取外部向 GPIO 输入的电平。</p>
<p>但是，这种方法只适合于一般对速度要求不高的场合，在需要高速访问 GPIO 的场合，这种方式还是比较吃力的。这是因为 sysfs 是透过文件 IO 操作进行 GPIO 控制，每次操作都需要进行文件系统的访问和系统调用，这都会引入一定的性能开销。</p>
<p>所以，若要破除额外的性能开销，突破文件 IO 瓶颈，那就需要想办法绕过它们，而 mmap 这种方法可以直接在物理内存中进行 GPIO 相关操作，按理说可以实现更快速的 GPIO 访问速度。</p>
<h1 id="mmap-控制-GPIO-的原理"><a href="#mmap-控制-GPIO-的原理" class="headerlink" title="mmap 控制 GPIO 的原理"></a>mmap 控制 GPIO 的原理</h1><p>我们知道，开发板上的 GPIO 实际上就是 CPU 上的一部分引脚，由于这一部分引脚可以透过程序控制，那么 CPU 内必然有与之对应的寄存器，那么也就必然有与之对应的物理地址区段，同时这个区段是不会改变的。而我们可以透过 mmap 操作 CPU 内部寄存器，那么就可以透过这种方式控制指定的 GPIO。</p>
<p>要透过 mmap 控制 GPIO，流程有如下 5 步。</p>
<ol>
<li>打开 <code>/dev/mem</code> 装置文件</li>
<li>确定 GPIO 控制寄存器的物理地址</li>
<li>使用 mmap 映射物理地址到用户空间</li>
<li>访问 GPIO 控制寄存器</li>
<li>取消 mmap 映射</li>
</ol>
<p>在这 5 步中，第 2 步需要查阅 CPU 厂商所提供的 Datasheet 来确定。</p>
<h1 id="查阅-Allwinner-H3-Datasheet"><a href="#查阅-Allwinner-H3-Datasheet" class="headerlink" title="查阅 Allwinner H3 Datasheet"></a>查阅 Allwinner H3 Datasheet</h1><p>透过 Google，博主找到了 <span class="exturl" data-url="aHR0cHM6Ly9kbC5saW51eC1zdW54aS5vcmcvSDMvQWxsd2lubmVyX0gzX0RhdGFzaGVldF9WMS4wLnBkZg==">Allwinner H3 的 Datasheet<i class="fa fa-external-link-alt"></i></span>。由于 Datasheet 有惊人的 618 页，不可能每页都看完，我们只需要按下 Ctrl + F 搭配搜索如下关键词即可。</p>
<ul>
<li>Base Address：基础地址</li>
<li>Register：寄存器</li>
</ul>
<p>在第 90 页 4.3.4. Register List 位置，我们得知，<strong>CPU 内所有寄存器基础地址为 0x01C20000</strong>；继续搜索后，在 318 页 4.22.1. Port Controller Register List 位置，可以了解到 Allwinner H3 的 <strong>GPIO 寄存器基础地址为 0x01C20800</strong>。由此，我们可以得出结论，<strong>GPIO 寄存器基础地址</strong>相对于 <strong>CPU 内所有寄存器基础地址</strong>的偏移量为 0x0800。</p>
<p>接下来，我们需要知道 GPIO 寄存器的具体配置。在 318 页 4.22.2. Port Controller Register 位置，我们可以看到寄存器表格，去除中断引脚，对于我们有用的寄存器配置如下。</p>
<table>
<thead>
<tr>
<th align="left">寄存器名称</th>
<th align="left">寄存器偏移</th>
<th align="left">寄存器描述</th>
<th align="left">博主注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Pn_CFG0</td>
<td align="left">n*0x24 + 0x00</td>
<td align="left">GPIO n 配置寄存器 0，用于配置 GPIO n 的模式</td>
<td align="left">先确定好要设定 GPIO 模式的端口号（如 GPIO_A）以及管脚号（如 A6）</td>
</tr>
<tr>
<td align="left">Pn_CFG1</td>
<td align="left">n*0x24 + 0x04</td>
<td align="left">GPIO n 配置寄存器 1，用于配置 GPIO n 的模式</td>
<td align="left">然后在 Datasheet 中此表格后续的 Pn Configure Register x 表中</td>
</tr>
<tr>
<td align="left">Pn_CFG2</td>
<td align="left">n*0x24 + 0x08</td>
<td align="left">GPIO n 配置寄存器 2，用于配置 GPIO n 的模式</td>
<td align="left">n = [0…6]，x = [1…3] 找到确切管脚对应之「位」与模式之「值」</td>
</tr>
<tr>
<td align="left">Pn_CFG3</td>
<td align="left">n*0x24 + 0x0C</td>
<td align="left">GPIO n 配置寄存器 3，用于配置 GPIO n 的模式</td>
<td align="left">（上文提及之代号 n 亦指代 GPIO 端口号 A、C、D、E、F、G、L 之一）</td>
</tr>
<tr>
<td align="left">Pn_DAT</td>
<td align="left">n*0x24 + 0x10</td>
<td align="left">GPIO n 数据寄存器，用于存取 GPIO n 的状态</td>
<td align="left">输入模式时对应位表示引脚状态；输出模式时引脚状态与对应位相同</td>
</tr>
<tr>
<td align="left">Pn_DRV0</td>
<td align="left">n*0x24 + 0x14</td>
<td align="left">GPIO n 驱动能力寄存器 0，用于配置 GPIO n 的驱动能力</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Pn_DRV1</td>
<td align="left">n*0x24 + 0x18</td>
<td align="left">GPIO n 驱动能力寄存器 1，用于配置 GPIO n 的驱动能力</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Pn_PUL0</td>
<td align="left">n*0x24 + 0x1C</td>
<td align="left">GPIO n 上拉电阻控制寄存器 0，用于配置 GPIO n 的上拉电阻</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Pn_PUL1</td>
<td align="left">n*0x24 + 0x20</td>
<td align="left">GPIO n 上拉电阻控制寄存器 1，用于配置 GPIO n 的上拉电阻</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>此外，虽然我们知道了 GPIO 的寄存器基础地址为 0x01C20800，但是我们要控制的 GPIO 是 GPIO_A，所以我们还需要知道 GPIO_A 相对于 GPIO 寄存器基础地址的偏移量。</p>
<p>继续翻阅 Datasheet，我们可以在 319 页 4.22.2.1. PA Configure Register 0 位置了解到，GPIO_A 端口寄存器相对于 GPIO 寄存器基础地址的偏移量为 0x00，同时 GPIO_A 端口寄存器的所有配置结束于 0x01C20820，位宽 0x20 字节。</p>
<p>综上所述，我们可以用一个结构体类型 <code>gpio_t</code> 来描述上述寄存器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> config[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> driver[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> pull[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="type">gpio_t</span>;</span><br></pre></td></tr></table></figure>

<p>在这个结构体中，<code>volatile</code> 关键字用于告诉编译器，这个结构体中的成员变量可能会被其他线程或者中断修改，所以编译器不要对这个结构体进行优化。</p>
<p>了解了 GPIO 寄存器的配置，我们可以透过一个实例来说明如何配置 GPIO。</p>
<p>例如，我们要控制 GPIO_A20 为输出模式，并输出高电平，透过查询 Datasheet，我们需要得知以下几条与 GPIO_A20 相关的资讯。</p>
<ol>
<li>GPIO_A20 的配置位于 PA_CFG2_REG 寄存器中第 20-22 位，其值为 0x01 时为输出模式</li>
<li>当 PA_DATA_REG 寄存器第 20 位值为 0x01 时，即可输出高电平</li>
</ol>
<p>又例如，我们要控制 GPIO_A8 为输入模式，并使能上拉电阻，透过查询 Datasheet，我们需要得知以下几条与 GPIO_A8 相关的资讯。</p>
<ol>
<li>GPIO_A8 的配置位于 PA_CFG1_REG 寄存器中第 0-2 位，其值为 0x00 时为输入模式</li>
<li>当 PA_PULL0_REG 寄存器第 16-17 位值为 0x01 时，即可使能上拉电阻</li>
</ol>
<h1 id="编程解决问题"><a href="#编程解决问题" class="headerlink" title="编程解决问题"></a>编程解决问题</h1><p>有了以上知识做铺垫，我们就可以开始编写程序解决问题了。</p>
<p>博主将以 C 语言、Go 语言与 Python 为例，透过 mmap 操作 GPIO，实现 GPIO_A21 管脚带动 LED 灯闪烁，同时读取 GPIO_A8 管脚电平并打印到终端。</p>
<p><strong>由于 GPIO_A8 管脚设定了上拉使能，所以除非用户将这个管脚接地，否则读出的电平始终为高</strong>；同理，若用户设定了下拉使能，则除非用户将这个管脚接到 Vcc，否则读出的电平始终为低。</p>
<h2 id="C-语言版本"><a href="#C-语言版本" class="headerlink" title="C 语言版本"></a>C 语言版本</h2><p>以下是 C 语言的版本，其中，<code>gpio_t</code> 结构体的定义与上文相同，<code>set_output</code> 函数用于将 GPIO 端口设置为输出模式，<code>set_input</code> 函数用于将 GPIO 端口设置为输入模式，<code>set_level</code> 函数用于设定 GPIO 端口电平，<code>get_level</code> 函数用于读取 GPIO 端口的电平。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO_A 配置寄存器列表</span></span><br><span class="line"><span class="comment">// &#123; 寄存器号, 寄存器位 &#125;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> GPIO_A_CONFIG[<span class="number">22</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>&#125;,   <span class="comment">// PA0</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">4</span>&#125;,   <span class="comment">// PA1</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">8</span>&#125;,   <span class="comment">// PA2</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">12</span>&#125;,  <span class="comment">// PA3</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">16</span>&#125;,  <span class="comment">// PA4</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">20</span>&#125;,  <span class="comment">// PA5</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">24</span>&#125;,  <span class="comment">// PA6</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">28</span>&#125;,  <span class="comment">// PA7</span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,   <span class="comment">// PA8</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">4</span>&#125;,   <span class="comment">// PA9</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">8</span>&#125;,   <span class="comment">// PA10</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">12</span>&#125;,  <span class="comment">// PA11</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">16</span>&#125;,  <span class="comment">// PA12</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">20</span>&#125;,  <span class="comment">// PA13</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">24</span>&#125;,  <span class="comment">// PA14</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">28</span>&#125;,  <span class="comment">// PA15</span></span><br><span class="line"></span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">0</span>&#125;,   <span class="comment">// PA16</span></span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">4</span>&#125;,   <span class="comment">// PA17</span></span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">8</span>&#125;,   <span class="comment">// PA18</span></span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">12</span>&#125;,  <span class="comment">// PA19</span></span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">16</span>&#125;,  <span class="comment">// PA20</span></span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">20</span>&#125;,  <span class="comment">// PA21</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器基础地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLWINNER_H3_BASE 0x01C20000</span></span><br><span class="line"><span class="comment">// GPIO_A 相对于 ALLWINNER_H3_BASE 偏移量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PA_OFFSET 0x0800</span></span><br><span class="line"><span class="comment">// 指定在使用 mmap 函数时要映射的区域大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMAP_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 模式设定</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GPIO_MODE</span> &#123;</span><br><span class="line">    INPUT = <span class="number">0</span>,</span><br><span class="line">    OUTPUT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// GPIO 电平设定</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GPIO_LEVEL</span> &#123;</span><br><span class="line">    LOW = <span class="number">0</span>,</span><br><span class="line">    HIGH,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// GPIO 上拉下拉设定</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GPIO_PULL</span> &#123;</span><br><span class="line">    PULL_OFF = <span class="number">0</span>,</span><br><span class="line">    PULL_UP,</span><br><span class="line">    PULL_DOWN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 端口寄存器类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> config[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> driver[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> pull[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="type">gpio_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 GPIO_A 的指定管脚为输出模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_output</span><span class="params">(<span class="type">gpio_t</span>* gpio, <span class="type">int</span> pin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取得寄存器号与寄存器位</span></span><br><span class="line">    <span class="type">int</span> reg = GPIO_A_CONFIG[pin][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> bit = GPIO_A_CONFIG[pin][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 清空原有配置</span></span><br><span class="line">    gpio-&gt;config[reg] &amp;= ~(<span class="number">0x0F</span> &lt;&lt; bit);</span><br><span class="line">    <span class="comment">// 设为输出模式</span></span><br><span class="line">    gpio-&gt;config[reg] |= (OUTPUT &lt;&lt; bit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 GPIO_A 的指定管脚为输入模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_input</span><span class="params">(<span class="type">gpio_t</span>* gpio, <span class="type">int</span> pin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取得寄存器号与寄存器位</span></span><br><span class="line">    <span class="type">int</span> reg = GPIO_A_CONFIG[pin][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> bit = GPIO_A_CONFIG[pin][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 清空原有配置</span></span><br><span class="line">    gpio-&gt;config[reg] &amp;= ~(<span class="number">0x0F</span> &lt;&lt; bit);</span><br><span class="line">    <span class="comment">// 设为输入模式</span></span><br><span class="line">    gpio-&gt;config[reg] |= (INPUT &lt;&lt; bit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定 GPIO_A 的指定管脚上拉下拉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pull</span><span class="params">(<span class="type">gpio_t</span>* gpio, <span class="type">int</span> pin, <span class="type">int</span> pull)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取得寄存器号</span></span><br><span class="line">    <span class="type">int</span> reg = pin / <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 取得寄存器位</span></span><br><span class="line">    <span class="type">int</span> bit = (pin % <span class="number">16</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 清空原有配置</span></span><br><span class="line">    gpio-&gt;pull[reg] &amp;= ~(<span class="number">0x03</span> &lt;&lt; bit);</span><br><span class="line">    <span class="comment">// 设定上拉下拉</span></span><br><span class="line">    gpio-&gt;pull[reg] |= (<span class="type">uint32_t</span>)pull &lt;&lt; bit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定 GPIO_A 的指定管脚电平</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_level</span><span class="params">(<span class="type">gpio_t</span>* gpio, <span class="type">int</span> pin, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">        <span class="keyword">case</span> HIGH:</span><br><span class="line">            gpio-&gt;data |= (<span class="number">1</span> &lt;&lt; pin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> LOW:</span><br><span class="line">            gpio-&gt;data &amp;= ~(<span class="number">1</span> &lt;&lt; pin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        defaults:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 GPIO_A 的指定管脚电平</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_level</span><span class="params">(<span class="type">gpio_t</span>* gpio, <span class="type">int</span> pin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取得寄存器号与寄存器位</span></span><br><span class="line">    <span class="type">int</span> reg = GPIO_A_CONFIG[pin][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> bit = GPIO_A_CONFIG[pin][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 清空原有配置</span></span><br><span class="line">    gpio-&gt;config[reg] &amp;= ~(<span class="number">0x0F</span> &lt;&lt; bit);</span><br><span class="line">    <span class="keyword">return</span> (gpio-&gt;data &gt;&gt; pin) &amp; <span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以读写模式打开 /dev/mem 装置文件</span></span><br><span class="line">    <span class="type">int</span> mem = <span class="built_in">open</span>(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open /dev/mem&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将寄存器映射到内存</span></span><br><span class="line">    <span class="type">char</span>* reg = (<span class="type">char</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,</span><br><span class="line">                            mem, ALLWINNER_H3_BASE);</span><br><span class="line">    <span class="keyword">if</span> (reg == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(mem);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将映射的地址偏移量应用于 GPIO_A 寄存器类型</span></span><br><span class="line">    <span class="type">gpio_t</span>* gpio = (<span class="type">gpio_t</span>*)&amp;reg[GPIO_PA_OFFSET];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定 GPIO_A21 为输出模式</span></span><br><span class="line">    <span class="built_in">set_output</span>(gpio, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 设定 GPIO_A8 为输入模式</span></span><br><span class="line">    <span class="built_in">set_input</span>(gpio, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 设定 GPIO_A8 上拉使能</span></span><br><span class="line">    <span class="built_in">set_pull</span>(gpio, <span class="number">8</span>, PULL_UP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闪烁 LED 灯并读取电平</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 闪烁 GPIO_A21 LED</span></span><br><span class="line">        <span class="built_in">set_level</span>(gpio, <span class="number">21</span>, HIGH);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">500000</span>);</span><br><span class="line">        <span class="built_in">set_level</span>(gpio, <span class="number">21</span>, LOW);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">500000</span>);</span><br><span class="line">        <span class="comment">// 读取 GPIO_A8 电平并打印</span></span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">get_level</span>(gpio, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GPIO_A8 level: %d\n&quot;</span>, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除内存映射</span></span><br><span class="line">    <span class="built_in">munmap</span>(gpio, MMAP_SIZE);</span><br><span class="line">    <span class="built_in">close</span>(mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go-语言版本"><a href="#Go-语言版本" class="headerlink" title="Go 语言版本"></a>Go 语言版本</h2><p>作为一个 Gopher，当然也要用 Go 语言来实现一遍了。</p>
<p>在 Go 语言的版本中，内存映射使用了 <code>syscall.Mmap()</code> 和 <code>syscall.Munmap()</code> 函数。</p>
<p>此外，在之前的 C 代码中，使用了强制类型转换 <code>(gpio_t *)</code> 和解引用运算符 <code>*</code> 来进行指针转换，而在 Go 版本的实现中，指针转换是使用 <code>unsafe.Pointer</code> 类型与 <code>unsafe.Pointer()</code> 函数来进行指针转换，从而实现了直接操作内存地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO_A 配置寄存器列表</span></span><br><span class="line"><span class="comment">// &#123; 寄存器号, 寄存器位 &#125;</span></span><br><span class="line"><span class="keyword">var</span> GPIO_A_CONFIG = [<span class="number">22</span>][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">0</span>&#125;,  <span class="comment">// PA0</span></span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">4</span>&#125;,  <span class="comment">// PA1</span></span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">8</span>&#125;,  <span class="comment">// PA2</span></span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">12</span>&#125;, <span class="comment">// PA3</span></span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">16</span>&#125;, <span class="comment">// PA4</span></span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">20</span>&#125;, <span class="comment">// PA5</span></span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">24</span>&#125;, <span class="comment">// PA6</span></span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">28</span>&#125;, <span class="comment">// PA7</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,  <span class="comment">// PA8</span></span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">4</span>&#125;,  <span class="comment">// PA9</span></span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">8</span>&#125;,  <span class="comment">// PA10</span></span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">12</span>&#125;, <span class="comment">// PA11</span></span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">16</span>&#125;, <span class="comment">// PA12</span></span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">20</span>&#125;, <span class="comment">// PA13</span></span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">24</span>&#125;, <span class="comment">// PA14</span></span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">28</span>&#125;, <span class="comment">// PA15</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">0</span>&#125;,  <span class="comment">// PA16</span></span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">4</span>&#125;,  <span class="comment">// PA17</span></span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">8</span>&#125;,  <span class="comment">// PA18</span></span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">12</span>&#125;, <span class="comment">// PA19</span></span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">16</span>&#125;, <span class="comment">// PA20</span></span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">20</span>&#125;, <span class="comment">// PA21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 寄存器基础地址</span></span><br><span class="line">	ALLWINNER_H3_BASE = <span class="number">0x01C20000</span></span><br><span class="line">	<span class="comment">// GPIO_A 相对于 ALLWINNER_H3_BASE 偏移量</span></span><br><span class="line">	GPIO_PA_OFFSET = <span class="number">0x0800</span></span><br><span class="line">	<span class="comment">// 指定在使用 mmap 函数时要映射的区域大小</span></span><br><span class="line">	MMAP_SIZE = <span class="number">0x1000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 模式设定</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	INPUT  = <span class="number">0</span></span><br><span class="line">	OUTPUT = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 电平设定</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	LOW  = <span class="number">0</span></span><br><span class="line">	HIGH = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上拉下拉设定</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	PULL_OFF  = <span class="number">0</span></span><br><span class="line">	PULL_UP   = <span class="number">1</span></span><br><span class="line">	PULL_DOWN = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 端口寄存器类型</span></span><br><span class="line"><span class="keyword">type</span> gpio_t <span class="keyword">struct</span> &#123;</span><br><span class="line">	config [<span class="number">4</span>]<span class="type">uint32</span></span><br><span class="line">	data   <span class="type">uint32</span></span><br><span class="line">	driver [<span class="number">2</span>]<span class="type">uint32</span></span><br><span class="line">	pull   [<span class="number">2</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setOutput</span><span class="params">(gpio *gpio_t, pin <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取得寄存器号与寄存器位</span></span><br><span class="line">	reg := GPIO_A_CONFIG[pin][<span class="number">0</span>]</span><br><span class="line">	bit := GPIO_A_CONFIG[pin][<span class="number">1</span>]</span><br><span class="line">	<span class="comment">// 清空原有配置</span></span><br><span class="line">	gpio.config[reg] &amp;= ^(<span class="number">0x0F</span> &lt;&lt; bit)</span><br><span class="line">	<span class="comment">// 设为输出模式</span></span><br><span class="line">	gpio.config[reg] |= OUTPUT &lt;&lt; bit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setInput</span><span class="params">(gpio *gpio_t, pin <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取得寄存器号与寄存器位</span></span><br><span class="line">	reg := GPIO_A_CONFIG[pin][<span class="number">0</span>]</span><br><span class="line">	bit := GPIO_A_CONFIG[pin][<span class="number">1</span>]</span><br><span class="line">	<span class="comment">// 清空原有配置</span></span><br><span class="line">	gpio.config[reg] &amp;= ^(<span class="number">0x0F</span> &lt;&lt; bit)</span><br><span class="line">	<span class="comment">// 设为输入模式</span></span><br><span class="line">	gpio.config[reg] |= INPUT &lt;&lt; bit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setPull</span><span class="params">(gpio *gpio_t, pin, pull <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取得寄存器号</span></span><br><span class="line">	reg := pin / <span class="number">16</span></span><br><span class="line">    <span class="comment">// 取得寄存器位</span></span><br><span class="line">    bit := (pin % <span class="number">16</span>) * <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 清空原有配置</span></span><br><span class="line">	gpio.pull[reg] &amp;= ^(<span class="number">0x03</span> &lt;&lt; bit)</span><br><span class="line">	<span class="comment">// 设定上拉下拉</span></span><br><span class="line">	gpio.pull[reg] |= <span class="type">uint32</span>(pull) &lt;&lt; bit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setLevel</span><span class="params">(gpio *gpio_t, pin, level <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> level &#123;</span><br><span class="line">	<span class="keyword">case</span> HIGH:</span><br><span class="line">		gpio.data |= <span class="number">1</span> &lt;&lt; pin</span><br><span class="line">	<span class="keyword">case</span> LOW:</span><br><span class="line">		gpio.data &amp;= ^(<span class="number">1</span> &lt;&lt; pin)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLevel</span><span class="params">(gpio *gpio_t, pin <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 取得寄存器号与寄存器位</span></span><br><span class="line">	reg := GPIO_A_CONFIG[pin][<span class="number">0</span>]</span><br><span class="line">	bit := GPIO_A_CONFIG[pin][<span class="number">1</span>]</span><br><span class="line">	<span class="comment">// 清空原有配置</span></span><br><span class="line">	gpio.config[reg] &amp;= ^(<span class="number">0x0F</span> &lt;&lt; bit)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>((gpio.data &gt;&gt; pin) &amp; <span class="number">0x01</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 以读写模式打开 /dev/mem 装置文件</span></span><br><span class="line">	mem, err := os.OpenFile(<span class="string">&quot;/dev/mem&quot;</span>, os.O_RDWR|os.O_SYNC, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Failed to open /dev/mem: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> mem.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将寄存器映射到内存</span></span><br><span class="line">	reg, err := syscall.Mmap(<span class="type">int</span>(mem.Fd()), ALLWINNER_H3_BASE, MMAP_SIZE, syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Failed to mmap: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> syscall.Munmap(reg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将映射的地址偏移量应用于 GPIO_A 寄存器类型</span></span><br><span class="line">	gpio := (*gpio_t)(unsafe.Pointer(&amp;reg[GPIO_PA_OFFSET]))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设定 GPIO_A21 为输出模式</span></span><br><span class="line">	setOutput(gpio, <span class="number">21</span>)</span><br><span class="line">	<span class="comment">// 设定 GPIO_A8 为输入模式</span></span><br><span class="line">	setInput(gpio, <span class="number">8</span>)</span><br><span class="line">	<span class="comment">// 设定 GPIO_A8 上拉使能</span></span><br><span class="line">	setPull(gpio, <span class="number">8</span>, PULL_UP)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 闪烁 LED 灯并读取电平</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 闪烁 GPIO_A21 LED</span></span><br><span class="line">		setLevel(gpio, <span class="number">21</span>, HIGH)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">		setLevel(gpio, <span class="number">21</span>, LOW)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">		<span class="comment">// 读取 GPIO_A8 电平并打印</span></span><br><span class="line">		level := getLevel(gpio, <span class="number">8</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;GPIO_A8 level: %d\n&quot;</span>, level)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h2><p>Python 版本的实现与 Go 版本的实现类似，不过在 Python 中，内存映射使用了 <code>mmap</code> 模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mmap <span class="keyword">import</span> mmap, MAP_SHARED, PROT_READ, PROT_WRITE</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> <span class="built_in">open</span>, close, O_RDWR, O_SYNC</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> Structure, c_uint32</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Type</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> exit</span><br><span class="line"></span><br><span class="line"><span class="comment"># GPIO_A 配置寄存器列表</span></span><br><span class="line"><span class="comment"># &#123; 寄存器号, 寄存器位 &#125;</span></span><br><span class="line">GPIO_A_CONFIG = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>],  <span class="comment"># PA0</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">4</span>],  <span class="comment"># PA1</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">8</span>],  <span class="comment"># PA2</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">12</span>],  <span class="comment"># PA3</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">16</span>],  <span class="comment"># PA4</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">20</span>],  <span class="comment"># PA5</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">24</span>],  <span class="comment"># PA6</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">28</span>],  <span class="comment"># PA7</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>],  <span class="comment"># PA8</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">4</span>],  <span class="comment"># PA9</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">8</span>],  <span class="comment"># PA10</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">12</span>],  <span class="comment"># PA11</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">16</span>],  <span class="comment"># PA12</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">20</span>],  <span class="comment"># PA13</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">24</span>],  <span class="comment"># PA14</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">28</span>],  <span class="comment"># PA15</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>],  <span class="comment"># PA16</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>],  <span class="comment"># PA17</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">8</span>],  <span class="comment"># PA18</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">12</span>],  <span class="comment"># PA19</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">16</span>],  <span class="comment"># PA20</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">20</span>],  <span class="comment"># PA21</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寄存器基础地址</span></span><br><span class="line">ALLWINNER_H3_BASE = <span class="number">0x01C20000</span></span><br><span class="line"><span class="comment"># GPIO_A 相对于 ALLWINNER_H3_BASE 偏移量</span></span><br><span class="line">GPIO_PA_OFFSET = <span class="number">0x0800</span></span><br><span class="line"><span class="comment"># 指定在使用 mmap 函数时要映射的区域大小</span></span><br><span class="line">MMAP_SIZE = <span class="number">0x1000</span></span><br><span class="line"><span class="comment"># GPIO 模式设定</span></span><br><span class="line">INPUT = <span class="number">0</span></span><br><span class="line">OUTPUT = <span class="number">1</span></span><br><span class="line"><span class="comment"># GPIO 电平设定</span></span><br><span class="line">LOW = <span class="number">0</span></span><br><span class="line">HIGH = <span class="number">1</span></span><br><span class="line"><span class="comment"># 上拉下拉设定</span></span><br><span class="line">PULL_OFF = <span class="number">0</span></span><br><span class="line">PULL_UP = <span class="number">1</span></span><br><span class="line">PULL_DOWN = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># GPIO 端口寄存器类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gpio_t</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;config&quot;</span>, c_uint32 * <span class="number">4</span>),</span><br><span class="line">        (<span class="string">&quot;data&quot;</span>, c_uint32),</span><br><span class="line">        (<span class="string">&quot;driver&quot;</span>, c_uint32 * <span class="number">2</span>),</span><br><span class="line">        (<span class="string">&quot;pull&quot;</span>, c_uint32 * <span class="number">2</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 GPIO_A 的指定管脚为输出模式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_output</span>(<span class="params">gpio: <span class="type">Type</span>[gpio_t], pin: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 取得寄存器号与寄存器位</span></span><br><span class="line">    reg, bit = GPIO_A_CONFIG[pin]</span><br><span class="line">    <span class="comment"># 清空原有配置</span></span><br><span class="line">    gpio.config[reg] &amp;= ~(<span class="number">0x0F</span> &lt;&lt; bit)</span><br><span class="line">    <span class="comment"># 设为输出模式</span></span><br><span class="line">    gpio.config[reg] |= (OUTPUT &lt;&lt; bit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 GPIO_A 的指定管脚为输入模式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_input</span>(<span class="params">gpio: <span class="type">Type</span>[gpio_t], pin: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 取得寄存器号与寄存器位</span></span><br><span class="line">    reg, bit = GPIO_A_CONFIG[pin]</span><br><span class="line">    <span class="comment"># 清空原有配置</span></span><br><span class="line">    gpio.config[reg] &amp;= ~(<span class="number">0x0F</span> &lt;&lt; bit)</span><br><span class="line">    <span class="comment"># 设为输入模式</span></span><br><span class="line">    gpio.config[reg] |= (INPUT &lt;&lt; bit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定 GPIO_A 的指定管脚上拉下拉</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_pull</span>(<span class="params">gpio: <span class="type">Type</span>[gpio_t], pin: <span class="built_in">int</span>, pull: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 取得寄存器号</span></span><br><span class="line">    reg = <span class="built_in">int</span>(pin / <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># 取得寄存器位</span></span><br><span class="line">    bit = <span class="built_in">int</span>((pin % <span class="number">16</span>) * <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 清除原有配置</span></span><br><span class="line">    gpio.pull[reg] &amp;= ~(<span class="number">0x03</span> &lt;&lt; bit)</span><br><span class="line">    <span class="comment"># 设置上拉下拉</span></span><br><span class="line">    gpio.pull[reg] |= (pull &lt;&lt; bit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定 GPIO_A 的指定管脚电平</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_level</span>(<span class="params">gpio: <span class="type">Type</span>[gpio_t], pin: <span class="built_in">int</span>, level: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> level == HIGH:</span><br><span class="line">        gpio.data |= (<span class="number">1</span> &lt;&lt; pin)</span><br><span class="line">    <span class="keyword">elif</span> level == LOW:</span><br><span class="line">        gpio.data &amp;= ~(<span class="number">1</span> &lt;&lt; pin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 GPIO_A 的指定管脚电平</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">gpio: <span class="type">Type</span>[gpio_t], pin: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 取得寄存器号与寄存器位</span></span><br><span class="line">    reg, bit = GPIO_A_CONFIG[pin]</span><br><span class="line">    <span class="comment"># 清空原有配置</span></span><br><span class="line">    gpio.config[reg] &amp;= ~(<span class="number">0x0F</span> &lt;&lt; bit)</span><br><span class="line">    <span class="keyword">return</span> (gpio.data &gt;&gt; pin) &amp; <span class="number">0x01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 以读写模式打开 /dev/mem 装置文件</span></span><br><span class="line">    mem = <span class="built_in">open</span>(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC)</span><br><span class="line">    <span class="keyword">if</span> mem &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Failed to open /dev/mem&quot;</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将寄存器映射到内存</span></span><br><span class="line">    reg = mmap(</span><br><span class="line">        mem, MMAP_SIZE, MAP_SHARED,</span><br><span class="line">        PROT_READ | PROT_WRITE,</span><br><span class="line">        offset=ALLWINNER_H3_BASE</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将映射的地址偏移量应用于 GPIO_A 寄存器类型</span></span><br><span class="line">    gpio = gpio_t.from_buffer(reg, GPIO_PA_OFFSET)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定 GPIO_A21 为输出模式</span></span><br><span class="line">    set_output(gpio, <span class="number">21</span>)</span><br><span class="line">    <span class="comment"># 设定 GPIO_A8 为输入模式</span></span><br><span class="line">    set_input(gpio, <span class="number">8</span>)</span><br><span class="line">    <span class="comment"># 设定 GPIO_A8 上拉使能</span></span><br><span class="line">    set_pull(gpio, <span class="number">8</span>, PULL_UP)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 闪烁 LED 灯并读取电平</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 闪烁 GPIO_A21 LED</span></span><br><span class="line">        set_level(gpio, <span class="number">21</span>, HIGH)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        set_level(gpio, <span class="number">21</span>, LOW)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># 读取 GPIO_A8 电平并打印</span></span><br><span class="line">        level = get_level(gpio, <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;GPIO_A8 level:&quot;</span>, level)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解除内存映射</span></span><br><span class="line">    reg.close()</span><br><span class="line">    close(mem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p><img data-src="https://c.ibcl.us/OrangePi-MMAP_20230520/2.gif" alt="GPIO_A21 闪烁的 LED"></p>
<p><img data-src="https://c.ibcl.us/OrangePi-MMAP_20230520/3.png" alt="读取 GPIO_A8 电平"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Orange Pi</tag>
        <tag>MMAP</tag>
        <tag>GPIO</tag>
        <tag>硬件</tag>
        <tag>嵌入式</tag>
        <tag>Rapsberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>ADS-B：从入门到入狱</title>
    <url>/ADSB_Decode_20200118/</url>
    <content><![CDATA[<p>听惯了中短波广播，甚至已经能准确说出当前的某个频率对应哪个电台在播音… 是的，博主终于对传统广播有了倦意，也正因如此，最后博主决定拿出闲置的 RTL-SDR，玩玩 ADS-B 接收。</p>
<p>在这篇文章中，博主将介绍如何用 RTL-SDR 接收 1090MHz，由航班下发的 ADS-B 信号，并将实时航班情况展示在地图上，公开至外网，然后坐等被喝茶（</p>
<p><del><span class="exturl" data-url="aHR0cHM6Ly9hLmliY2wudXMv">现在，博主的 ADS-B 监测站点已经上线，欢迎来踩～<i class="fa fa-external-link-alt"></i></span></del></p>
<p><img data-src="https://c.ibcl.us/ADSB-Decode_20200118/1.jpg" alt="博主的 SDR 服务器" title="博主的 SDR 服务器"></p>
<span id="more"></span>

<h1 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h1><ul>
<li>RTL-SDR 及其附赠天线</li>
<li>装了 Linux 的主机（Linux 大法好</li>
</ul>
<p>需要注意的是，RTL-SDR 有着不同的芯片方案，即 RTL2832U+ [ xx 芯片 ]。不同的芯片方案，覆盖的频率范围和灵敏度也不同，这是尤其要注意的。</p>
<p>再把之前在<a href="https://ibcl.us/RTLSDR-Modifying_20190323/">《Re：从零开始的 RTL-SDR 折腾记》</a>一文中的那份表格贴上来…</p>
<table>
<thead>
<tr>
<th align="left">芯片方案</th>
<th align="left">频率范围</th>
<th align="left">情况</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RTL2832U+E4000</td>
<td align="left">54-2200 MHz</td>
<td align="left">已停产</td>
</tr>
<tr>
<td align="left">RTL2832U+R820T</td>
<td align="left">24-1766 MHz</td>
<td align="left">最容易取得</td>
</tr>
<tr>
<td align="left">RTL2832U+R820T2</td>
<td align="left">24-1766 MHz</td>
<td align="left">接收能力最强</td>
</tr>
<tr>
<td align="left">RTL2832U+FC0013</td>
<td align="left">22-1100 MHz</td>
<td align="left">灵敏度最差</td>
</tr>
<tr>
<td align="left">RTL2832U+FC0012</td>
<td align="left">22-948 MHz</td>
<td align="left">未知</td>
</tr>
</tbody></table>
<p>博主所购买的还是 CNY 42（不含运费）的那一款 SDR，其芯片方案是 RTL2832U+R820T2。如果有特别需求，可以购买 CNY 120 左右的，带温度补偿晶振（TXCO）的那款 RTL-SDR，其芯片方案同样是 RTL2832U+R820T2。</p>
<p><img data-src="https://c.ibcl.us/ADSB-Decode_20200118/2.jpg" alt="RTL2832U+R820T2" title="RTL2832U+R820T2"></p>
<p>此外，本文的 Linux 发行版选用 Debian Stretch。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>软件选用由 FlightAware 所维护的 dump1090，安装在博主的斐讯 N1 上，好在 N1 有两个 USB 口，CPU 也比较强劲，同时拖两个 SDR 完全够了。</p>
<p>这里，用于<span class="exturl" data-url="aHR0cHM6Ly9zLmliY2wudXMv">本站 WebSDR 页面<i class="fa fa-external-link-alt"></i></span>的 RTL-SDR 编号为 <code>0</code>，用于 ADS-B 接收的 RTL-SDR 编号为 <code>1</code>。关于如何获取 RTL-SDR 设备编号的问题，这里给出一个比较简单的方法。</p>
<ol>
<li>首先保证先前的 RTL-SDR 正在被使用；</li>
<li>插入新的 RTL-SDR；</li>
<li>在终端上执行命令 <code>rtl_test</code>，不出意外，得到以下回显，能够看到，rtl_test 探测到了两个 RTL-SDR，并提示因 <code>0</code> 号设备被占用而无法打开。现在可以得出 <code>1</code> 号设备即是新插入的 RTL-SDR；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dev:~# rtl_test</span><br><span class="line">Found 2 device(s):</span><br><span class="line">  0:  Realtek, RTL2838UHIDIR, SN: 00000001</span><br><span class="line">  1:  Realtek, RTL2838UHIDIR, SN: 00000001</span><br><span class="line"></span><br><span class="line">Using device 0: Generic RTL2832U OEM</span><br><span class="line">usb_claim_interface error -6</span><br><span class="line">Failed to open rtlsdr device #0.</span><br></pre></td></tr></table></figure></li>
<li>记下 <code>1</code> 这个数字为新插入的 RTL-SDR。</li>
</ol>
<p>至于 ADS-B 使用的天线，由于条件所限，只能放在窗边（虽然博主知道这样很敷衍了啦</p>
<p>最后，dump1090 的页面使用 Frp 内网穿透到博主服务器上的 8082 端口，然后通过 Nginx 反向代理到服务器的 80 端口，接上 CloudFlare，供人访问。</p>
<h1 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h1><p>以下的过程，均是在 root 用户下的操作，如果是子用户，博主建议先用 <code>sudo -i</code> 命令进入 root 模式后再进行下面的操作。</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>dump1090 依赖于 RTL-SDR 的驱动和支持库工作，同时 RTL-SDR 通过 USB 与主机连接，所以要安装 rtl-sdr、librtlsdr-dev、libusb-1.0-0-dev 三个依赖项。</p>
<p>由于需要从 GitHub 拉取 dump1090 的源码编译并打包为 deb 文件，所以还需要安装 git、build-essential、pkg-config、debhelper、dh-systemd、libncurses5-dev、libbladerf-dev。</p>
<p>此外，由 FlightAware 所维护的 dump1090 是作为 Lighttpd 的一个模块而存在的，所以也必须安装 lighttpd 这个软件。</p>
<p>综合一下，在终端下执行如下命令，将上述软件一并安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dev:~# apt update</span><br><span class="line">root@dev:~# apt install build-essential debhelper rtl-sdr libusb-1.0-0-dev librtlsdr-dev pkg-config dh-systemd libncurses5-dev libbladerf-dev git lighttpd -y</span><br></pre></td></tr></table></figure>

<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>拉取 dump1090 的源码到本地，然后进入源码目录，编译打包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dev:~# cd /home</span><br><span class="line">root@dev:/home# git clone https://github.com/flightaware/dump1090</span><br><span class="line">root@dev:/home# cd dump1090</span><br><span class="line">root@dev:/home/dump1090# dpkg-buildpackage -b</span><br></pre></td></tr></table></figure>

<p>稍等片刻，即可在上一层目录找到打包好的 deb 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dev:/home/dump1090# cd ../</span><br><span class="line">root@dev:/home# ls</span><br><span class="line">dump1090                  dump1090-fa_3.8.0_arm64.buildinfo  </span><br><span class="line">dump1090_3.8.0_all.deb    dump1090-fa_3.8.0_arm64.changes</span><br><span class="line">dump1090-fa-dbgsym_3.8.0_arm64.deb    dump1090-fa_3.8.0_arm64.deb</span><br></pre></td></tr></table></figure>

<p>文件名可能会因 CPU 架构而有所不同，但都大同小异，记下文件名，分别将其安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dev:/home# dpkg --install dump1090-fa_3.8.0_arm64.deb</span><br><span class="line">root@dev:/home# dpkg --install dump1090_3.8.0_all.deb</span><br></pre></td></tr></table></figure>

<h2 id="配置调整"><a href="#配置调整" class="headerlink" title="配置调整"></a>配置调整</h2><p>修改 /etc/default/dump1090-fa，这是 dump1090 的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dev:/home# vi /etc/default/dump1090-fa</span><br></pre></td></tr></table></figure>

<p>首先配置 dump1090 开机启动，直接将配置文件中 <code>ENABLED</code> 字段赋值为 <code>yes</code> 即可。</p>
<p>由于要指定 dump1090 使用 <code>1</code> 号 RTL-SDR，所以需要修改 <code>RECEIVER_OPTIONS</code> 字段，加入 <code>--device-index 1 --gain 50</code>，告诉 dump1090 打开 <code>1</code> 号 SDR，增益为 50dB。增益根据实际情况而定，正负值均可。</p>
<p>最后是告诉 dump1090 博主所处的经纬度，考虑到安全，可以填一个大致的位置。博主所处纬度 31.170280，经度 108.404610，所以在 <code>DECODER_OPTIONS</code> 字段加入 <code>--lat 31.170280 --lon 108.404610</code> 这样一句话。</p>
<p>综合上述要求，这里给出一个配置文件示范。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dump1090-fa configuration</span><br><span class="line"># This is sourced by /usr/share/dump1090-fa/start-dump1090-fa as a</span><br><span class="line"># shellscript fragment.</span><br><span class="line"></span><br><span class="line"># If you are using a PiAware sdcard image, this config file is regenerated</span><br><span class="line"># on boot based on the contents of piaware-config.txt; any changes made to this</span><br><span class="line"># file will be lost.</span><br><span class="line"></span><br><span class="line"># dump1090-fa won&#x27;t automatically start unless ENABLED=yes</span><br><span class="line">ENABLED=yes</span><br><span class="line"></span><br><span class="line">RECEIVER_OPTIONS=&quot;--device-index 1 --gain 50 --ppm 0&quot;</span><br><span class="line">DECODER_OPTIONS=&quot;--lat 31.170280 --lon 108.404610 --max-range 360 --fix&quot;</span><br><span class="line">NET_OPTIONS=&quot;--net --net-heartbeat 60 --net-ro-size 1300 --net-ro-interval 0.2 --net-ri-port 0 --net-ro-port 30002 --net-sbs-port 30003 --net-bi-port 30004,30104 --net-bo-port 30005&quot;</span><br><span class="line">JSON_OPTIONS=&quot;--json-location-accuracy 1&quot;</span><br></pre></td></tr></table></figure>

<p>修改完后，保存并退出。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>前面已经提到，由 FlightAware 所维护的 dump1090 是作为 Lighttpd 的一个模块而存在的，所以启动的方式是使用 lighty-enable-mod 加载这个模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dev:/home# lighty-enable-mod dump1090-fa</span><br><span class="line">root@dev:/home# service lighttpd force-reload</span><br></pre></td></tr></table></figure>

<p>加载这个模块后，重启使其生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dev:/home# reboot</span><br></pre></td></tr></table></figure>

<p>重启完成后，访问 <code>http://[N1 对应的 IP 地址]/dump1090-fa/</code>，就可以看到列在地图上的实时 ADS-B 数据了～</p>
<p><img data-src="https://c.ibcl.us/ADSB-Decode_20200118/3.jpg" alt="效果图" title="效果图"></p>
<h1 id="公开数据等喝茶"><a href="#公开数据等喝茶" class="headerlink" title="公开数据等喝茶"></a>公开数据等喝茶</h1><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>以 Frp 为例，服务器上已经安装好了 Frp 的服务端 Frps，传入端口为 7000，IP 地址 1.2.3.4，认证密钥为 ibcl.us。本地也安装好了 Frp 的客户端 Frpc，并通过 tcp 与服务器端建立连接。</p>
<p>给出 Frpc 的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 1.2.3.4</span><br><span class="line">server_port = 7000</span><br><span class="line">token = ibcl.us</span><br><span class="line">pool_count = 10</span><br><span class="line">tcp_mux = true</span><br><span class="line">login_fail_exit = false</span><br><span class="line">protocol = tcp</span><br><span class="line">tls_enable = true</span><br><span class="line">[a.ibcl.us]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 80</span><br><span class="line">use_encryption = false</span><br><span class="line">use_compression = true</span><br><span class="line">remote_port = 8082</span><br></pre></td></tr></table></figure>
<p>运行 Frpc，与服务器对接，随后登入服务器，修改 Nginx 的相关配置文件，将 8082 端口反向代理到 80 端口。</p>
<p>在 Nginx 相关配置文件里，加入反向代理的相关内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /</span><br><span class="line">&#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8082/dump1090-fa/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存并退出后，重载 Nginx，大功告成～</p>
<h2 id="坐等喝茶"><a href="#坐等喝茶" class="headerlink" title="坐等喝茶"></a>坐等喝茶</h2><p>根据某乎上某些大佬对相关法律政策的解读，个人私下接收 ADS-B 信号并不构成违法。好比收听传统的无线电广播，ADS-B 的原理也注定了它不可能被禁止，毕竟，ADS-B 也是无线电广播，而且，严禁收听敌台的年代已经成为历史。</p>
<p>话是这样说没错啦，但据这位大佬的介绍，若将接收到的 ADS-B 数据公开或是传送至境外组织，则是违法行为…</p>
<p>《中华人民共和国无线电管理条例（2016）》中第七十五条提到：</p>
<blockquote>
<p>违反本条例规定，有下列行为之一的，由无线电管理机构责令改正；拒不改正的，没收从事违法活动的设备，并处 3 万元以上 10 万元以下的罚款；造成严重后果的，并处 10 万元以上 30 万元以下的罚款：</p>
<ol>
<li>研制、生产、销售和维修大功率无线电发射设备，未采取有效措施抑制电波发射；</li>
<li>境外组织或者个人在我国境内进行电波参数测试或者电波监测；</li>
<li>向境外组织或者个人提供涉及国家安全的境内电波参数资料。</li>
</ol>
</blockquote>
<p>所以… 博主违法了？</p>
<p>所以… 博主会被请喝茶？</p>
<p>值得一提的是，直至目前，国内已有好几起因接收 ADS-B 信号并为 FlightRadar24 等组织提供实时航班数据而被<del>有关部门</del>没收接收设备的案例。</p>
<p>或许… 博主的名字会出现在下一批名单中？</p>
<p>那么，还请诸位看官静候博主喝茶归来的消息（大雾</p>
]]></content>
      <categories>
        <category>广播</category>
      </categories>
      <tags>
        <tag>广播</tag>
        <tag>原创</tag>
        <tag>SDR</tag>
        <tag>瞎搞</tag>
      </tags>
  </entry>
  <entry>
    <title>老乡别走：搭建自己的 Telegram 可转债机器人</title>
    <url>/BondBot-Telegram_20230524/</url>
    <content><![CDATA[<p>在博主的高中时代，曾经意外接触到一本名为「段子手股民的忏悔录」的书，出于兴趣，在博主满 18 岁那天的早上，便果断给自己开了一个股票账户，从此入坑大 A 股海。</p>
<p>由于博主资金体量不大，而大 A 市场也不能以零股形式交易，所以博主长期以来的持仓，都只能靠几只稳如老狗的银行股和几个行业 ETF 苟活。直到有一天，博主在刷雪球时看到，原来像博主这样的小散户，还能透过可转债打新的方式，靠运气赚点零花钱。</p>
<p>不幸的是，可转债这种东西，并不是每天都能申购的。作为一个懒人，每天一早打开炒股软件，生无可恋地看一眼自己绿油油的收益，再去看有没有能申购的新可转债，实在是一件很痛苦的事情。</p>
<p>多亏博主心理比较强大，也坚信价值投资的意义，否则就成为被收割的韭菜了。在痛苦之余，博主也曾思考，能否写一个小程序，获取每日的可转债并通知博主申购呢？</p>
<p>也好在博主是 Telegram 的常驻用户，同时，Telegram 也提供了健全的生态，以支援平台下的机器人开发，于是博主萌生了写一个 Telegram 可转债机器人的想法。</p>
<p>这篇文章，将会分享博主编写简单的 Telegram 可转债机器人时的一些思路，并介绍如何将其搭建在云服务器上，实现每天给自己或是往几个朋友组建的小群里自动推送可供当日申购的可转债，推动「共同富裕」。</p>
<p><img data-src="https://c.ibcl.us/BondBot-Telegram_20230524/1.jpg" alt="博主 2022 打新收益"></p>
<span id="more"></span>

<h1 id="寻找数据来源"><a href="#寻找数据来源" class="headerlink" title="寻找数据来源"></a>寻找数据来源</h1><p>既然需要推送当日可转债，那就需要一个靠谱的数据来源了。在博主综合比较多个网站过后，最后瞄准了东方财富的<span class="exturl" data-url="aHR0cHM6Ly9kYXRhLmVhc3Rtb25leS5jb20veGcveGcvP21rdD1reno=">新股申购与中签查询<i class="fa fa-external-link-alt"></i></span>。</p>
<p>东方财富的债券接口是 <code>https://datacenter-web.eastmoney.com/api/data/v1/get</code>，请求方法为 GET。除此之外，在请求时，还需要带上一些额外的参数才能正确响应。</p>
<p>经过博主摸索和测试，最后总结出来可用于获取可转债列表的接口调用方法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET https://datacenter-web.eastmoney.com/api/data/v1/get?callback=_&amp;sortColumns=PUBLIC_START_DATE&amp;sortTypes=-1&amp;pageNumber=1&amp;quoteType=0&amp;reportName=RPT_BOND_CB_LIST&amp;columns=ALL&amp;quoteColumns=f2~01~CONVERT_STOCK_CODE~CONVERT_STOCK_PRICE,f235~10~SECURITY_CODE~TRANSFER_PRICE,f236~10~SECURITY_CODE~TRANSFER_VALUE,f2~10~SECURITY_CODE~CURRENT_BOND_PRICE,f237~10~SECURITY_CODE~TRANSFER_PREMIUM_RATIO,f239~10~SECURITY_CODE~RESALE_TRIG_PRICE,f240~10~SECURITY_CODE~REDEEM_TRIG_PRICE,f23~01~CONVERT_STOCK_CODE~PBV_RATIO</span><br></pre></td></tr></table></figure>

<p>此外，由于东方财富的可转债接口为了实现跨域请求，返回值没有使用日常开发常用的 JSON 格式，而是使用了 JSONP 格式，将数据包裹在 <code>_</code> 这个 callback 中。</p>
<h1 id="解析-JSONP"><a href="#解析-JSONP" class="headerlink" title="解析 JSONP"></a>解析 JSONP</h1><p>博主决定使用 Golang 来实现这个小需求，但是苦于 Golang 中的标准库没有提供 JSONP 的解析方式，所以还需要博主自行编写一个包装器来解析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> JsonpWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">	Prefix     <span class="type">string</span>    <span class="comment">// 指定 callback 前缀</span></span><br><span class="line">	Underlying io.Reader <span class="comment">// 在底层提供 JSONP 数据</span></span><br><span class="line"></span><br><span class="line">	gotPrefix <span class="type">bool</span>       <span class="comment">// 指示是否读到 callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 <code>JsonpWrapper</code> 的实例化后的名称为 <code>jpw</code>，那么实现 <code>jpw.Read()</code> 方法的流程如下所述。</p>
<ol>
<li>若已读取过前缀（即 <code>jpw.gotPrefix</code> 为 <code>true</code>，则直接调用 <code>jpw.Underlying.Read(b)</code> 从底层的 JSONP 数据源读取数据，并返回结果；若未读取过前缀，则创建一个与前缀长度相同的字节数组 <code>prefix</code></li>
<li>调用 <code>io.ReadFull</code> 方法从 <code>jpw.Underlying</code> 中读取与前缀长度相同的字节，并将结果存储在 <code>prefix</code> 中</li>
<li>若读取前缀的结果与指定的前缀字符串 <code>jpw.Prefix</code> 不同，则返回读取的字节数 n 和错误，表明前缀不匹配</li>
<li>若读取到的前缀与指定前缀相同，则创建一个长度为 1 的字节数组 <code>char</code></li>
<li>连续从 <code>jpw.Underlying</code> 中逐字节读取，并将结果存储在 <code>char</code> 中，直到遇到 <code>(</code> 字符为止</li>
<li>将 <code>jpw.gotPrefix</code> 设置为 <code>true</code>，标记已经读取到了前缀</li>
<li>调用 <code>jpw.Underlying.Read(b)</code> 从底层数据源读取数据，并返回结果</li>
</ol>
<p>根据上述流程，可以编写如下代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jpw *JsonpWrapper)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> jpw.gotPrefix &#123;</span><br><span class="line">		<span class="keyword">return</span> jpw.Underlying.Read(b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	prefix := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(jpw.Prefix))</span><br><span class="line">	n, err := io.ReadFull(jpw.Underlying, prefix)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">string</span>(prefix) != jpw.Prefix &#123;</span><br><span class="line">		<span class="keyword">return</span> n, fmt.Errorf(</span><br><span class="line">            <span class="string">&quot;JSONP prefix mismatch: expected %q, got %q&quot;</span>,</span><br><span class="line">			jpw.Prefix, prefix)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> char[<span class="number">0</span>] != <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">		n, err = jpw.Underlying.Read(char)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> || err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jpw.gotPrefix = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> jpw.Underlying.Read(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以使用 <code>JsonpWrapper</code> 来解析 JSONP 数据了。例如，有一串 JSONP 数据如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">_</span>(&#123;<span class="string">&quot;data&quot;</span>:[],<span class="string">&quot;success&quot;</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>那么可以使用如下方法来解析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := strings.NewReader(<span class="string">`_(&#123;&quot;data&quot;:[1, 2, 3],&quot;success&quot;:true&#125;)`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data            []any <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">    Success <span class="type">bool</span>    <span class="string">`json:&quot;success&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := json.NewDecoder(&amp;JsonpWrapper&#123;</span><br><span class="line">    Prefix:     <span class="string">&quot;_&quot;</span>, <span class="comment">// 指定 callback 名称，需要与 JSONP 数据中的前缀相同</span></span><br><span class="line">    Underlying: r, <span class="comment">// 透过 strings.NewReader() 实现 io.Reader 接口</span></span><br><span class="line">&#125;).Decode(&amp;data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="略过节假日"><a href="#略过节假日" class="headerlink" title="略过节假日"></a>略过节假日</h1><p>由于节假日是不会开市的，所以在获取可转债列表时，需要略过节假日，以避免多余的推送打扰了在节假日休息的博主。</p>
<p>麻烦的是，除了日常的周末外，还有一些特殊的节假日，例如春节、劳动节等，为了避免麻烦，所以博主决定用别人写好的库来判断是否为节假日，这里使用的是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FkbWluZ3l1L2dvLXdvcmtpbmdkYXk=">go-workingday<i class="fa fa-external-link-alt"></i></span>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FkbWluZ3l1L2dvLXdvcmtpbmdkYXk=">go-workingday<i class="fa fa-external-link-alt"></i></span> 的调用方法也很简单，只需要调用 <code>workingday.IsWorkDay()</code> 方法，传入日期和地区即可，例如 <code>workingday.IsWorkDay(time.Now(), &quot;CN&quot;)</code>。</p>
<p>博主在阅读了这个库的源码后，发现这个库的实现也很简单粗暴，原理是请求了一个网上的 <span class="exturl" data-url="aHR0cDovL3BjLnN1aXNoZW55dW4ubmV0L3BlYWNvY2svYXBpL2g1L2Zlc3RpdmFs">API<i class="fa fa-external-link-alt"></i></span> 来判断是否为节假日。</p>
<h1 id="对接-Telegram"><a href="#对接-Telegram" class="headerlink" title="对接 Telegram"></a>对接 Telegram</h1><p>这里用到了 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvLXRlbGVncmFtLWJvdC1hcGkvdGVsZWdyYW0tYm90LWFwaQ==">telegram-bot-api<i class="fa fa-external-link-alt"></i></span> 这个库，这个库的使用方法也很简单，只需要调用 <code>tgbotapi.NewBotAPI()</code> 方法，传入 Bot Token 即可完成 Bot 的实例化。</p>
<p>示例代码如下，博主按照<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9tL2FydGljbGVzLzEwMjYyODgx">这个教程<i class="fa fa-external-link-alt"></i></span>申请了一个 Telegram Bot，然后将 Bot Token 传入 <code>tgbotapi.NewBotAPI()</code> 方法即可完成对接，向指定用户发送消息。</p>
<p>需要注意，由于 Telegram 在中国被屏蔽，所以需要使用代理才能正常使用。所以博主在运行程序前，需要设置 <code>HTTPS_PROXY</code> 环境变量，例如在 Linux 下运行 <code>export HTTPS_PROXY=http://127.0.0.1:10809</code> 命令。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 Bot</span></span><br><span class="line"><span class="comment">// 假设 Bot Token 为 123456789:abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line">bot, err := tgbotapi.NewBotAPI(<span class="string">&quot;123456789:abcdefghijklmnopqrstuvwxyz&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取消息间隔</span></span><br><span class="line">u := tgbotapi.NewUpdate(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 设定超时</span></span><br><span class="line">u.Timeout = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向用户发送消息</span></span><br><span class="line"><span class="comment">// 假设用户的 ID 为 987654321</span></span><br><span class="line">msg := tgbotapi.NewMessage(</span><br><span class="line">    <span class="number">987654321</span>, <span class="string">&quot;Hello World!&quot;</span>,</span><br><span class="line">)</span><br><span class="line">bot.Send(msg)</span><br></pre></td></tr></table></figure>

<p>至于如何取得用户或群组 ID，可以参考<span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMjMwNTIxMDYwNjU2L2h0dHBzOi8vd3cuc2pmbi5jb20vcG9zdC90ZWxlZ3JhbS1nZXQtaWQuaHRtbA==">这篇教程<i class="fa fa-external-link-alt"></i></span>。</p>
<h1 id="成品和实战"><a href="#成品和实战" class="headerlink" title="成品和实战"></a>成品和实战</h1><p>博主已经将上述的代码整合到了一个完整的程序中，可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvYm9uZC1ib3Q=">GitHub - bclswl0827/bond-bot<i class="fa fa-external-link-alt"></i></span> 找到。</p>
<p>由于博主的朋友也在打新可转债，所以博主将程序部署到了自己的云服务器上，每天早上 9 点 30 分自动推送可转债列表，以便大家及时了解可转债的情况。</p>
<p>用户可以自行决定推送的时间，例如在每天 10 点整推送可转债信息，只需要修改 <code>config.json</code> 配置文件即可，配置文件中的时间一律为北京时间。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456789:abcdefghijklmnopqrstuvwxyz&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;chat_id&quot;</span><span class="punctuation">:</span> <span class="number">987654321</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hour&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minute&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>最后附上推送效果截图。</p>
<p><img data-src="https://c.ibcl.us/BondBot-Telegram_20230524/2.png" alt="中签的博主"></p>
]]></content>
      <categories>
        <category>股市</category>
      </categories>
      <tags>
        <tag>股票</tag>
        <tag>可转债</tag>
        <tag>A 股</tag>
        <tag>韭菜</tag>
        <tag>Golang</tag>
        <tag>Telegram 机器人</tag>
      </tags>
  </entry>
  <entry>
    <title>今天继续手把手教大家如何喝茶</title>
    <url>/FY-2x_20211104/</url>
    <content><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>出了这么大一事儿，博主才想起自己还有个博客…… 直到有人开始传博主也是因为被喝了茶，才金盆洗手同无线电一刀两断时，博主这才觉得有必要出来冒个泡了。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/1.jpg" alt="1" title="1"></p>
<p>继 ADS-B、AIS 玩家挨个被慰问过后，各种另类版本也冒了出来，有说自己建气象站被喝茶的，有说玩 FT8 会被喝茶的，还有说用别人 KiwiSDR 也会被喝茶的（这都什么牛马？）…… 照这趋势，以后是不是车上听个对岸中波电台也要被喝茶了？</p>
<p>既然干啥都会被喝茶，那喝茶就得喝得有逼格，鉴于以上种种，博主这次就来手把手教大家如何通过“架设气象观测设备”喝茶。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/2.jpg" alt="2" title="2"></p>
<h1 id="境外势力的风云二号观测设备"><a href="#境外势力的风云二号观测设备" class="headerlink" title="境外势力的风云二号观测设备"></a>境外势力的风云二号观测设备</h1><span id="more"></span>

<p><a href="https://ibcl.us/">I BCL.</a> 网站从没备过案，服务器也一直丢国外，所以博主是妥妥的境外势力。博主这次接收风云二号的全盘云图，相当于泄漏国家敏感气象资讯，就是妥妥的给境外势力递刀子行为。如此惊天地泣鬼神，拜登看了都恨不得哭着给博主转账 500 万作气象战经费。</p>
<p>500 万气象战经费，附赠一杯国安局清茶，美中两边便宜都占了，看官的你是否心动？</p>
<h1 id="刺探风云二号情报"><a href="#刺探风云二号情报" class="headerlink" title="刺探风云二号情报"></a>刺探风云二号情报</h1><p>就在刚刚，博主接到了 CIA 探员发来的信息，目前中国的风云二号系列全是静轨卫星，并有如下卫星仍在工作。</p>
<ul>
<li>风云二号 F 星（112° E）（快挂了）</li>
<li>风云二号 G 星（99° E）</li>
<li>风云二号 H 星（79° E）</li>
</ul>
<p>不过这位探员眼看时间来到三点几，不得不去饮茶，所以没做细致调查，剩下的工作就得全部交由博主一人做。</p>
<p>在动用各种社会工程学人际关系网络后，博主得知，目前开源的风云二号收图方案，是接收 1687.5 MHz，位于 L 波段的 VISSR 业务。</p>
<p>VISSR 全称 Visible and Infrared Spin Scan，中文名可见与红外自旋扫描辐射计，下传高解析度的云图数据，这对于博主这种境外势力，这可是巨大的诱惑，因为只有高解析度的气象云图，才能更精准地发动气象战。</p>
<h1 id="风云二号发播形式"><a href="#风云二号发播形式" class="headerlink" title="风云二号发播形式"></a>风云二号发播形式</h1><p>买通了中国国家卫星气象中心的高层后，博主总算掌握到了风云二号的基本发播格式，只有拿到全盘图的发播时间和规律，才能更有针对性地分析天气，发动气象战。</p>
<table>
<thead>
<tr>
<th align="left">全盘图</th>
<th align="left">信标</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0’ - 30’</td>
<td align="left">30’ - 60’</td>
</tr>
</tbody></table>
<p>博主写到这里，门突然被撞开，吓得博主立马盖上笔记本，转头一看，原来是室友，门本来也没锁，看来做境外势力可比粉红难多了。</p>
<h1 id="博主开始暗地采购了"><a href="#博主开始暗地采购了" class="headerlink" title="博主开始暗地采购了"></a>博主开始暗地采购了</h1><p>以科研为由，博主从某位商家那里买下了口径 180 公分的四威牌 C 波段大锅，和商家闲聊数句，得知到最近买这样大锅的人突然多了起来，这不禁让博主怀疑，身边的境外势力会不会不止博主一个？</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/3.jpg" alt="3" title="3"></p>
<p>通过拜托不相干的人从咸鱼代购，博主弄到了一块 SAWBird LNA 板子，售价 360 元。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/4.jpg" alt="4" title="4"></p>
<p>普通的 C 波段馈源不适用于 L 波段的接收，所以需要对馈源进行改造。正值那位 CIA 探员饮茶返来，他建议博主做个探针天线，博主忙活了一个晚上，信了他的邪，啥也收不到。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/5.jpg" alt="5" title="5"></p>
<p>最后博主从网上找了个菱形天线的制作方法，依葫芦画瓢整了个简陋馈源出来。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/6.jpg" alt="6" title="6"></p>
<p>线径 1.5 mm，菱边 40 mm，菱角相互垂直，反射面铺铜箔并接地，丑是丑了点，可最后居然把棒子国的 GK-2A 给收下了。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/7.jpg" alt="7" title="7"></p>
<p>SDR 部分，CIA 探员不晓得从哪弄来个 Airspy Mini……</p>
<p>Spy？这不摆明了博主间谍行为？不行，得改，名字得改成 Airclean Mini。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/8.jpg" alt="8" title="8"></p>
<p>差不多了，博主将这些零件拆分打包，找了个人少的楼，三天分三次运到了楼顶天台。</p>
<h1 id="部署软件"><a href="#部署软件" class="headerlink" title="部署软件"></a>部署软件</h1><p>那个 CIA 探员又告诉博主，他通过检索 GitHub，已经看到已经有现成的开源解码软件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsdGlsbGltaXR5L1NhdER1bXA=">SatDump<i class="fa fa-external-link-alt"></i></span>。</p>
<p>好，安排上。</p>
<p>连上 Tor，找了个非洲的 Debian 镜像站，下了三天三夜，终于把 Debian 拖下来，作为境外势力，匿名上网是基本操作，多等几天也没问题。</p>
<p>装上 Debian，换上非洲的软件源，开始安装桌面环境，LXDE 又花了三天，好了，终于轮到部署 SatDump 了。</p>
<p>先完善软件依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@yuki-pc:~$ sudo apt install git build-essential cmake g++ pkgconf libfftw3-dev libvolk1-dev libjpeg-dev libpng-dev librtlsdr-dev libhackrf-dev libairspy-dev libairspyhf-dev libglew-dev libglfw3-dev</span><br></pre></td></tr></table></figure>

<p>博主用的 Debian 11，结果完善依赖时报错了，原因是 Debian 11 中，<code>libvolk1-dev</code> 已被 <code>libvolk2-dev</code> 取代（Ubuntu 也是如此）。</p>
<p>依赖补齐后，从源码编译安装 <code>libnng-dev</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@yuki-pc:~$ git clone https://github.com/nanomsg/nng.git ~/nng</span><br><span class="line">yuki@yuki-pc:~$ mkdir -p ~/nng/build; cd ~/nng</span><br><span class="line">yuki@yuki-pc:~/nng/build$ cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=/usr</span><br><span class="line">yuki@yuki-pc:~/nng/build$ make -j4</span><br><span class="line">yuki@yuki-pc:~/nng/build$ sudo make install</span><br><span class="line">yuki@yuki-pc:~/nng/build$ cd ~</span><br></pre></td></tr></table></figure>

<p>从 GitHub 拉取 SatDump 源码，从源码编译 SatDump。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@yuki-pc:~$ git clone https://github.com/altillimity/SatDump.git --depth 1 ~/SatDump</span><br><span class="line">yuki@yuki-pc:~$ mkdir -p ~/SatDump/build; cd ~/SatDump</span><br><span class="line">yuki@yuki-pc:~/SatDump/build$ cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr</span><br><span class="line">yuki@yuki-pc:~/SatDump/build$ make -j4</span><br><span class="line">yuki@yuki-pc:~/SatDump/build$ ln -s ../pipelines .</span><br><span class="line">yuki@yuki-pc:~/SatDump/build$ ln -s ../resources .</span><br><span class="line">yuki@yuki-pc:~/SatDump/build$ ln -s ../Ro* .</span><br></pre></td></tr></table></figure>

<p>运行 SatDump，不出意外，带 GUI 的 SatDump 已经成功启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@yuki-pc:~/SatDump/build$ ./satdump-ui</span><br></pre></td></tr></table></figure>

<h1 id="拜登经费到账"><a href="#拜登经费到账" class="headerlink" title="拜登经费到账"></a>拜登经费到账</h1><p>来到天台，支起大锅，按如下流程安装设备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">锅 --&gt; 馈源 --&gt; 馈线 --&gt; LNA（需额外供电） --&gt; SDR --&gt; 电脑</span><br></pre></td></tr></table></figure>

<p>和收听敌台、翻墙不一样，敌台能躲在被窝里边听，墙能躺在沙发上翻，气象数据却得跑外边去收集，或许这就是作为境外势力默默承受的压力吧。</p>
<p>想到这里，博主叹一口气，然而想到拜登的经费就快要到账，博主又振作了起来。</p>
<p>插入 Airclean Mini，将 SatDump 标签页切换到 Live processing，指定 Pipeline 为 FengYun-2 S-VISSR，然后选择云图输出目录。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/9.jpg" alt="9" title="9"></p>
<p>将 Samplerate 改为 1000000，然后按下 Start，启动解码器，一坨绿色的星座图出现。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/10.jpg" alt="10" title="10"></p>
<p>要成功收集气象数据，这坨星座图就得分成两半才行。博主打算先干位于 99° E 的风云 2G，无奈不知道方位角该转到多少，只得拿出一台随身携带的菊花牌备用机，打开 <span class="exturl" data-url="aHR0cHM6Ly9kaXNocG9pbnRlci5jb20v">dishpointer.com<i class="fa fa-external-link-alt"></i></span>，在线计算方位角。</p>
<p>输入博主所在坐标，得出接收风云 2G 方位角是 212.5°，借助罗盘 APP，转动天线到相应位置。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/11.jpg" alt="11" title="11"></p>
<p>正值整点，博主看到了星座图有分离的趋势，把增益开最大，解码器上的 SNR 来到了 10 dB，解码正式开始，拜登经费即将到账。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/12.jpg" alt="12" title="12"></p>
<p>根据气象中心的高层的说法，风云下传的图像数据有如下类型。</p>
<table>
<thead>
<tr>
<th align="left">通道</th>
<th align="left">类型</th>
<th>解析度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FY-2x_1</td>
<td align="left">可见光</td>
<td>9160 x 10004</td>
</tr>
<tr>
<td align="left">FY-2x_2</td>
<td align="left">红外线</td>
<td>2291 x 2501</td>
</tr>
<tr>
<td align="left">FY-2x_3</td>
<td align="left">水蒸气</td>
<td>2291 x 2501</td>
</tr>
<tr>
<td align="left">FY-2x_4</td>
<td align="left">红外线</td>
<td>2291 x 2501</td>
</tr>
<tr>
<td align="left">FY-2x_5</td>
<td align="left">红外线</td>
<td>2291 x 2501</td>
</tr>
</tbody></table>
<p>等待 Receiving 进度条到 100%，接收完成。打开此前指定的云图输出目录，可以看到六个文件，前五个文件和上表中图像类型一一对应，多出来的一张，是 SatDump 自动根据 Colour Look-Up Table 生成的假彩色图片。</p>
<p>六张图用去 163 MB，可见光和假彩图占了大头。而其中由可见光通道生成的假彩色图片中，中国全境云层情况清晰可见。</p>
<p><img data-src="https://c.ibcl.us/FY-2x_20211104/13.jpg" alt="13" title="13"></p>
<p>支付宝传来拜登的到账提示，境外势力的风云二号观测设备完成了他的使命，博主笑麻了。</p>
<h1 id="笑麻过后该被喝茶了"><a href="#笑麻过后该被喝茶了" class="headerlink" title="笑麻过后该被喝茶了"></a>笑麻过后该被喝茶了</h1><p>CCAV 的对无线电爱好者的“深入调查”一推出，就受到广泛关注，可造成的负面影响是：无线电爱好者现在不论玩什么，都会被当作间谍、境外势力。这其中，媒体不专业的配图和解说和以偏概全的话术，占了不可估量的功劳，不愧是外行领导内行的典范。</p>
<p>在这玩 FT8 都可能被当作间谍的年头，博主不禁陷入沉思：某些人一边喊“中国全世界最安全”，一边却又说“境外势力已经入侵中国”，这岂不自相矛盾？</p>
<p>也许吧，管他毛不矛盾，反正最大赢家肯定又是中国，中国又赢麻了。</p>
<p>忽然间想起一句话，想要赠予本站所有读者朋友共勉之。</p>
<blockquote>
<p>无知即力量，战争即和平，自由即奴役。</p>
</blockquote>
<p>麻了。</p>
]]></content>
      <categories>
        <category>SDR</category>
      </categories>
      <tags>
        <tag>广播</tag>
        <tag>原创</tag>
        <tag>SDR</tag>
        <tag>软件无线电</tag>
        <tag>风云二号</tag>
        <tag>气象卫星</tag>
      </tags>
  </entry>
  <entry>
    <title>别样的 GK2A 气象卫星接收大战</title>
    <url>/GK2A-Decode_20190811/</url>
    <content><![CDATA[<blockquote>
<p>一天，BH4ERB 给我发来消息他说：“你敢不敢和我接收 GK2A 气象卫星”，我豪爽的答应了：“我当然敢”，周日下午在 xx 路 xx 大厦举行，谁不来谁就是怂货。</p>
</blockquote>
<blockquote>
<p>我原本以为我恐吓了 BH4ERB，BH4ERB 应该躲在家，不敢找我，可正当这时，我听见了音乐声，原来是我手机响了，一看，竟然是 BH4ERB 发来的消息，他还真有勇气，我接通了电话，听道电话那头骂道：“<del>小废物，你怎么还不来，再不来你妈的泌尿系统就被我搞坏了。</del>”我听到他对我的毒骂之后，我回骂道：“<del>我要把你挂到同性恋网站上，帮你炒作一番，你说好不好啊。</del>”</p>
</blockquote>
<blockquote>
<p>他吓得没再回应我，可是到了周日，BH4ERB 竟然又给我发消息了，他还真要和我举行接收大战，于是我按照约定，到达了 xx 大厦，可他已经等我很久了。</p>
</blockquote>
<p>……</p>
<p>GK2A 是韩国的气象卫星，由韩国气象厅开发，KARI 制造。于 2018 年 12 月 4 日由欧洲航天局的阿丽亚娜 5 号将其送上轨道，属于地球同步卫星。</p>
<p>最近 HAM 大佬  BH4ERB 对这颗卫星感上了兴趣，决定尝试接收并解码 GK2A 下传的数据。</p>
<p>接收数据需要使用到一个名为 Goestools 的工具，钦定在 Linux 下运行。由于 BH4ERB 对 Linux 并不熟悉，在多次尝试编译安装，却报错无法启动之后，找到了博主帮忙，希望跟博主一起合作填完这个巨坑。</p>
<span id="more"></span>

<h2 id="准备设备"><a href="#准备设备" class="headerlink" title="准备设备"></a>准备设备</h2><ul>
<li>树莓派或 x86 主机（钦定 Linux 系统）</li>
<li>RTL-SDR 或 Airspy（钦定接收设备）</li>
<li>LNA 放大器</li>
<li>强烈安利 2.4G 栅格天线（大锅盖+螺旋天线亦可）</li>
</ul>
<p>BH4ERB 选用的是一台 x86 主机，在博主的安利下装了 Debian Buster 服务器版，SDR 选用的是 Airspy R2，搭配 2.4G 栅格天线，方位角对准 160 度。</p>
<p><img data-src="https://c.ibcl.us/GK2A-Decode_20190811/1.jpg" alt="x86 旧主机" title="x86 旧主机"></p>
<p><img data-src="https://c.ibcl.us/GK2A-Decode_20190811/2.jpg" alt="Airspy R2 + 1.7GHz LNA" title="Airspy R2 + 1.7GHz LNA"></p>
<p><img data-src="https://c.ibcl.us/GK2A-Decode_20190811/3.jpg" alt="2.4G 栅格天线" title="2.4G 栅格天线"></p>
<p>值得注意的是，栅格天线前端需要反方向安装。</p>
<p>由于篇幅所限，安装天线、Linux 系统等过程和安装完成后的更换软件源等操作不再赘述（其实是懒得写）。</p>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>首先 SSH 连上主机，更新一波软件源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ sudo apt update</span><br></pre></td></tr></table></figure>

<p>由于是采用编译安装，所以要准备编译的环境。</p>
<p>一次性安装所有需要的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ sudo apt install wget build-essential cmake zlib1g-dev git python3 python3-pip unzip libusb-1.0-0-dev pkg-config libairspy-dev rtl-sdr librtlsdr-dev libopencv-dev</span><br></pre></td></tr></table></figure>

<h3 id="编译安装-Goestools"><a href="#编译安装-Goestools" class="headerlink" title="编译安装 Goestools"></a>编译安装 Goestools</h3><p>此外，Goestools 还需要依赖于 Airspy、RTL-SDR 的驱动才能正常工作，所以在编译安装 Goestools 之前还需要手动编译安装 Airspy、RTL-SDR 的相关驱动及支持库。</p>
<p>编译 Airspy 的驱动及支持库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ git clone https://github.com/airspy/airspyone_host</span><br><span class="line">BH4ERB@pc:~$ cd airspyone_host</span><br><span class="line">BH4ERB@pc:~/airspyone_host$ mkdir build</span><br><span class="line">BH4ERB@pc:~/airspyone_host$ cd build</span><br><span class="line">BH4ERB@pc:~/airspyone_host/build$ cmake ../ -DINSTALL_UDEV_RULES=ON</span><br><span class="line">BH4ERB@pc:~/airspyone_host/build$ make</span><br><span class="line">BH4ERB@pc:~/airspyone_host/build$ sudo make install</span><br><span class="line">BH4ERB@pc:~/airspyone_host/build$ sudo ldconfig</span><br><span class="line">BH4ERB@pc:~/airspyone_host/build$ cd ../..</span><br></pre></td></tr></table></figure>

<p>接着编译安装 RTL-SDR 的驱动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ git clone https://github.com/osmocom/rtl-sdr.git</span><br><span class="line">BH4ERB@pc:~$ cd rtl-sdr</span><br><span class="line">BH4ERB@pc:~/rtl-sdr$ mkdir build</span><br><span class="line">BH4ERB@pc:~/rtl-sdr$ cd build</span><br><span class="line">BH4ERB@pc:~/rtl-sdr/build$ cmake ../ -DINSTALL_UDEV_RULES=ON</span><br><span class="line">BH4ERB@pc:~/rtl-sdr/build$ make</span><br><span class="line">BH4ERB@pc:~/rtl-sdr/build$ sudo make install</span><br><span class="line">BH4ERB@pc:~/rtl-sdr/build$ sudo ldconfig</span><br><span class="line">BH4ERB@pc:~/rtl-sdr/build$ cd ../..</span><br></pre></td></tr></table></figure>

<p>接下来才是编译 Goestools。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ git clone --recursive https://github.com/sam210723/goestools</span><br><span class="line">BH4ERB@pc:~$ cd goestools</span><br><span class="line">BH4ERB@pc:~/goestools$ mkdir build</span><br><span class="line">BH4ERB@pc:~/goestools$ cd build</span><br><span class="line">BH4ERB@pc:~/goestools/build$ cmake ../ -DCMAKE_INSTALL_PREFIX=/usr/local</span><br><span class="line">BH4ERB@pc:~/goestools/build$ make</span><br><span class="line">BH4ERB@pc:~/goestools/build$ sudo make install</span><br><span class="line">BH4ERB@pc:~/goestools/build$ cd ../..</span><br></pre></td></tr></table></figure>

<p><em>由于 BH4ERB 没有意识到需要先安装驱动和支持库的这个问题，于是毫不犹豫地跳进了这个坑…（反面教材</em></p>
<p><em>所以在启动 Goestools 时，他得到了类似于这样的报错。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">terminate called after throwing an instance of &#x27;std::runtime_error&#x27;</span><br><span class="line">  what():  You configured goesrecv to use the &quot;airspy&quot; source, but goesrecv was not compiled with Airspy support. Make sure to install the Airspy library before compiling goestools, and look for a message saying &#x27;Found libairspy&#x27; when running cmake.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>

<p><em>要解决这个问题，只有安装了 Airspy 和 RTL-SDR 的驱动和支持库后，重新编译一次 Goestools。</em></p>
<p>Goestools 的配置文件位于 <code>~/goestools/etc/</code> 目录下，如果使用 RTL-SDR，需要对 <code>goesrecv.conf</code> 做一番修改，将第六行的 <code>source = &quot;airspy&quot;</code> 改为 <code>source = &quot;rtlsdr&quot;</code>，并注释掉 16～27 行的内容，在 29～34 行做相应调整，此外，配置文件中接收的频率保持默认就好。</p>
<h3 id="编译安装-xrit-rx"><a href="#编译安装-xrit-rx" class="headerlink" title="编译安装 xrit-rx"></a>编译安装 xrit-rx</h3><h4 id="什么鬼"><a href="#什么鬼" class="headerlink" title="什么鬼"></a>什么鬼</h4><p>这是专门用于接收 · 解码 GK2A 下行数据的一个工具，解码的数据以 <code>.lrit</code> 或是 <code>.jpg</code>、<code>.png</code>、<code>.gif</code> 的形式输出。xrit-rx 需要搭配 Goestools 食用。</p>
<h4 id="编译安装-踩坑"><a href="#编译安装-踩坑" class="headerlink" title="编译安装 + 踩坑"></a>编译安装 + 踩坑</h4><p>xrit-rx 用 Python 3 编写，开箱即用，<del>灰常方便</del>。</p>
<p>博主先把仓库 Clone 到了本地，启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ git clone https://github.com/sam210723/xrit-rx</span><br><span class="line">BH4ERB@pc:~$ cd xrit-rx/src</span><br><span class="line">BH4ERB@pc:~/xrit-rx/src$ chmod +x xrit-rx.py</span><br><span class="line">BH4ERB@pc:~/xrit-rx/src$ python3 xrit-rx.py</span><br></pre></td></tr></table></figure>

<p>然后… 报错了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;xrit-rx.py&quot;, line 10, in &lt;module&gt;</span><br><span class="line">    from demuxer import Demuxer</span><br><span class="line">  File &quot;/home/xrit-rx/src/demuxer.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    import ccsds as CCSDS</span><br><span class="line">  File &quot;/home/xrit-rx/src/ccsds.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    from Crypto.Cipher import DES</span><br><span class="line">ImportError: No module named &#x27;Crypto&#x27;</span><br></pre></td></tr></table></figure>

<p>原来是缺失模块，安装就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~/xrit-rx/src$ pip3 install -r ~/xrit-rx/requirements.txt </span><br></pre></td></tr></table></figure>

<p>安装好缺失模块后再试一次… 成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~/xrit-rx/src$ python3 xrit-rx.py</span><br><span class="line">┌──────────────────────────────────────────────┐</span><br><span class="line">│    xrit-rx - LRIT/HRIT Downlink Processor    │</span><br><span class="line">│         github.com/sam210723/xrit-rx         │</span><br><span class="line">└──────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">SPACECRAFT:       GK-2A</span><br><span class="line">DOWNLINK:         LRIT (64 kbps)</span><br><span class="line">INPUT SOURCE:     goesrecv (github.com/sam210723/goestools)</span><br><span class="line">OUTPUT PATH:      /root/xrit-rx/received</span><br><span class="line">KEY FILE:         EncryptionKeyMessage.bin.dec</span><br><span class="line">VERSION:          1.0.2</span><br><span class="line"></span><br><span class="line">Connecting to goesrecv (127.0.0.1)...[Errno 111] Connection refused</span><br><span class="line"></span><br><span class="line">Exiting...</span><br></pre></td></tr></table></figure>

<h4 id="导入密钥"><a href="#导入密钥" class="headerlink" title="导入密钥"></a>导入密钥</h4><p>解码 GK2A 的数据需要用到一个密钥，直至目前，该密钥适用于 GK2A 卫星所有的下传数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~/xrit-rx/src$ wget --no-check-certificate https://c.ibcl.us/GK2A-Decode_20190811/EncryptionKeyMessage_001F2904C905.bin</span><br></pre></td></tr></table></figure>

<p>然而这个密钥本身也是加密的，所以在食用前，还需要对密钥解密一次。</p>
<p>好在 xrit-rx 已经预置了解密的工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~/xrit-rx/src$ python3 tools/keymsg-decrypt.py EncryptionKeyMessage_001F2904C905.bin 001F2904C905</span><br></pre></td></tr></table></figure>

<p>解密后生成的密钥名为 <code>EncryptionKeyMessage.bin.dec</code>，位于 xrit-rx 的 src 目录下。</p>
<h2 id="万事俱备"><a href="#万事俱备" class="headerlink" title="万事俱备"></a>万事俱备</h2><h3 id="运行软件"><a href="#运行软件" class="headerlink" title="运行软件"></a>运行软件</h3><p>已经安装好了解码必须的软件，只需要运行对应的软件就可以了。</p>
<p>打开一个终端，先运行 Goesrecv，正常的话应该得到类似下面的回显。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ goesrecv -i 1 -c ~/goestools/etc/goesrecv.conf</span><br><span class="line">2019-08-10T13:12:29Z [monitor] gain: 15.41, freq:    -8.7, omega: 19.531, vit(avg): 1983, rs(sum):    0, packets:  0, drops:  5</span><br><span class="line">2019-08-10T13:12:30Z [monitor] gain: 40.18, freq:  -101.0, omega: 19.531, vit(avg): 1684, rs(sum):    0, packets:  0, drops:  5</span><br><span class="line">2019-08-10T13:12:31Z [monitor] gain: 60.61, freq: -1051.0, omega: 19.531, vit(avg): 1425, rs(sum):    0, packets:  0, drops:  8</span><br><span class="line">2019-08-10T13:12:32Z [monitor] gain: 77.26, freq: -3263.5, omega: 19.531, vit(avg):  736, rs(sum):    0, packets:  2, drops:  4</span><br><span class="line">2019-08-10T13:12:33Z [monitor] gain: 90.99, freq: -4634.3, omega: 19.531, vit(avg):   43, rs(sum):    0, packets:  8, drops:  0</span><br><span class="line">2019-08-10T13:12:34Z [monitor] gain: 102.21, freq: -4609.4, omega: 19.531, vit(avg):   41, rs(sum):    0, packets:  8, drops:  0</span><br><span class="line">2019-08-10T13:12:35Z [monitor] gain: 111.27, freq: -4615.9, omega: 19.531, vit(avg):   38, rs(sum):    0, packets:  8, drops:  0</span><br><span class="line">2019-08-10T13:12:36Z [monitor] gain: 118.72, freq: -4596.9, omega: 19.531, vit(avg):   43, rs(sum):    0, packets:  8, drops:  0</span><br><span class="line">2019-08-10T13:12:37Z [monitor] gain: 124.84, freq: -4568.5, omega: 19.531, vit(avg):   37, rs(sum):    0, packets:  7, drops:  0</span><br><span class="line">2019-08-10T13:12:38Z [monitor] gain: 129.86, freq: -4592.8, omega: 19.531, vit(avg):   44, rs(sum):    0, packets:  8, drops:  0</span><br><span class="line">2019-08-10T13:12:39Z [monitor] gain: 134.01, freq: -4578.2, omega: 19.531, vit(avg):   43, rs(sum):    0, packets:  8, drops:  0</span><br><span class="line">2019-08-10T13:12:40Z [monitor] gain: 137.48, freq: -4583.3, omega: 19.531, vit(avg):   39, rs(sum):    0, packets:  8, drops:  0</span><br></pre></td></tr></table></figure>

<p>然后另开一个终端，运行 xrit-rx，xrit-rx 随即会与 Goesrecv 模块建立连接，这时便开始解码了。</p>
<p>如果一切顺利，回显应该像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ cd xrit-rx/src</span><br><span class="line">BH4ERB@pc:~/xrit-rx/src$ python3 xrit-rx.py</span><br><span class="line">┌──────────────────────────────────────────────┐</span><br><span class="line">│    xrit-rx - LRIT/HRIT Downlink Processor    │</span><br><span class="line">│         github.com/sam210723/xrit-rx         │</span><br><span class="line">└──────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">SPACECRAFT:       GK-2A</span><br><span class="line">DOWNLINK:         LRIT (64 kbps)</span><br><span class="line">INPUT SOURCE:     goesrecv (github.com/sam210723/goestools)</span><br><span class="line">OUTPUT PATH:      /home/BH4ERB/xrit-rx/src/received</span><br><span class="line">KEY FILE:         EncryptionKeyMessage.bin.dec</span><br><span class="line">VERSION:          1.0.2</span><br><span class="line"></span><br><span class="line">Connecting to goesrecv (127.0.0.1)...CONNECTED</span><br><span class="line">Decryption keys loaded</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────                                                                           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[VCID 0] GK-2A: FULL DISK</span><br></pre></td></tr></table></figure>

<h3 id="得到图像"><a href="#得到图像" class="headerlink" title="得到图像"></a>得到图像</h3><p>一段时间后，xrit-rx 会自动将接收到的图片存为 .jpg 和 .gif 图像，生成的图像位于 /home/BH4ERB/xrit-rx/src/received，接收到的图片会自动根据时间来排序。</p>
<h2 id="Docker-大法"><a href="#Docker-大法" class="headerlink" title="Docker 大法"></a>Docker 大法</h2><p>为（作）了（为）方（Docker）便（的）起（信）见（徒），博主特地制作了一个用接收 GK2A 卫星的 Docker 镜像，以简化部署过程。</p>
<p>Dockerfile 位于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvR0syQS1Eb2NrZXI=">bclswl0827/GK2A-Docker<i class="fa fa-external-link-alt"></i></span>，总的来说，部署只需要三步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BH4ERB@pc:~$ docker volume create xrit-rx</span><br><span class="line">BH4ERB@pc:~$ sudo chmod -R 777 /var/lib/docker/volumes/xrit-rx</span><br><span class="line">BH4ERB@pc:~$ docker run -d -i -t \</span><br><span class="line">	--restart always \</span><br><span class="line">	--name=GK2A \</span><br><span class="line">	--device /dev/bus/usb \</span><br><span class="line">	-e DEVICE=airspy \</span><br><span class="line">	-e GAIN=50 \</span><br><span class="line">	-p 0.0.0.0:5001:5001 \</span><br><span class="line">	-p 0.0.0.0:5002:5002 \</span><br><span class="line">	-p 0.0.0.0:5004:5004 \</span><br><span class="line">	-p 0.0.0.0:6001:6001 \</span><br><span class="line">	-p 0.0.0.0:6002:6002 \</span><br><span class="line">	-v xrit-rx:/xrit-rx \</span><br><span class="line">	bclswl0827/gk2a-docker:latest</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果使用的是 RTL-SDR，则需要将部署命令中 <code>airspy</code> 字段替换为 <code>rtlsdr</code>。</p>
<p>此后，得到的图片便可在 Docker 持久卷路径 <code>/var/lib/docker/volumes/xrit-rx/_data/src/received</code> 下找到。</p>
<p>附上 BH4ERB 使用体验：</p>
<blockquote>
<p>香疯了！！！</p>
</blockquote>
<h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p><img data-src="https://c.ibcl.us/GK2A-Decode_20190811/4.jpg" alt="FD" title="FD"></p>
<p><img data-src="https://c.ibcl.us/GK2A-Decode_20190811/5.png" alt="TYIA" title="TYIA"></p>
<p><img data-src="https://c.ibcl.us/GK2A-Decode_20190811/6.gif" alt="UP50A" title="UP50A"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><h3 id="续写接收大战"><a href="#续写接收大战" class="headerlink" title="续写接收大战"></a>续写接收大战</h3><blockquote>
<p>第一回合，我占上风，他比不过我，到了第六回合，他就主动认输了。<br>　　<br>第二局，他开始占上风，我也不甘势弱，我们僵持了一百多个回合，我因为轻敌，被他击败了。<br>　　<br>从那时开始，我就不轻敌了，我认真研究他的套路，于是我总结出了一种方案。<br>　　<br>第二天，我们举行第三局，他使用祖传方案，对我发动猛烈的攻击，我们势均力敌，平分秋色，我们比了 3 个多小时，也没分出胜负。<br>　　<br>后来，他不知不觉的睡着了，我趁着这个好机会，一记 <code>rm -rf /*</code>，打的他不敢还手，对他的打击比砸了他的天线和 SDR 还大。</p>
</blockquote>
<p><em>改编自 <span class="exturl" data-url="aHR0cHM6Ly9lc3Uud2lraS8lRTMlODAlOEElRTUlODglQUIlRTYlQTAlQjclRTclOUElODQlRTclQTIlQjAlRTclQTIlQjAlRTglQkQlQTYlRTUlQTQlQTclRTYlODglOTglRTMlODAlOEI=">《别样的碰碰车大战》<i class="fa fa-external-link-alt"></i></span>。《别样的碰碰车大战》是我国作家张祥如创作的短篇小说，也是其代表作。作品讲述主人公凭着聪明才智，在强大敌人仵沉蛋的挑衅下，不畏强暴，敢于反抗，最后在碰碰车大战中取得胜利的故事。小说发表后，当时的社会流传“不读《碰碰车》，就无法在文坛混”的谚语。《别样的碰碰车大战》在叙事深度的挖掘上远远超出了同时代作家所能及的层次。它开创了后世“意识流小说”、“叙事小说”的先河。《别样的碰碰车大战》发表以来，被译成多种文字广为流传，<span class="exturl" data-url="aHR0cHM6Ly9lc3Uud2lraS8=">Esu.wiki<i class="fa fa-external-link-alt"></i></span> 收录了其原版作品。</em></p>
<h3 id="关于-BH4ERB-大佬"><a href="#关于-BH4ERB-大佬" class="headerlink" title="关于 BH4ERB 大佬"></a>关于 BH4ERB 大佬</h3><p>希望大佬别找我麻烦…</p>
<p>BH4ERB 大佬现居上海，折腾 GK2A 卫星时正值台风利奇马过境。</p>
<p>是大佬果然不一样，说出来的话都辣么有气势…</p>
<blockquote>
<p>我要看着台风从我头顶上过去。</p>
</blockquote>
<p>博主还能说什么呢，希望天线不要被吹倒吧…</p>
<p>溜了溜了～～</p>
]]></content>
      <categories>
        <category>广播</category>
      </categories>
      <tags>
        <tag>广播</tag>
        <tag>原创</tag>
        <tag>SDR</tag>
        <tag>瞎搞</tag>
      </tags>
  </entry>
  <entry>
    <title>记与一款 JJY 电波钟模块的邂逅</title>
    <url>/JJY-Timecode_20230522/</url>
    <content><![CDATA[<p>某日，博主在逛淘宝时，发现了一款电波钟模块。</p>
<p><img data-src="https://c.ibcl.us/JJY_Timecode_20230522/1.png" alt="JJY 电波钟模块"></p>
<p>博主第一次听说长波授时的概念还是在上初中的时候，出于兴趣，当年也下单了过一个 CASIO 出口转内销的电波授时闹钟。如今距离买下这款闹钟已有快七年时间了，虽然当年买的电波钟外壳已经泛黄，但是时间仍然分毫不差。如今刷到这么一个模块，又唤起了博主的回忆。</p>
<p>在这七年间，博主也曾经尝试弄清楚电波授时的解码原理以及数据报文格式，但是迫于当年的知识面与技术并不到位，所以在几次尝试与几次失败后，博主便放弃了。</p>
<p>而如今博主作为一个通信工程大学牲，想要再次挑战弄懂 JJY 长波授时的时间码结构，并尝试编写程序解码准确时间，于是果断下单了这款模块。</p>
<p>在收到模块后，经过两天的不懈努力，博主也终于成功达成了目标，了结了七年来的心事。这篇文章，会分享博主玩转 JJY 时间码模块的过程。</p>
<span id="more"></span>

<h1 id="模块引脚与电平逻辑"><a href="#模块引脚与电平逻辑" class="headerlink" title="模块引脚与电平逻辑"></a>模块引脚与电平逻辑</h1><p>几天后模块到手了，由于模块是拆机模块，成色老旧，为了避免断线和焊盘脱落，博主先用热溶胶加固了比较脆弱的位置，同时给引脚位置加装了 2.54mm 排针。</p>
<p>这款模块用了的经典的牛屎封装，经过一番 Google，得知真正的核心貌似用的是 MAS6180B。另外，这款模块的原理，实际上就是透过 MAS6180B 将长波授时信号进行放大与解调，并透过内部的比较器将其二进制输出。</p>
<p>这个模块有 5 个引脚，经过博主一番尝试和整理，其功能如下。</p>
<table>
<thead>
<tr>
<th align="left">引脚名字</th>
<th align="left">引脚功能</th>
<th align="left">逻辑电平</th>
<th align="left">默认状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">60K1</td>
<td align="left">60 kHz 使能</td>
<td align="left">高电平使能</td>
<td align="left">低电平</td>
</tr>
<tr>
<td align="left">PON1</td>
<td align="left">模块使能</td>
<td align="left">低电平使能</td>
<td align="left">高电平</td>
</tr>
<tr>
<td align="left">3V1</td>
<td align="left">3.3V 电源输入</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">TCO1</td>
<td align="left">信号脉冲</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">GND1</td>
<td align="left">电源接地</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>在整理引脚的过程中，博主也发现不同 JJY 模块间的引脚排布、引脚逻辑电平、引脚功能都不尽相同，所以在使用模块前，一定要先确认好模块的引脚功能和逻辑电平，以免翻车损坏模块。</p>
<p><img data-src="https://c.ibcl.us/JJY_Timecode_20230522/2.jpg" alt="博主的 JJY 模块"><br>`</p>
<h1 id="模块测试"><a href="#模块测试" class="headerlink" title="模块测试"></a>模块测试</h1><p>为了简化开发流程，博主使用 Arduino UNO 来测试模块的功能。但是在测试模块的过程中，博主发现模块的 TCO1 输出的脉冲电压只有 1V 左右，无法直接连接到 Arduino 的数字输入引脚。</p>
<p>由于使用的是 Arduino 单片机，而且博主也不想额外搭建电平转换电路，所以博主决定将模块的 TCO1 输出接到 Arduino 的模拟输入引脚上，然后透过 Arduino 的 <code>analogRead()</code> 函数来读取 TCO1 的电压值，进而分析出其电平高低。</p>
<h1 id="JJY-时间码结构"><a href="#JJY-时间码结构" class="headerlink" title="JJY 时间码结构"></a>JJY 时间码结构</h1><p>在编写程序前，我们需要先了解一下 JJY 时间码的结构。NICT 在官网给出的时间码结构如下图所示。</p>
<p><img data-src="https://c.ibcl.us/JJY_Timecode_20230522/3.png" alt="NICT 时间结构"></p>
<p>JJY 的脉冲宽度总共分为 3 种，分别是 200ms、500ms、800ms，其中 200ms 的脉冲代表<strong>标记符</strong>，500ms 的脉冲代表<strong>逻辑 1</strong>，800ms 的脉冲代表<strong>逻辑 0</strong>。</p>
<p>在 NICT 给出的结构图中，可以看出，JJY 一帧完整的时间数据总共有 60 位，每一位对应到一个固定宽度的脉冲。透过上图，可以将时间主要位的索引整理如下表。</p>
<table>
<thead>
<tr>
<th align="left">时间位名称</th>
<th align="left">位数索引</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分钟</td>
<td align="left">[1:8]</td>
</tr>
<tr>
<td align="left">小时</td>
<td align="left">[12:18]</td>
</tr>
<tr>
<td align="left">天数</td>
<td align="left">[22:33]</td>
</tr>
<tr>
<td align="left">年份</td>
<td align="left">[41:48]</td>
</tr>
<tr>
<td align="left">星期</td>
<td align="left">[50:52]</td>
</tr>
</tbody></table>
<p>此外，JJY 对时间的编码形式是 BCD 码的一种变体，但是计算方式和 BCD 码相同。例如，若在分钟位接收到的数据是 00110010，结合上图中所给的位权重，那么将该数据换算成 10 进制，即分钟数为 12，其算式如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0*40 + 0*20 + 1*10 + 1*0 + 0*8 + 0*4 + 1*2 + 0*1 = 12</span><br></pre></td></tr></table></figure>

<p>根据上图，还可以得出的一个结论是，当连续收到两次标记符信号时，就可以确认当前的时间是第 0 秒，也就是某一分钟的起始。</p>
<p>另外，JJY 的时间码还带有闰秒信息，当闰秒发生时，JJY 会在 59 秒的位置插入一个 800ms 的脉冲，用来表示闰秒。但是本文的目标只是实现对 JJY 的简单解码，所以不会对闰秒进行处理，也不会对奇偶校验码做处理。</p>
<h1 id="硬件搭建"><a href="#硬件搭建" class="headerlink" title="硬件搭建"></a>硬件搭建</h1><p>硬件连线图如下所示。</p>
<p><img data-src="https://c.ibcl.us/JJY_Timecode_20230522/4.png" alt="硬件连线图"></p>
<p>引脚的连线方式如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">模块引脚</th>
<th align="left">单片机引脚</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">JJY 模块 GND1</td>
<td align="left">GND</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">JJY 模块 TCO1</td>
<td align="left">A0</td>
<td align="left"><strong>需要接入 Arduino 模拟引脚</strong></td>
</tr>
<tr>
<td align="left">JJY 模块 3V1</td>
<td align="left">3.3V</td>
<td align="left"><strong>须 3.3V 供电</strong>避免烧坏模块</td>
</tr>
<tr>
<td align="left">JJY 模块 PON1</td>
<td align="left">11</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">JJY 模块 60K1</td>
<td align="left">10</td>
<td align="left">低电平 40 kHz，高电平 60 kHz</td>
</tr>
</tbody></table>
<p>由于博主的 Arduino UNO 临时没有找到，所以博主使用的是引脚功能是一样的，所以不会影响程序的编写。</p>
<p>下面是博主的硬件搭建图。</p>
<p><img data-src="https://c.ibcl.us/JJY_Timecode_20230522/5.jpg" alt="博主的硬件搭建图"></p>
<h1 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h1><p>Github 仓库：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvSkpZLUNsb2Nr">github.com/bclswl0827/JJY-Clock<i class="fa fa-external-link-alt"></i></span></p>
<p>博主已经写好了程序，也开源到了 GitHub 上，经过测试可以正常解码。下文介绍一些关键点与代码。</p>
<p>另外，博主使用的 IDE 是 PlatformIO，编译固件时需要注意。</p>
<h2 id="重写-digitalRead-函数"><a href="#重写-digitalRead-函数" class="headerlink" title="重写 digitalRead() 函数"></a>重写 digitalRead() 函数</h2><p>由于 JJY 模块输出的电平高低与 Arduino 的电平标准不同，所以可以使用 analogRead 来读取引脚模拟值，并根据人为的设定电平阈值来判断逻辑 1 或 0，因此，只需要对 digitalRead() 函数进行重写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">digitalRead</span><span class="params">(<span class="type">int</span> pin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">analogRead</span>(pin) &gt; <span class="number">100</span> ? LOW : HIGH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="声明每一位权重"><a href="#声明每一位权重" class="headerlink" title="声明每一位权重"></a>声明每一位权重</h2><p>前面提到过，JJY 的时间码是 BCD 码的一种变体，所以需要声明位权重，用来计算时间码的十进制值。</p>
<p>这里透过枚举类型来声明位权重，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分钟位权重</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">minute</span> &#123;</span><br><span class="line">    MINUTE_0 = <span class="number">40</span>,</span><br><span class="line">    MINUTE_1 = <span class="number">20</span>,</span><br><span class="line">    MINUTE_2 = <span class="number">10</span>,</span><br><span class="line">    MINUTE_3 = <span class="number">0</span>,</span><br><span class="line">    MINUTE_4 = <span class="number">8</span>,</span><br><span class="line">    MINUTE_5 = <span class="number">4</span>,</span><br><span class="line">    MINUTE_6 = <span class="number">2</span>,</span><br><span class="line">    MINUTE_7 = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小时位权重</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">hour</span> &#123;</span><br><span class="line">    HOUR_0 = <span class="number">20</span>,</span><br><span class="line">    HOUR_1 = <span class="number">10</span>,</span><br><span class="line">    HOUR_2 = <span class="number">0</span>,</span><br><span class="line">    HOUR_3 = <span class="number">8</span>,</span><br><span class="line">    HOUR_4 = <span class="number">4</span>,</span><br><span class="line">    HOUR_5 = <span class="number">2</span>,</span><br><span class="line">    HOUR_6 = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 天数位权重</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">day</span> &#123;</span><br><span class="line">    DAY_0 = <span class="number">200</span>,</span><br><span class="line">    DAY_1 = <span class="number">100</span>,</span><br><span class="line">    DAY_2 = <span class="number">0</span>,</span><br><span class="line">    DAY_3 = <span class="number">80</span>,</span><br><span class="line">    DAY_4 = <span class="number">40</span>,</span><br><span class="line">    DAY_5 = <span class="number">20</span>,</span><br><span class="line">    DAY_6 = <span class="number">10</span>,</span><br><span class="line">    DAY_7 = <span class="number">8</span>,</span><br><span class="line">    DAY_8 = <span class="number">4</span>,</span><br><span class="line">    DAY_9 = <span class="number">2</span>,</span><br><span class="line">    DAY_10 = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 年份位权重</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">year</span> &#123;</span><br><span class="line">    YEAR_0 = <span class="number">80</span>,</span><br><span class="line">    YEAR_1 = <span class="number">40</span>,</span><br><span class="line">    YEAR_2 = <span class="number">20</span>,</span><br><span class="line">    YEAR_3 = <span class="number">10</span>,</span><br><span class="line">    YEAR_4 = <span class="number">8</span>,</span><br><span class="line">    YEAR_5 = <span class="number">4</span>,</span><br><span class="line">    YEAR_6 = <span class="number">2</span>,</span><br><span class="line">    YEAR_7 = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 星期位权重</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">week</span> &#123;</span><br><span class="line">    WEEK_0 = <span class="number">4</span>,</span><br><span class="line">    WEEK_1 = <span class="number">2</span>,</span><br><span class="line">    WEEK_2 = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="天数转月份与日期"><a href="#天数转月份与日期" class="headerlink" title="天数转月份与日期"></a>天数转月份与日期</h2><p>由于 JJY 的天数位是从每年的第一天开始计数的，所以需要将天数转换成月份日期。</p>
<p>由于存在闰年，所以在调用函数时，除了传入天数，还需要传入是否为闰年的标记。</p>
<p>下方是天数转月份的代码，代码中，天数统一扩大了 1000 倍，这样可以避免浮点数运算带来的精度丢失问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">Days2Month</span><span class="params">(<span class="type">uint8_t</span> days, <span class="type">uint8_t</span> leap)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> rate = days * <span class="number">1000</span> / <span class="number">365</span>;</span><br><span class="line">    <span class="keyword">if</span> (rate &lt;= <span class="number">31000</span> / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">60000</span> : <span class="number">59000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">91000</span> : <span class="number">90000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">121000</span> : <span class="number">120000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">152000</span> : <span class="number">151000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">182000</span> : <span class="number">181000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">213000</span> : <span class="number">212000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">244000</span> : <span class="number">243000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">274000</span> : <span class="number">273000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">305000</span> : <span class="number">304000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rate &lt;= (leap ? <span class="number">335000</span> : <span class="number">334000</span>) / <span class="number">365</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下方是天数转日期的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">Days2Date</span><span class="params">(<span class="type">uint8_t</span> days, <span class="type">uint8_t</span> leap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">Days2Month</span>(days, leap)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">31</span> - (<span class="number">31</span> - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> (leap ? <span class="number">29</span> : <span class="number">28</span>) - ((leap ? <span class="number">60</span> : <span class="number">59</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">31</span> - ((leap ? <span class="number">91</span> : <span class="number">90</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">30</span> - ((leap ? <span class="number">121</span> : <span class="number">120</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">31</span> - ((leap ? <span class="number">152</span> : <span class="number">151</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">30</span> - ((leap ? <span class="number">182</span> : <span class="number">181</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">31</span> - ((leap ? <span class="number">213</span> : <span class="number">212</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">31</span> - ((leap ? <span class="number">244</span> : <span class="number">243</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">30</span> - ((leap ? <span class="number">274</span> : <span class="number">273</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">31</span> - ((leap ? <span class="number">305</span> : <span class="number">304</span>) - days);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">30</span> - ((leap ? <span class="number">335</span> : <span class="number">334</span>) - days);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">31</span> - ((leap ? <span class="number">366</span> : <span class="number">28</span>) - days);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取得同步标记"><a href="#取得同步标记" class="headerlink" title="取得同步标记"></a>取得同步标记</h2><p>前面也已经提到过，当连续收到两次标记符信号时，就可以确认 JJY 新的一帧数据已经开始。</p>
<p>所以，需要声明一个变量或者结构体，用来记录上一次脉冲的宽度，并与当前脉冲的宽度进行比较，若判断到上一次与这一次的脉冲宽度都是标记符信号，就可以确认 JJY 新的一帧数据已经开始。</p>
<p>下面是声明的用来存储状态的结构体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">JJYStatus</span> &#123;</span><br><span class="line">    <span class="type">bool</span> status;             <span class="comment">// 是否有数据</span></span><br><span class="line">    <span class="type">uint16_t</span> time;           <span class="comment">// 记录起始时间用于后续计算</span></span><br><span class="line">    <span class="type">uint16_t</span> previous;       <span class="comment">// 记录上一次起始时间</span></span><br><span class="line">    <span class="type">uint16_t</span> cycle;          <span class="comment">// 记录方波周期时间</span></span><br><span class="line">    <span class="type">uint16_t</span> pulse;          <span class="comment">// 记录当前脉冲时间</span></span><br><span class="line">    <span class="type">uint16_t</span> previousPulse;  <span class="comment">// 记录上次脉冲时间</span></span><br><span class="line">&#125; JJYStatus;</span><br></pre></td></tr></table></figure>

<h2 id="解码器缓存"><a href="#解码器缓存" class="headerlink" title="解码器缓存"></a>解码器缓存</h2><p>解码器缓存也为一个结构体，用来保存解码数据，存储解码器的状态，记录是否已经完成解码，以及一个用于记录数据缓存位置的计数器。</p>
<p>由于实际解码时，由于标记符会直接丢弃，所以缓存大小为 53 个数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DecoderStatus</span> &#123;</span><br><span class="line">    <span class="type">bool</span> status;      <span class="comment">// 解码器运行状态</span></span><br><span class="line">    <span class="type">bool</span> done;        <span class="comment">// 解码是否完成</span></span><br><span class="line">    <span class="type">uint8_t</span> counter;  <span class="comment">// 数据缓存位置计数器</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">53</span>];     <span class="comment">// 除去标记符后的数据缓存</span></span><br><span class="line">&#125; DecoderStatus;</span><br></pre></td></tr></table></figure>

<p><strong>由于抛弃了标记符，所以上文提到的时间位索引表，也应做相应的调整。</strong></p>
<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p>最后附上博主的成果，数据透过串口终端输出，可以看到，数据已经成功解码。</p>
<p><img data-src="https://c.ibcl.us/JJY_Timecode_20230522/6.gif" alt="成功解码时间"></p>
]]></content>
      <categories>
        <category>电波钟</category>
      </categories>
      <tags>
        <tag>电波钟</tag>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>JJY</tag>
        <tag>长波</tag>
        <tag>无线电</tag>
      </tags>
  </entry>
  <entry>
    <title>龙芯 2K1000 EDU 斗智斗勇记</title>
    <url>/Loongson-Kernel_20230521/</url>
    <content><![CDATA[<p>博主最近在折腾一个地震监测相关的项目，项目中的测站上位机程序需要运行在 Linux 平台上。</p>
<p>由于博主的地震项目需要在异地多点部署测站，要是再从网上采购一堆 Linux 开发板的话，又会是一大笔开销。在翻遍实验室库存过后，博主发现了一堆往届学生参加嵌入式比赛留下的龙芯 2K1000 EDU 板子。</p>
<p>2K1000 EDU 是 mips64el 架构，说来惭愧，博主此前实际用过的 mips 架构的设备，也就只有几台路由器了。</p>
<p>当然，博主相信，这玩意肯定还是比路由器强一点的，不过能强多少，就不好说了。抱着测站程序「能跑就行」的想法，博主取了一块板子，准备上电装系统看看究竟。</p>
<p>本以为 2K1000 EDU 除了架构不太一样，性能比较拉垮一点之外，其他方面同别的 ARM Linux 系列开发板别无两样，结果却出乎博主的意料：本来预计一两个小时就能搞定的事情，在 2K1000 EDU 上折腾了快一天才完成。</p>
<p>所以，这篇文章将详细介绍博主与 2K1000 EDU 斗智斗勇的过程。</p>
<p><img data-src="https://c.ibcl.us/Loongson-Kernel_20230520/1.jpg" alt="即将寄走的龙芯 2K1000 EDU"></p>
<span id="more"></span>

<h1 id="ISO-在哪里"><a href="#ISO-在哪里" class="headerlink" title="ISO 在哪里"></a>ISO 在哪里</h1><p>插上 HDMI 显示器，上电过后却迟迟没有动静，博主怀疑系统是空的，于是开始上网找系统。</p>
<p>找了半天，却发现<span class="exturl" data-url="aHR0cHM6Ly9tYnl6aGFuZy5naXRib29rLmlvL2xvb25nYmlhbi9vcy9sb29uZ2JpYW4taW5zdGFsbGF0aW9uLWd1aWRl">龙芯文档<i class="fa fa-external-link-alt"></i></span>给出的 Loongbian 的 ISO 下载链接都已经挂了。</p>
<p><img data-src="https://c.ibcl.us/Loongson-Kernel_20230520/2.png" alt="挂掉的链接"></p>
<p>最后，博主只能将 ISO 文件名丢进 Google 搜寻，不幸中的万幸，终于找出来了难得能用的一个地址，而且万万没想到的是，系统镜像提供方来自武昌首义学院。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLndzeXUuZWR1LmNuL2xvb25nc29uL2luc3RhbGxlci8=">mirrors.wsyu.edu.cn/loongson/installer/<i class="fa fa-external-link-alt"></i></span></p>
<p>为了方便后续对系统做客制化，博主最终选择下载了 <code>loongbian_current_base.iso</code>。</p>
<p>按照教程给出的方式，使用 <code>dd</code> 命令将系统刷入 U 盘后，准备开始安装 Loongbian 系统。</p>
<p>安装一切顺利，也成功进入了系统，可以进一步配置了。</p>
<h1 id="升级-Debian-版本"><a href="#升级-Debian-版本" class="headerlink" title="升级 Debian 版本"></a>升级 Debian 版本</h1><p>另外，由于 current_base 版本的系统默认不带 sudo 包，所以下面操作要先切换到 root 用户下进行。</p>
<p>透过 su 命令即可切换到 root 身份，密码同样为 loongson。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su root</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>/etc/apt/sources.list</code> 中的源地址也挂掉了，所以首先要换源。</p>
<p>Loongbian 实际上源自 Debian Buster，由于要对系统发行版做升级，所以直接将源地址改成 Debian Bullseye 的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.bfsu.edu.cn/debian bullseye main&quot;</span> | <span class="built_in">tee</span> /etc/apt/sources.list</span></span><br></pre></td></tr></table></figure>

<p>再更新软件列表，并对软件做最小升级。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt update</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt upgrade --without-new-pkgs -y</span></span><br></pre></td></tr></table></figure>

<p>在升级途中可能会有提示是否不询问直接重启服务，勾选 Yes 即可。</p>
<p>完成最小升级后，再进行完全升级。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt full-upgrade -y</span></span><br></pre></td></tr></table></figure>

<p>在完全升级途中，仍然提示是否保留配置文件，一律选择覆盖安装即可。完成完全升级后，重启设备。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">reboot</span></span><br></pre></td></tr></table></figure>

<p>重启完成后，依然以 root 身份进入系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su root</span></span><br></pre></td></tr></table></figure>

<p>同时对系统版本做检查。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/os-release</span></span><br><span class="line">PRETTY_NAME=&quot;Debian GNU/Linux 11 (bullseye)&quot;</span><br><span class="line">NAME=&quot;Debian GNU/Linux&quot;</span><br><span class="line">VERSION_ID=&quot;11&quot;</span><br><span class="line">VERSION=&quot;11 (bullseye)&quot;</span><br><span class="line">VERSION_CODENAME=bullseye</span><br><span class="line">ID=debian</span><br><span class="line">HOME_URL=&quot;https://www.debian.org/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://www.debian.org/support&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.debian.org/</span><br></pre></td></tr></table></figure>

<p>返回结果中带有 Bullseye 即说明成功。</p>
<h1 id="安装常用组件"><a href="#安装常用组件" class="headerlink" title="安装常用组件"></a>安装常用组件</h1><p>接下来为龙芯 2K1000 EDU 安装必备及常用组件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install -y openssh-server usbutils network-manager liblinux-usermod-perl build-essential locales bc make dialog network-manager</span></span><br></pre></td></tr></table></figure>

<p>安装完成后，将 loongson 用户加入 sudo 组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo usermod -aG sudo loongson</span></span><br></pre></td></tr></table></figure>

<p>然后再次重启设备。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo reboot</span></span><br></pre></td></tr></table></figure>

<h1 id="安装无线网卡驱动"><a href="#安装无线网卡驱动" class="headerlink" title="安装无线网卡驱动"></a>安装无线网卡驱动</h1><p>由于 2K1000 EDU 板子没有无线网卡，而博主恰好又有使用无线网卡的需求，所以需要先安装无线网卡驱动。</p>
<p><img data-src="https://c.ibcl.us/Loongson-Kernel_20230520/3.jpg" alt="博主使用的无线网卡"></p>
<p>这一款 USB 无线网卡使用的芯片方案是 RTL8188GU，所以需要安装驱动。</p>
<p>不幸的是，由于 Loongbian 的源地址挂掉了，所以无法直接安装驱动，只能自己动手交叉编译。</p>
<h2 id="准备交叉编译环境"><a href="#准备交叉编译环境" class="headerlink" title="准备交叉编译环境"></a>准备交叉编译环境</h2><p>博主使用的交叉编译环境是 Ubuntu 20.04，所以需要先安装交叉编译工具链及搭建交叉编译环境。</p>
<p>先为交叉编译环境换源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo sed -e &quot;s/archive.ubuntu.com/mirrors.bfsu.edu.cn/g&quot; -e &quot;s/security.ubuntu.com/mirrors.bfsu.edu.cn/g&quot; -i /etc/apt/sources.list</span><br><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>

<p>然后为交叉编译的环境安装编译内核需要的相关依赖项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install crossbuild-essential-mips64el u-boot-tools git flex bison libncurses-dev bc ssh libssl-dev rsync kmod cpio -y</span></span><br></pre></td></tr></table></figure>

<h2 id="交叉编译龙芯内核"><a href="#交叉编译龙芯内核" class="headerlink" title="交叉编译龙芯内核"></a>交叉编译龙芯内核</h2><p>在用户根目录下，拉取 Loongbian 所使用的内核源码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --depth 1 https://github.com/Loongbian/linux ~/linux</span></span><br></pre></td></tr></table></figure>

<p>由于源码仓库有太多 commits，所以可以加上 <code>--depth 1</code> 选项，加快拉取速度。</p>
<p>拉取完成后，进入 linux 目录，然后加载龙芯 2K1000 EDU 配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/linux</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=mips CROSS_COMPILE=/usr/bin/mips64el-linux-gnuabi64- ls2k_defconfig</span></span><br></pre></td></tr></table></figure>

<p>然后运行 menuconfig 开始配置内核参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=mips CROSS_COMPILE=/usr/bin/mips64el-linux-gnuabi64- menuconfig</span></span><br></pre></td></tr></table></figure>

<p>在弹出的 TUI 界面中，勾选以下选项。</p>
<ul>
<li>启用 cfg80211 证书义务： Networking support -&gt; Wireless -&gt; cfg80211 certification onus</li>
<li>启用 Realtek USB 无线网卡支援：Device Drivers -&gt; Network device support -&gt; Wireless LAN -&gt; Realtek devices -&gt; Realtek 8187 and 8187B USB support</li>
<li>启用龙芯暂存驱动以支援 GPIO：Device Drivers -&gt; Staging drivers -&gt; Loongson Staging Drivers</li>
<li>启用系统 sysfs 支援：Device Drivers -&gt; GPIO Support -&gt; /sys/class/gpio/… (sysfs interface)</li>
<li>启用 CP210x 串口芯片支援：Device Drivers -&gt; USB support -&gt; USB Serial Converter support -&gt; USB CP210x family of UART Bridge Controllers</li>
<li>启用 CH341 系列串口芯片支援：Device Drivers -&gt; USB support -&gt; USB Serial Converter support -&gt; USB Winchiphead CH341 Single Port Serial Driver</li>
<li>启用 USB Modem 支援：Device Drivers -&gt; USB support -&gt; USB Modem (CDC ACM) support</li>
</ul>
<p>在完成设定后，多次按下 Esc 键，保存设定并退出，依次运行如下命令进行编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=mips CROSS_COMPILE=/usr/bin/mips64el-linux-gnuabi64- prepare -j$(<span class="built_in">nproc</span>)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=mips CROSS_COMPILE=/usr/bin/mips64el-linux-gnuabi64- scripts -j$(<span class="built_in">nproc</span>)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=mips CROSS_COMPILE=/usr/bin/mips64el-linux-gnuabi64- modules -j$(<span class="built_in">nproc</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="安装龙芯新内核"><a href="#安装龙芯新内核" class="headerlink" title="安装龙芯新内核"></a>安装龙芯新内核</h2><p>完成编译后，对内核打包为 .deb 格式，方便在龙芯上安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make ARCH=mips CROSS_COMPILE=/usr/bin/mips64el-linux-gnuabi64- bindeb-pkg -j$(<span class="built_in">nproc</span>)</span></span><br></pre></td></tr></table></figure>

<p>上述命令执行完成后，可以在用户根目录找到打包好的 .deb 文件。</p>
<p>退回到用户根目录，假设龙芯 IP 为 10.0.0.105，使用 scp 命令将 .deb 文件全部上传到龙芯。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scp ./*.deb loongson@10.0.0.105:/home/loongson</span></span><br></pre></td></tr></table></figure>

<p>然后回到 2K1000 EDU 的终端，安装刚刚上传的内核安装包，安装完成后重启。</p>
<p><strong>需要注意的是，安装新内核过程中，可能会出现找不到部分驱动的警告，可以将 <code>https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git</code> 仓库 clone 下来，然后在仓库中找到警告中缺失的驱动，将其移动到龙芯的 /lib/firmware 目录下（若没有此目录则需要手动创建），然后再运行 <code>sudo update-initramfs -u</code> 即可解决。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo dpkg -i ./*.deb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo reboot</span></span><br></pre></td></tr></table></figure>

<p>重启过后，可以使用 <code>uname -r</code> 命令查看内核版本，不出意外，内核版本已经更新到了交叉编译的版本。</p>
<h2 id="交叉编译-USB-网卡驱动"><a href="#交叉编译-USB-网卡驱动" class="headerlink" title="交叉编译 USB 网卡驱动"></a>交叉编译 USB 网卡驱动</h2><p>由于 USB 网卡驱动为内核模块形式，所以还需要对此内核模块做交叉编译。</p>
<p>在交叉编译环境中，回到用户根目录，首先拉取 RTL8188GU 驱动的源码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> --depth 1 https://github.com/McMCCRU/rtl8188gu ~/rtl8188gu</span></span><br></pre></td></tr></table></figure>

<p>拉取完成后，进入 rtl8188gu 目录，然后指定 CPU 架构、交叉编译器、内核源码目录，开始编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~/rtl8188gu</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ARCH=mips CROSS_COMPILE=/usr/bin/mips64el-linux-gnuabi64- make KSRC=~/linux -j$(<span class="built_in">nproc</span>)</span></span><br></pre></td></tr></table></figure>

<p>编译完成后，将 8188gu.ko 文件上传到龙芯。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">scp ./8188gu.ko loongson@10.0.0.150:/home/loongson</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-USB-网卡驱动"><a href="#安装-USB-网卡驱动" class="headerlink" title="安装 USB 网卡驱动"></a>安装 USB 网卡驱动</h2><p>然后回到 2K1000 EDU 的终端，加载刚刚上传的内核模块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo insmod ./8188gu.ko</span></span><br></pre></td></tr></table></figure>

<p>不出意外，执行 <code>sudo ifconfig</code> 命令后应该能够看到 USB 网卡设备，其前缀一般为 wlx。</p>
<p>然后运行 <code>sudo nmtui</code> 命令，在弹出的 TUI 窗口选择 Activate a connection 即可连接 WLAN 网络。</p>
<p><img data-src="https://c.ibcl.us/Loongson-Kernel_20230520/4.png" alt="WLAN 连接成功"></p>
<h1 id="部署测站程序"><a href="#部署测站程序" class="headerlink" title="部署测站程序"></a>部署测站程序</h1><p>好在博主的测站程序是使用 Go 语言编写的，只需要一条命令就能编译出 Mips 平台的程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">GOOS=linux GOARCH=mipsle GOMIPS=softfloat go build -ldflags=<span class="string">&quot;-s -w&quot;</span> main ../cmd/*.go</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，部分 Mips 平台的内核是没有打开 MIPS FPU Emulator 的，这可能会导致运行时会显示 Illegal instruction，博主考虑到兼容性，所以在编译 Go 程序的时候一律带上了 <code>GOMIPS=softfloat</code> 选项。</p>
<p>将程序上传到龙芯，测站程序成功运行。</p>
<p><img data-src="https://c.ibcl.us/Loongson-Kernel_20230520/5.png" alt="测站程序"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>硬件</tag>
        <tag>嵌入式</tag>
        <tag>龙芯</tag>
      </tags>
  </entry>
  <entry>
    <title>这或许是全网最完善的辉光钟 DIY 指南</title>
    <url>/Nixie-Clock_20230823/</url>
    <content><![CDATA[<p>去年（2022 年） 8 月的某一天，博主逛淘宝时偶然刷到了一个 IN-12 辉光管，看完买家秀中展示的照片后，博主深深地被管子发出的幽幽红光给吸引住了，在 Google 上一番搜寻过后，博主发现大多数人都用它来做时钟。</p>
<p>虽然原理看上去非常简单，但显示时间的载体从液晶屏换到辉光管后，真的很炫酷。博主犹豫片刻过后，随即下单了一个 IN-12 管子和一个升压模块，决定先尝试将其点亮，看看效果如何，再决定是否继续。</p>
<p>几天后，快递如约而至，博主将升压模块和 IN-12 引脚连接好，接通 5V 电源后，辉光管发出了迷人的红光，博主也露出了满意的笑容。</p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/1.jpg" alt="单只辉光管"></p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/2.jpg" alt="成功点亮 IN-12"></p>
<p>试水计划顺利完成后，博主也没有闲下来，而是又下单了 3 只 IN-12，决定打造一台属于自己的辉光钟。在历经几个月的不断试错与改进过后，博主终于给交出了一份满意的答卷，<strong>并将整个项目（PCB 文件、单片机程序、授时软件）开源到了 GitHub</strong>，供更多人参考与借鉴。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvT3Blbk5peGll">GitHub - bclswl0827/OpenNixie<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/3.jpg" alt="博主的辉光钟成品"></p>
<span id="more"></span>

<h1 id="硬件方案"><a href="#硬件方案" class="headerlink" title="硬件方案"></a>硬件方案</h1><h2 id="升压方案"><a href="#升压方案" class="headerlink" title="升压方案"></a>升压方案</h2><p>在网上搜寻后，博主发现 MAX1771 对于这个项目是一个近乎完美的升压方案，其外设极其简单，只需要设计好反馈电阻即可。比较可惜的是，网上现成的 MAX1771 升压电路，输入电压基本都是 12V，而电路中其他模块又需要 5V 供电，所以只能再外加一个 LDO 模块（AMS1117）来实现 12V 转 5V。</p>
<p>最后，博主画出的完整升压模块原理图长这样。</p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/4.png" alt="MAX1771 升压原理图"></p>
<p><strong>需要注意的是，图中代号为 C3 的 10uF 电解电容，耐压值需要在 200V 以上，这样才能承受较高的输出电压。</strong></p>
<p>值得一提的是，MAX1771 还提供了一个使能引脚（SHDN 引脚），让用户可以通过控制这一引脚的电平高低，从而使能或禁能升压。</p>
<h2 id="驱动方案"><a href="#驱动方案" class="headerlink" title="驱动方案"></a>驱动方案</h2><p>网络上大多数的辉光钟项目，都采用了 74141 或 K155ID1 译码器芯片来控制辉光管的亮灭，无奈这些芯片要么假货遍地，要么价格太贵，让博主不敢贸然下手。在与一位朋友交流后，这位朋友提到可以使用有高耐压值的 NPN 三极管来控制辉光管亮灭，从而避开这些芯片。</p>
<p>经过选型，博主发现 MPSA42 三极管恰好符合项目需求，淘宝上这款三极管的售价也非常便宜，不出 10 元就能买到一大包，性价比直接暴打 74141 和 K155ID1。</p>
<p>但是这一方案又会导致一个新问题，那就是若使用常用的静态扫描方式驱动辉光管，4 个辉光管加一个氖灯符号则将会用去 4 + 4*10 + 1 个 NPN 三极管，如此一来，不光 PCB 装不下这么多器件，即便装下了，布线也是个麻烦事。因此，博主也只能退而求其次，采用动态扫描方式进行驱动，从而也将 NPN 三极管的数量压缩到 4 + 10 + 1 个。解决方法看似很完美，但是这样会导致辉光管的亮度会暗一些。</p>
<p>在原理图中，博主用分层的方式，单独画出了辉光管段选和位选驱动的原理图。</p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/5.png" alt="辉光管段选原理图"></p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/6.png" alt="辉光管位选原理图"></p>
<p>在辉光管位选原理图中，博主使用的是 20k 欧姆的限流电阻，<strong>需要注意的是，这里的限流电阻功率需要比其他电阻稍大一些（如选用功率为 0.5W 的电阻），从而避免长期运行过烫而导致电阻寿命缩短</strong>。</p>
<h2 id="寄存器组合"><a href="#寄存器组合" class="headerlink" title="寄存器组合"></a>寄存器组合</h2><p>根据前面的描述可以得出，总共有 16 个引脚需要控制（升压模块使能脚、辉光管段选三极管、辉光管位选三极管、氖灯符号三极管）。由于用于控制的单片机片上 GPIO 资源比较宝贵，不可能 16 个控制脚都接去单片机 GPIO 上，所以博主决定使用两个 74HC595 芯片级联组成一个 16 位的寄存器，从而实现只用 3 个片上 GPIO 对辉光钟进行控制。</p>
<p>原理图如下，博主还附上了一张表格描述寄存器位数对应的功能。</p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/7.png" alt="74HC595 原理图"></p>
<table>
<thead>
<tr>
<th align="left">寄存器位</th>
<th align="left">位功能</th>
<th align="left">位描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[0:9]</td>
<td align="left">辉光钟段选</td>
<td align="left">高电平使能</td>
</tr>
<tr>
<td align="left">[10:13]</td>
<td align="left">辉光钟位选</td>
<td align="left">低电平使能</td>
</tr>
<tr>
<td align="left">[14:15]</td>
<td align="left">氖灯符号位</td>
<td align="left">高电平使能</td>
</tr>
<tr>
<td align="left">[15:16]</td>
<td align="left">MAX1771 使能</td>
<td align="left">低电平使能</td>
</tr>
</tbody></table>
<h2 id="单片机、串口、RTC"><a href="#单片机、串口、RTC" class="headerlink" title="单片机、串口、RTC"></a>单片机、串口、RTC</h2><p>由于博主的实验室有堆积如山的 STC89C51 工业垃圾，所以博主也就直接选用了这款单片机。</p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/8.jpg" alt="DIP-40 封装的 STC89C51 单片机"></p>
<p>STC89C51 单片机带有一个串口，博主将其连接到了 BLE 蓝牙模块，从而实现透过无线蓝牙对辉光钟授时。至于蓝牙模块，博主选用的是 JDY-34-SPP。</p>
<p>RTC 芯片的选型是 DS3231，和一般的 DS1302 相比，DS3231 有更高的精度。DS3231 使用 I2C 协议与单片机进行通信，但是由于 STC89C51 单片机没有硬件 I2C，所以博主只能使用软件模拟 I2C 的方式来实现与 DS3231 的通信，虽然速度稍慢，不过也完全足够应付需求了。</p>
<p>提到这里，博主就不得不推一波去年疫情空档期为 8051 单片机打造的一款 Arduino 风格函数库了，这款函数库提供了包含 I2C、SPI、UART 在内的函数，且与 Arduino 的函数功能保持一致，让用户可以在只对代码做少量修改，直接将 Arduino 的项目代码移植到 8051 单片机上。这款函数库目前也以 MIT 协议开源到了 GitHub 上，本项目也将在此库基础上进行开发。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvNTFkdWlubw==">GitHub - bclswl0827/51duino<i class="fa fa-external-link-alt"></i></span></p>
<p>基于此库，例如要读取 DS3231 的时间，只需调用库中提供的 <code>WireBeginTransmission()</code>、<code>WireWrite()</code>、<code>WireRead()</code>、<code>WireRequestFrom()</code> 等函数即可，与在 Arduino 平台上开发的代码基本一致，同时，分配给 I2C 的引脚也可以在相关头文件中进行变更。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework/wire.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DS3231_ADDRESS 0x68</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> year;</span><br><span class="line">    <span class="type">uint8_t</span> month;</span><br><span class="line">    <span class="type">uint8_t</span> day;</span><br><span class="line">    <span class="type">uint8_t</span> week;</span><br><span class="line">    <span class="type">uint8_t</span> hour;</span><br><span class="line">    <span class="type">uint8_t</span> minute;</span><br><span class="line">    <span class="type">uint8_t</span> second;</span><br><span class="line">&#125; <span class="type">time_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getTime</span><span class="params">(<span class="type">time_t</span>* time)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">WireBeginTransmission</span>(DS3231_ADDRESS);</span><br><span class="line">    <span class="built_in">WireWrite</span>(<span class="number">0x00</span>);</span><br><span class="line">    <span class="built_in">WireEndTransmission</span>();</span><br><span class="line">    <span class="built_in">WireRequestFrom</span>(DS3231_ADDRESS, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    time-&gt;second = <span class="built_in">bcdToDec</span>(<span class="built_in">WireRead</span>() &amp; <span class="number">0x7F</span>);</span><br><span class="line">    time-&gt;minute = <span class="built_in">bcdToDec</span>(<span class="built_in">WireRead</span>());</span><br><span class="line">    time-&gt;hour = <span class="built_in">bcdToDec</span>(<span class="built_in">WireRead</span>());</span><br><span class="line">    time-&gt;week = <span class="built_in">bcdToDec</span>(<span class="built_in">WireRead</span>());</span><br><span class="line">    time-&gt;day = <span class="built_in">bcdToDec</span>(<span class="built_in">WireRead</span>());</span><br><span class="line">    time-&gt;month = <span class="built_in">bcdToDec</span>(<span class="built_in">WireRead</span>());</span><br><span class="line">    time-&gt;year = <span class="built_in">bcdToDec</span>(<span class="built_in">WireRead</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PCB-设计"><a href="#PCB-设计" class="headerlink" title="PCB 设计"></a>PCB 设计</h2><p>为了项目有较强的可拓展性，博主决定设计一款适用于大多数辉光管的标准插座，IN-12 则透过转接板对接到标准插座。这样一来，以后若想要更换辉光管型号，只需另外设计转接板即可，不需要对 PCB 进行任何改动，成本极低。</p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/9.jpg" alt="IN-12 转接板"></p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/10.jpg" alt="QS-27 转接板"></p>
<p>博主使用 KiCAD 7.0.0 来设计 PCB，由于本项目和射频、模拟电路等关系不大，因此 PCB 的设计也比较简单，只需将原理图中的元件进行布局、连线、铺铜。DRC 通过后，导出 Gerber 文件即可交送厂商生产。为了方便手工焊接，所以博主尽量选用了直插元器件。</p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/11.jpg" alt="PCB 正面"></p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/12.jpg" alt="PCB 背面"></p>
<p>PCB 尺寸 152 * 55 mm，嘉立创打样 5 片 PCB 的费用是 40.02 元。<strong>博主也建议在月底打板 PCB，这样可以在次月领到两张免费券，从而免去转接板的打板费用。</strong></p>
<p>PCB 以及转接板的完整设计文件位于仓库的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvT3Blbk5peGllL3RyZWUvbWFzdGVyL2NpcmN1aXQ=">circuit 目录下<i class="fa fa-external-link-alt"></i></span>，<strong>经过博主实测，KiCAD 对于跨版本的支持并不好，所以在二次开发时需要注意 KiCAD 的版本号最好同博主保持一致（使用 7.0.0 版本），避免出现奇怪的错误</strong>。</p>
<p>截止发文时，博主已经为这个项目制作了 IN-12、QS-27 两款辉光管的转接板，博主预计在不久的将来还能支持更多辉光管，博主也欢迎用户自行制作转接板，并向仓库提交 PR。</p>
<h1 id="软件方案"><a href="#软件方案" class="headerlink" title="软件方案"></a>软件方案</h1><h2 id="单片机端"><a href="#单片机端" class="headerlink" title="单片机端"></a>单片机端</h2><p>单片机的完整源码位于仓库的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvT3Blbk5peGllL3RyZWUvbWFzdGVyL2Zpcm13YXJl">firmware 目录下<i class="fa fa-external-link-alt"></i></span>，为了充分享受自动补全、代码高亮、自动格式化等现代生产力黑科技，所以博主抛弃了传统的 Keil（补一句，Keil 真是又丑又难用），而是使用了 VSCode 上的 EIDE 插件作为 STC89C51 的开发环境。在 VSCode 上安装该插件后，打开 firmware 目录下的 <code>OpenNixie.code-workspace</code> 文件，即可进入 EIDE 工作区编辑代码、构建项目、烧录固件。</p>
<h3 id="辉光管驱动"><a href="#辉光管驱动" class="headerlink" title="辉光管驱动"></a>辉光管驱动</h3><p>由于博主使用 74HC595 移位寄存器来控制整个设备，所以需要为 74HC595 编写驱动程序，以正确设定对应位（引脚）的电平。根据前文表格中提到的寄存器各位之功能，则可以编写出如下几个函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LATCH P24 <span class="comment">// 74HC595 锁存脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA P23  <span class="comment">// 74HC595 数据脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK P22 <span class="comment">// 74HC595 时钟脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定段选（显示 0-9 之一数字）</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">setSegment</span><span class="params">(<span class="type">uint8_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &lt; <span class="number">10</span> ? <span class="number">1</span> &lt;&lt; val : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定位选（使能 0-4 之一辉光管）</span></span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">setBit</span><span class="params">(<span class="type">uint8_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (val) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0x07</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0x0B</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0x0D</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0x0E</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x0F</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定氖灯符号（开或关）</span></span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">setSymbol</span><span class="params">(<span class="type">uint8_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定 MAX1771（使能或禁能）</span></span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">setEnable</span><span class="params">(<span class="type">uint8_t</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算寄存器值（作为参数调用 shiftOut 函数）</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">setNixie</span><span class="params">(<span class="type">uint8_t</span> enable,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span> symbol,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span> _bit,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint16_t</span> segment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (enable &lt;&lt; <span class="number">15</span>) | (symbol &lt;&lt; <span class="number">14</span>) | (_bit &lt;&lt; <span class="number">10</span>) | segment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据寄存器值设定 595 各引脚电平</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shiftOut</span><span class="params">(<span class="type">uint16_t</span> val)</span> </span>&#123;</span><br><span class="line">    LATCH = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        DATA = !!(val &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">15</span> - i)));</span><br><span class="line">        CLOCK = <span class="number">1</span>;</span><br><span class="line">        CLOCK = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LATCH = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于博主的项目采用动态扫描方式进行显示，所以，例如要显示 <code>1 2·3 4</code>，则可以编写下述代码片段。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> enable = <span class="built_in">setEnable</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">uint8_t</span> symbol = <span class="built_in">setSymbol</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> s0 = <span class="built_in">setSegment</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">uint16_t</span> s1 = <span class="built_in">setSegment</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">uint16_t</span> s2 = <span class="built_in">setSegment</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">uint16_t</span> s3 = <span class="built_in">setSegment</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(enable, symbol, <span class="built_in">setBit</span>(<span class="number">0</span>), s0));</span><br><span class="line">    <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(enable, symbol, <span class="built_in">setBit</span>(<span class="number">1</span>), s1));</span><br><span class="line">    <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(enable, symbol, <span class="built_in">setBit</span>(<span class="number">2</span>), s2));</span><br><span class="line">    <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(enable, symbol, <span class="built_in">setBit</span>(<span class="number">3</span>), s3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免出现鬼影</span></span><br><span class="line">    <span class="built_in">delayMicroseconds</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(<span class="built_in">setEnable</span>(<span class="number">0</span>), symbol, <span class="built_in">setBit</span>(<span class="number">0</span>), <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阴极保护"><a href="#阴极保护" class="headerlink" title="阴极保护"></a>阴极保护</h3><p>由于辉光管长期运行可能发生中毒现象，因此需要避免长期显示某个固定的数字。解决的方案则是定时显示一遍所有数字，代码只需基于上述片段稍作修改即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProtection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> s0 = <span class="built_in">setSegment</span>(i);</span><br><span class="line">        <span class="type">uint16_t</span> s1 = <span class="built_in">setSegment</span>(i);</span><br><span class="line">        <span class="type">uint16_t</span> s2 = <span class="built_in">setSegment</span>(i);</span><br><span class="line">        <span class="type">uint16_t</span> s3 = <span class="built_in">setSegment</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="type">uint8_t</span> enable = <span class="built_in">setEnable</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">uint8_t</span> symbol = <span class="built_in">setSymbol</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint8_t</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(enable, symbol, <span class="built_in">setBit</span>(<span class="number">0</span>), s0));</span><br><span class="line">            <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(enable, symbol, <span class="built_in">setBit</span>(<span class="number">1</span>), s1));</span><br><span class="line">            <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(enable, symbol, <span class="built_in">setBit</span>(<span class="number">2</span>), s2));</span><br><span class="line">            <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(enable, symbol, <span class="built_in">setBit</span>(<span class="number">3</span>), s3));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">delayMicroseconds</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">shiftOut</span>(<span class="built_in">setNixie</span>(<span class="built_in">setEnable</span>(<span class="number">0</span>), symbol, <span class="built_in">setBit</span>(<span class="number">0</span>), <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，若要调整数字显示的时长，可以修改内层循环 <code>j &lt; 5</code> 到其他值。</p>
<h3 id="校准时间"><a href="#校准时间" class="headerlink" title="校准时间"></a>校准时间</h3><p>为了让辉光钟正确识别来自授时客户端的授时请求，博主定义了一系列的命令字和应答字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_WORD 0xE0 <span class="comment">// 命令字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACK_WORD 0xE1 <span class="comment">// 应答字</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR_WORD 0xF1   <span class="comment">// 年位命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MONTH_WORD 0xF2  <span class="comment">// 月位命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAY_WORD 0xF3    <span class="comment">// 日位命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEEK_WORD 0xF4   <span class="comment">// 星期位命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOUR_WORD 0xF5   <span class="comment">// 小时位命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINUTE_WORD 0xF6 <span class="comment">// 分钟位命令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECOND_WORD 0xF7 <span class="comment">// 秒数位命令</span></span></span><br></pre></td></tr></table></figure>

<p>当单片机监测到串口数据与命令字相匹配时，则开始接收位命令（年月日时分秒等）和时间数据，并将数据写入 RTC 芯片的对应位，写入操作完成后，再往外发送应答字，指示本次授时成功，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 其他代码</span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> time;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SerialAvailable</span>() &amp;&amp; <span class="built_in">SerialRead</span>() == CMD_WORD) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> cmd = <span class="built_in">SerialRead</span>();</span><br><span class="line">        <span class="type">uint8_t</span> dat = <span class="built_in">SerialRead</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> YEAR_WORD:</span><br><span class="line">                time.year = dat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MONTH_WORD:</span><br><span class="line">                time.month = dat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DAY_WORD:</span><br><span class="line">                time.day = dat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WEEK_WORD:</span><br><span class="line">                time.week = dat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOUR_WORD:</span><br><span class="line">                time.hour = dat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MINUTE_WORD:</span><br><span class="line">                time.minute = dat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SECOND_WORD:</span><br><span class="line">                time.second = dat;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTime</span>(&amp;time);</span><br><span class="line">        <span class="built_in">SerialWrite</span>(ACK_WORD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="授时客户端"><a href="#授时客户端" class="headerlink" title="授时客户端"></a>授时客户端</h2><p>博主提供了用 Python、Go、TypeScript 编写的三个授时客户端，<strong>此外，由 TypeScript 编写的客户端基于浏览器实验特性 WebBluetooth，需要使用最新版 Chrome 或者 Edge 才能运行</strong>。</p>
<p>三个版本的授时工具的完整源码位于仓库的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvT3Blbk5peGllL3RyZWUvbWFzdGVyL3Rvb2xz">tools 目录下<i class="fa fa-external-link-alt"></i></span>，用户可以对其自行构建或二次开发。</p>
<p>对于一般用户，使用 TypeScript 的版本即可，只需要打开 <a href="https://ibcl.us/OpenNixie/">ibcl.us/OpenNixie</a>，点击屏幕的任意位置即可开始配对和授时。</p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/13.png" alt="TypeScript 版本授时客户端"></p>
<h1 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h1><p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/14.gif" alt="显示随机数"></p>
<p><img data-src="https://c.ibcl.us/Nixie-Clock_20230823/15.gif" alt="网页授时"></p>
<h1 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h1><p>除了 GitHub 仓库的 Issue 之外，博主还建了一个 Telegram 群组，方便为读者解答辉光钟 DIY 过程中遇到的各种问题，欢迎加入。</p>
<p>对了，现在还却一个外壳，可惜博主不会做 3D 设计，所以只能等待有缘人帮忙设计了。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL09wZW5OaXhpZQ==">t.me/OpenNixie<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>辉光钟</tag>
      </tags>
  </entry>
  <entry>
    <title>某科学的 T1 盒子刷 Armbian 调教笔记</title>
    <url>/PhicommT1-Armbian_20190825/</url>
    <content><![CDATA[<p>在剁手斐讯 N1 刷入 Armbian 作为<span class="exturl" data-url="aHR0cHM6Ly9zLmliY2wudXMv">本站的 SDR 服务器<i class="fa fa-external-link-alt"></i></span>之后，博主已经对这个“穷人的树莓派”佩服得五体投地了。</p>
<p>然而人的欲望总是无止境的，所以过了几天，博主又在并夕夕上剁手了斐讯 T1 盒子，也打算刷入 Armbian，作为日常实（瞎）验（搞）之用。</p>
<p>可网上一大堆教程都是在调教 N1，有关 T1 刷机的文章少之又少，一切只能自己摸索。</p>
<p>在害怕踩坑并搞烂 T1，导致自己省下的一百五十来块打水漂的情况下，于是博主带着 T1 去附近的庙里烧了香拜了佛……</p>
<p>听上去有些扯，但是博主最后顺利地让 T1 运行了 Armbian，并烧写镜像到了自带的 emmc 中。</p>
<p>这篇文章，便是调教 T1 盒子的笔记。</p>
<p><img data-src="https://c.ibcl.us/PhicommT1-Armbian_20190825/1.jpg" alt="T1 盒子" title="T1 盒子"></p>
<span id="more"></span>
<h2 id="开箱上电"><a href="#开箱上电" class="headerlink" title="开箱上电"></a>开箱上电</h2><p>拿到盒子接上电源，迎面而来便是斐讯俗里俗气的开机画面。启动完成后，是第一次使用前的配置向导，接上鼠标，资料一阵乱填，然后… 来到了手机绑定界面…</p>
<p><img data-src="https://c.ibcl.us/PhicommT1-Armbian_20190825/2.jpg" alt="绑定手机" title="绑定手机"></p>
<p>居然还要绑定手机，博主肯定不会用自己号码绑定的，然而又不能填 Google Voice 的号码，于是，博主填了同桌的电话号码…</p>
<p>按下获取验证码的按钮，博主马上给同桌打了电话。</p>
<blockquote>
<p><strong>窝：</strong>刚才有个验证码，你收到没得？<br><strong>同桌：</strong>啥子验证码？我啷个没收到诶？<br><strong>窝：</strong>就是那个… 斐讯的验证码耶，没收到啊，你等一哈…</p>
</blockquote>
<p>于是博主按下了重新发送验证码。</p>
<blockquote>
<p><strong>窝：</strong>现在收到了嘛？<br><strong>同桌：</strong>还是没有，恁么晚给窝打电话你是不是有病？</p>
</blockquote>
<p>挂断了电话，这时博主意识到斐讯可能已经关闭了注册通道…</p>
<p>难道 T1 就只能吃灰了？</p>
<p>查阅某屎黄色论坛里各位大佬们的发帖，发现原来可以用手机遥控可以跳过注册直接到设置，并打开 ADB。</p>
<p>配套的手机遥控器 APP 在盒子底部便可找到下载二维码。借着这种骚操作，跳过注册步骤直接进入设置，博主顺利地打开了 ADB 功能。</p>
<p><img data-src="https://c.ibcl.us/PhicommT1-Armbian_20190825/3.png" alt="开启 ADB" title="开启 ADB"></p>
<h2 id="系统降级"><a href="#系统降级" class="headerlink" title="系统降级"></a>系统降级</h2><p>接下来就是正式的调教了。</p>
<p>实际操作时，博主使用的是 Fedora Linux 系统，至于 Windows 下是否能成功对接 ADB 并进入 Fastboot 模式写入相关降级固件，博主并不清楚（逃。</p>
<p>事先安装了 <code>android-tools</code>，找到 T1 的 IP 地址，用 <code>adb connect</code> 命令建立连接。此处，博主 T1 分配到的 IP 地址是 <code>10.10.10.214</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ adb connect 10.10.10.214:5555</span><br></pre></td></tr></table></figure>

<p>返回了 Connected to 10.10.10.214:5555 这样的提示，表示连接成功，其他一大堆废话回显就不去管了。</p>
<p>接着，命令 T1 进入 Fastboot 模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ adb shell reboot fastboot</span><br></pre></td></tr></table></figure>

<p>这时，就该供出双公头 USB 数据线了，将数据线的一端<del>轻轻地插入 T1 的 USB 小穴中</del>，另一端接到电脑的 USB 接口上。</p>
<p>检查 T1 是否已被识别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ fastboot devices</span><br><span class="line">CASDB1154K01740 fastboot # 是设备的序列号</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9mLmliY2wudXMvJUU2JTk2JTkwJUU4JUFFJUFGJUU3JTlCJTkyJUU1JUFEJTkwJUU5JTk5JThEJUU3JUJBJUE3JUU1JTlCJUJBJUU0JUJCJUI2JUU1JTkyJThDJTIwZHRiJTIwJUU3JUFEJTg5L3QxLw==">位于本站的文件库，博主已将相关固件上传至此<i class="fa fa-external-link-alt"></i></span>。下载 <code>boot.img</code>、<code>bootloader.img</code>、<code>recovery.img</code> 降级固件到本地终端所在目录，然后将他们写入 T1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ fastboot flash boot boot.img</span><br><span class="line">yuki@meow:~$ fastboot flash bootloader bootloader.img</span><br><span class="line">yuki@meow:~$ fastboot flash recovery recovery.img</span><br></pre></td></tr></table></figure>

<p>没有报错就说明降级成功了，重启 T1，赋予她新生罢！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ fastboot reboot</span><br></pre></td></tr></table></figure>

<p>但是重启之后，却发现什么变化都没有。是的，肉体还在，只是灵魂变了。</p>
<h2 id="刷入-Armbian"><a href="#刷入-Armbian" class="headerlink" title="刷入 Armbian"></a>刷入 Armbian</h2><p>博主从 Armbian 的源码编译了最新的可用于 T1 的 Armbian Buster 镜像，同样的，也于本站的文件库中。</p>
<p>下载镜像并解压得到 .img 文件过后，用 balenaEtcher 将镜像写入 U 盘，写入完成后重新插拔 U 盘，然后可以看到多出了个卷标名为 Boot 的磁盘。</p>
<p>编辑 Boot 卷根目录下的 uEnv.txt，修改 dtb 文件名为 <code>meson-gxm-q201.dtb</code>，然后保存。</p>
<p>不过不要先急着插 U 盘到 T1 上面，因为现在需要电脑上执行命令，让 T1 知道下次应该从 U 盘启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ adb connect 10.10.10.214:5555</span><br><span class="line">yuki@meow:~$ adb shell reboot update</span><br></pre></td></tr></table></figure>

<p>考验手速的时候到了，在 T1 原系统画面黑下去的一瞬间，插入 U 盘。</p>
<p>重启了。博主看到了熟悉的 Linux 小企鹅…</p>
<p>Armbian 的默认 root 密码是 1234，系统会要求更改默认密码。</p>
<p>密码更新后，会提示创建一个新的子帐户，先按 Ctrl+C 跳过，稍后创建。</p>
<p>执行 <code>fdisk -l</code> 命令，可以看到 emmc 分区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device         Boot   Start      End  Sectors  Size Id Type</span><br><span class="line">/dev/mmcblk1p1      1368064  1617919   249856  122M  c W95 FAT32 (LBA)</span><br><span class="line">/dev/mmcblk1p2      1619968 30535679 28915712 13.8G 83 Linux</span><br></pre></td></tr></table></figure>

<p>现在，可以将系统安装到 emmc 里面了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@aml:~# ./install-aml.sh</span><br></pre></td></tr></table></figure>

<p>写入完成后，用 <code>poweroff</code> 命令关机，取下 U 盘，重新上电开机，此时启动的便会是 Debian 了。</p>
<h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><p>除了 Debian 的软件源之外，还有 Armbian 自己的软件源，位于 <code>/etc/sources/sources.list.d/armbian.list</code>。</p>
<p>由于你国网络具有神奇的特性，上述的两个软件源在使用的时候速度一般不会超过 40 KB/s，如果是第一次更新软件源的话，照这个速度怕是要等上一天。</p>
<p>国内有大学提供了 Debian 和 Armbian 的镜像源，为了节约时间，一定要换源。</p>
<p>方便起见，这里提供已经改好的软件源配置文件，可以用 curl 命令写入 <code>/etc/apt/sources.list</code> 和 <code>/etc/sources/sources.list.d/armbian.list</code>（需要联网）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@aml:~# cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">root@aml:~# cp /etc/apt/sources.list.d/armbian.list /etc/apt/sources.list.d/armbian.list.bak</span><br><span class="line">root@aml:~# curl https://c.ibcl.us/PhicommT1-Armbian_20190825/sources.list &gt; /etc/apt/sources.list</span><br><span class="line">root@aml:~# curl https://c.ibcl.us/PhicommT1-Armbian_20190825/armbian.list &gt; /etc/apt/sources.list.d/armbian.list</span><br></pre></td></tr></table></figure>

<p>然后，更新软件源并升级软件源到最新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@aml:~# apt update &amp;&amp; apt upgrade</span><br></pre></td></tr></table></figure>

<p><em>而在实际操作，执行到 apt upgrade 时，博主却遇到了 Read only filesystem 的报错，最后通过 U 盘引导，在 U 盘下面的 Armbian 系统下执行 <code>e2fsck /dev/mmcblk1p2</code> 才得以解决。</em></p>
<h2 id="安装桌面"><a href="#安装桌面" class="headerlink" title="安装桌面"></a>安装桌面</h2><p>完成后，使用 <code>armbian-config</code> 命令配置系统，安装桌面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@aml:~# armbian-config</span><br></pre></td></tr></table></figure>

<p><img data-src="https://c.ibcl.us/PhicommT1-Armbian_20190825/4.png" alt="armbian-config" title="armbian-config"></p>
<p>进入 System 项，然后选择 Default，系统先会引导创建一个子用户，然后下载相关文件并安装完整桌面。</p>
<p>大概 20 分钟之后，桌面就安装好了，这时重启一下系统。</p>
<p>由于 T1 只有一个 USB 口，所以还要接一个 USB Hub，才能容纳键盘和鼠标。推荐使用外部供电的 USB Hub，避免因 T1 电流不够而造成各种各样奇怪的问题。</p>
<p>此外，Armbian 自带浏览器 Chromium，可是总觉得有些不对劲…</p>
<p><img data-src="https://c.ibcl.us/PhicommT1-Armbian_20190825/5.png" alt="硬件加速开启时" title="硬件加速开启时"></p>
<p>经检查，这是开启了硬件加速才导致的。</p>
<p><img data-src="https://c.ibcl.us/PhicommT1-Armbian_20190825/6.png" alt="硬件加速关闭时" title="硬件加速关闭时"></p>
<p>前往 <span class="exturl" data-url="Y2hyb21lOi8vc2V0dGluZ3M=">chrome://settings<i class="fa fa-external-link-alt"></i></span>，翻到页面最底部，将 Use hardware acceleration when available 取消勾选，重启 Chromium 后即可正常显示。</p>
<h2 id="加-Swap"><a href="#加-Swap" class="headerlink" title="加 Swap"></a>加 Swap</h2><p>虽说 T1 有八核，但运行内存只有 2GB，看点视频简直卡成 PPT… 忍无可忍，最后又加了 2GB 的 Swap… 由于 Armbian 是采用的 ZRam 作为 Swap 方案，所以增加 Swap 的方式与一般的 Linux 也有所不同。</p>
<p>桌面单击右键，选中 Open Terminal Here，修改 ZRam 的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yukiho@aml:~/Desktop$ sudo nano /etc/default/armbian-zram-config</span><br></pre></td></tr></table></figure>

<p>取消掉 <code>ZRAM_PERCENTAGE=50</code> 一行的注释，然后将 <code>50</code> 改至 <code>100</code>，意为定义 ZRam 大小为物理内存的 100%，保存退出后重启 T1。</p>
<p>在重启过后，执行 free -m，看到 Swap 已经被应用。</p>
<p>开个视频试试看，Swap 用了不少，不过好在终于不卡顿了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yukiho@aml:~/Desktop$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1845         801         725         117         318         798</span><br><span class="line">Swap:          2047         581        1466</span><br></pre></td></tr></table></figure>

<h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><p>操作系统是英文不算是什么大问题，毕竟自己英语学得有那么好（捂脸</p>
<p>可是折腾的时候要打中文啊，所以这时中文输入法成了必不可少的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yukiho@aml:~/Desktop$ sudo apt install fcitx fcitx-config-gtk im-config fcitx-data fcitx-pinyin fcitx-ui-light fcitx-ui-classic fcitx-frontend-all fcitx-frontend-gtk2 fcitx-frontend-gtk3 fcitx-frontend-qt4 fcitx-frontend-qt5 fcitx-libs fcitx-module-dbus fcitx-module-x11 fcitx-modules fcitx-pinyin</span><br><span class="line">yukiho@aml:~/Desktop$ im-config -s fcitx -z default</span><br><span class="line">yukiho@aml:~/Desktop$ fcitx</span><br></pre></td></tr></table></figure>

<p>然后按下 Ctrl+C，接下来加入 Fcitx 到系统的输入法选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yukiho@aml:~/Desktop$ fcitx-config-gtk3</span><br></pre></td></tr></table></figure>

<p>在弹出的图形页面左下角按下 + 号，并在对话框中取消 Only Show Current Language 复选框，选中 Pinyin 后保存配置并退出。</p>
<p>接着重启，不出意外，状态栏已经出现了一个键盘的标志。恭喜，输入法安装成功了！</p>
<p>使用 Ctrl+Space 切换输入法，然后就可以输入中文了。</p>
<p><img data-src="https://c.ibcl.us/PhicommT1-Armbian_20190825/7.png" alt="斐讯牛逼惨了" title="斐讯牛逼惨了"></p>
<p>享受输入的乐趣罢！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>折腾到这里，文章也接进尾声了，总的来说，T1 与 N1 的操作大同小异，只是由于后续的 Armbian 镜像无法识别 emmc 和 Wifi 模块，而较早的镜像又被原作者删除，只能自己编译镜像…</p>
<p>另外， 由于 T1 的体积比 N1 小了不少，也导致了 T1 的发热量很高，对于重庆这种夏天动辄 40 摄氏度的地区还是不太友好…</p>
<p>等到冬天再用罢！</p>
<p>最后，想说的是…</p>
<blockquote>
<p>我买了台斐讯 T1，我发现这破玩意…</p>
</blockquote>
<blockquote>
<p><strong>牛逼惨了。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>瞎搞</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅地编写寄存器读写驱动，然后惊艳所有人</title>
    <url>/Register-RW_20240107/</url>
    <content><![CDATA[<p>在博主刚入门单片机时，经常看到其他人写出类似这样的驱动代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 其他内容</span></span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0xAE</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0x00</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0x40</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0xDA</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0x1D</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0xF1</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0x8D</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0x14</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0xA4</span>);</span><br><span class="line"><span class="built_in">i2c_write_cmd</span>(<span class="number">0xA6</span>);</span><br><span class="line"><span class="comment">// ... 其他内容</span></span><br></pre></td></tr></table></figure>

<p>作为小白，看到一大堆的 16 进制数字，自然是一脸懵比，就算看了半天也只能从调用的函数名字勉强猜出这可能是在操作寄存器，但是具体是什么寄存器，写入的值是什么，就不得而知了。</p>
<p>用这种一把梭方式写出的驱动代码，不仅可读性极差，而且一旦需要修改，事情就会变得非常麻烦：由于不清楚每句代码都是在操作哪个寄存器，因此开发者又需要回到 Datasheet 中去查找寄存器的地址，然后再去查看寄存器的功能，最后才能确定要写入的值，这样的开发效率可想而知，如果时间一长，开发者便会对这个项目产生厌恶情绪，最终导致项目被搁置，而屎山项目也就此诞生。</p>
<p>但不幸的是，这种一把梭的方式在很多开源项目中都能看到，因此这也让有强迫症的博主非常不爽。对此，博主决定写一篇文章，以自己的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL2V4cGxvcmVyL3RyZWUvbWFzdGVyL2Zpcm13YXJl">AnyShake Explorer 项目开发途中为 ADC 编写驱动<i class="fa fa-external-link-alt"></i></span>的经历为例，来分享如何才能写出能惊艳到其他人的驱动代码。</p>
<span id="more"></span>

<p>博主在开发 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL2V4cGxvcmVyL3RyZWUvbWFzdGVyL2Zpcm13YXJl">AnyShake Explorer<i class="fa fa-external-link-alt"></i></span> 时，ADC 选型为 TI 家的 ADS1262，这是一款 32 位的 ADC，使用 SPI 协议进行通信，提供 10 个通道。由于网上现成的库实在太少，因此博主只能自己编写驱动。</p>
<p>ADS1262 的 Datasheet 位于 <span class="exturl" data-url="aHR0cHM6Ly93d3cudGkuY29tL2xpdC9kcy9zeW1saW5rL2FkczEyNjIucGRm">www.ti.com/lit/ds/symlink/ads1262.pdf<i class="fa fa-external-link-alt"></i></span>，其中，芯片寄存器表位于第 88 页，如下图所示。</p>
<p><img data-src="https://c.ibcl.us/Register-RW_20240107/1.png" alt="ADS1262 芯片寄存器表"></p>
<p>从表中可以看到，ADS1262 一共有 21 个寄存器（剩下 6 个寄存器为 ADS1263 独占），每一个寄存器中有 8 位的数据。</p>
<p>在寄存器表的下文中，TI 详细介绍了每一个寄存器中每一位的功能、可选值及默认值等资讯，如下图所示。</p>
<p><img data-src="https://c.ibcl.us/Register-RW_20240107/2.png" alt="ADS1262 芯片寄存器功能介绍"></p>
<p>以寄存器 <code>POWER</code> 为例，其地址为 <code>0x01</code>，其中，第 4 位指示芯片是否被复位过，第 1 位控制芯片是否为 AICOM 启用电平转换电压，第 0 位控制芯片是否启用内部参考电压，其他位则为保留位，其值必须为 0。</p>
<p>看到这里，或许一些人会想到可以定义下面几个函数来实现对 <code>POWER</code> 寄存器的读写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">ads1262_get_reg_power_bit_reset</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">ads1262_get_reg_power_bit_vbias</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">ads1262_get_reg_power_bit_vref</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ads1262_set_reg_power_bit_reset</span><span class="params">(<span class="type">uint8_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ads1262_set_reg_power_bit_vbias</span><span class="params">(<span class="type">uint8_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ads1262_set_reg_power_bit_vref</span><span class="params">(<span class="type">uint8_t</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这种方法的优点是，每一个函数都只负责一个寄存器功能位的读写，因此函数的代码量非常少，而且由于函数名字中已经包含了寄存器与寄存器位的名字，因此函数的可读性也非常好。</p>
<p>但是，这种方法的缺点也非常明显：由于每一个寄存器的功能位都需要编写 2 个函数（get 函数和 set 函数），因此当寄存器功能位数量较多时，这种方法会导致项目总体代码量急剧膨胀，而且这样一来，工作量也是非常大的。</p>
<p>因此，博主认为这种方式并不适合用于编写驱动代码，所以需要寻找一种更好的办法，也就是<strong>仅为寄存器整体编写读写函数</strong>，这样一来，对于每个寄存器整体，只需要编写 2 个函数（同样是 get 函数和 set 函数）即可，而寄存器中的每一个功能位，则将其封装到一个结构体中，调用时取其指针传入函数参数即可。</p>
<p>所以，上述的 <code>POWER</code> 寄存器的读写函数接口，博主会这样定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __ADC_POWER_DEFAULT_VALUE 0x11</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_POWER_RESET_NONE 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_POWER_RESET_OCCURRED 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_POWER_VBIAS_DISABLED 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_POWER_VBIAS_ENABLED 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_POWER_INTREF_DISABLED 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_POWER_INTREF_ENABLED 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Reset indicator, indicates ADC reset has occurred. Clear this bit to</span></span><br><span class="line">    <span class="comment">// detect the next device reset.</span></span><br><span class="line">    <span class="comment">// 0x00: No reset</span></span><br><span class="line">    <span class="comment">// 0x01: Reset has occurred (default)</span></span><br><span class="line">    <span class="type">uint8_t</span> reset = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// Level shift voltage enable, enables the internal level shift voltage to</span></span><br><span class="line">    <span class="comment">// the AINCOM pin.</span></span><br><span class="line">    <span class="comment">// 0x00: Disabled (default),</span></span><br><span class="line">    <span class="comment">// 0x01: Enabled</span></span><br><span class="line">    <span class="type">uint8_t</span> vbias = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// Internal reference enable, enables the internal reference voltage. Note</span></span><br><span class="line">    <span class="comment">// the IDAC and temperature sensor require the internal voltage reference.</span></span><br><span class="line">    <span class="comment">// 0x00: Disabled</span></span><br><span class="line">    <span class="comment">// 0x01: Enabled (default)</span></span><br><span class="line">    <span class="type">uint8_t</span> intref = <span class="number">0x01</span>;</span><br><span class="line">&#125; <span class="type">adc_reg_power_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adc_reg_set_power</span><span class="params">(<span class="type">adc_reg_power_t</span>* power)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adc_reg_get_power</span><span class="params">(<span class="type">adc_reg_power_t</span>* power)</span></span>;</span><br></pre></td></tr></table></figure>

<p>至于上述定义中读写函数的实现，实际上也非常简单，只需要将结构体中的每一个成员变量的值按位写入到寄存器中，或者将寄存器中的值按位读取到结构体中即可。</p>
<p>例如写入函数的实现，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adc_reg_set_power</span><span class="params">(<span class="type">adc_reg_power_t</span>* power)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> power_data = __ADC_POWER_DEFAULT_VALUE;</span><br><span class="line">    power_data &amp;= ~(<span class="number">0x01</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    power_data |= (power-&gt;reset &amp; <span class="number">0x01</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    power_data &amp;= ~(<span class="number">0x01</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    power_data |= (power-&gt;vbias &amp; <span class="number">0x01</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    power_data &amp;= ~<span class="number">0x01</span>;</span><br><span class="line">    power_data |= power-&gt;intref &amp; <span class="number">0x01</span>;</span><br><span class="line">    <span class="built_in">adc_write_reg</span>(ADC_REG_POWER, &amp;power_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段函数中，寄存器默认值（可从 Datasheet 中获得）先赋给了 <code>power_data</code> 变量，然后结构体中每一个成员变量的值又按位写入到 <code>power_data</code> 变量中，最后，<code>power_data</code> 变量的值写入寄存器中，寄存器则写入完成。</p>
<p>而读取函数的实现，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adc_reg_get_power</span><span class="params">(<span class="type">adc_reg_power_t</span>* power)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> power_data = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">adc_read_reg</span>(ADC_REG_POWER, &amp;power_data);</span><br><span class="line">    power-&gt;reset = (power_data &amp; <span class="number">0x10</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    power-&gt;vbias = (power_data &amp; <span class="number">0x02</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    power-&gt;intref = power_data &amp; <span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段函数中，寄存器中读取到的数据首先赋给了 <code>power_data</code> 变量，然后，<code>power_data</code> 变量中的值再按位提取到结构体中，最后，结构体中的值就是寄存器中的值，读取完成。</p>
<p>如此一来，每个寄存器的功能位数量不再影响函数的数量，而且当需要修改某个寄存器的读写函数时，也只需要修改 2 个函数，这样的工作量也是非常小的。而且，这样的代码更加具有可读性，维护起来也更加方便。</p>
<p>另外，博主还尽量保持了驱动代码的可移植性，例如，对于 SPI 通信，博主并未使用 Arduino 提供的 <code>spi_transfer()</code> 函数，或是 STM32 提供的 <code>HAL_SPI_Transmit()</code> 函数，而是自行对其重新进行了封装，因此才有了 <code>adc_write_reg()</code> 函数和 <code>adc_read_reg()</code> 函数。若是需要移植到其他平台，也只需要修改这两个函数即可。</p>
<p>值得一提的是，在 Linux 内核中的驱动代码中，大多数寄存器的读写函数接口都是用类似的方式编写的，博主的灵感也正是来自于此。</p>
<p>至于这套完整的 ADS1262 驱动代码，可以在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL2V4cGxvcmVyL3RyZWUvbWFzdGVyL2Zpcm13YXJl">AnyShake Explorer 项目的 firmware 目录中找到<i class="fa fa-external-link-alt"></i></span>，欢迎大家批评指正。</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>C / C++</tag>
        <tag>SPI</tag>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title>探寻二十年前的声卡 SDR</title>
    <url>/Soundcard-SDR_20230601/</url>
    <content><![CDATA[<p>几日前和一个朋友聊起 SDR，在感叹两年的芯片短缺潮终于快要翻篇之余，朋友还提到了快二十年前他在玩的一种 SDR。</p>
<p>RTL-SDR 的出现在 2012 年左右，值得一提的是，博主入坑 SDR 的第一台设备，也是 RTL-SDR。而在这之前，SDR 设备主要还是集中在专业领域，成本较高且功能也相对有限，仅有 USRP、BladeRF 等几种选择，对于博主这样的业余玩家来说，要是当年购买一套 USRP 或是 BladeRF，恐怕就要掏空好几个腰包了。</p>
<p>即便如此，也没有难住那时的玩家：<strong>在遥远的当年，比较流行的一个方案就是 DIY 一块包含了射频信号采集、混频、放大、滤波的板卡，然后将其与 PC 上的声卡相连，以声卡作为 ADC，再透过软件进行信号处理，这就是声卡 SDR</strong>。</p>
<p><img data-src="https://c.ibcl.us/Soundcard-SDR_20230601/1.png" alt="声卡 SDR 架构图"></p>
<p>上图是一个典型的声卡 SDR 架构框图，在博主正式给出声卡 SDR 的原理图之前，还需要引入一些概念和理论做铺垫，便于以出浅入深的方式去分析及理解声卡 SDR 的工作原理。</p>
<span id="more"></span>

<h1 id="I-Q-信号"><a href="#I-Q-信号" class="headerlink" title="I/Q 信号"></a>I/Q 信号</h1><p>在通常的数字通信中，通常将复杂信号以两个正交的信号分量 I 和 Q 来表示，其中，<strong>I 指代同相（In-phase），Q 则指代正交（Quadrature），另外，I 分量和 Q 分量之间的相位差通常为 90 度</strong>。</p>
<p>I 分量表示信号在实轴上的幅度或幅度变化，Q 分量表示信号在虚轴上的幅度或幅度变化。若将这两个信号组合起来，则可以表示复杂信号的幅度和相位信息。</p>
<p>要生成 I/Q 信号，可以透过混频器和振荡器来实现，其基本原理是将原始信号与正弦（I）和余弦（Q）波形进行乘法运算，即可得到对应的 I/Q 信号。</p>
<p>使用 I/Q 信号的意义在于，I/Q 信号在数字信号处理中提供了更大的灵活性。透过对 I/Q 信号进行数字信号处理操作，如滤波、频谱分析、调制解调等，可以实现更高级的信号处理功能，例如信号的解调、编码解码、信道估计、自适应调制等。</p>
<p>例如在 GNURadio 中，<code>complex</code> 数据类型就表示了 I/Q 数据，生成一个余弦信号，并使用 Time Sink 查看其时域波形，可以看到，实部信号（即 I 分量）与虚部信号（即 Q 分量）之间相位差刚好为 90 度。</p>
<p><img data-src="https://c.ibcl.us/Soundcard-SDR_20230601/2.png" alt="GNURadio 中 complex 数据类型"></p>
<p>由于本文的重点不在 I/Q 调制和解调的原理上，所以这里只会简单介绍 I/Q 信号的构成及应用领域，有兴趣的朋友可以自行查阅相关资料及文献。</p>
<h1 id="移相器与触发器"><a href="#移相器与触发器" class="headerlink" title="移相器与触发器"></a>移相器与触发器</h1><p>刚刚上文提到，I 分量和 Q 分量之间相位差为 90 度，而要实现这样的相位差，硬件层面则需要透过移相器（Phase Shifter）来实现。移相器的主要功能是将输入信号的相位进行可控的变化，可以增加或减小信号的相位角度，或者将相位角度移动到不同的位置。</p>
<p>从硬件层面来说，虽然可能有人没接触过移相器的概念，但是如果曾经有学过数字电路，那么多半会接触到触发器（Flip-Flop）这一器件。触发器是一种存储器件，可以将输入信号的状态（高电平或低电平）先存储起来，然后在时钟信号的作用下，将存储的状态输出。</p>
<p>所以，结合上述两个器件的共通之处，就可以透过触发器来实现移相器的功能，例如使用 D 触发器、JK 触发器等。向触发器输入的时钟信号可以由 SI5351 等模块产生，透过调整 SI5351 等模块产生的时钟频率，即可实现移相的操作，从而调制出 I/Q 信号。</p>
<p>本文决定采用 D 触发器来实现移相器的功能，74HC74 双 D 触发器就是一个不错的选择。借助此 IC 中的两个 D 触发器，可以产生相位差分别为 0 度、90 度、180 度和 270 度的 4 个信号，<strong>而我们只需要取出其中相位差为 90 度的任意两路信号即可构成 I/Q 信号</strong>。博主使用了 Proteus 来模拟 74HC74 用作移相器的电路，如下图所示。</p>
<p><img data-src="https://c.ibcl.us/Soundcard-SDR_20230601/3.png" alt="74HC74 双 D 触发器原理图"></p>
<p>仿真结果如下所示，可以明显看到不同输出端有不同的相位差，从而验证了这套方案的可行性。</p>
<p><img data-src="https://c.ibcl.us/Soundcard-SDR_20230601/4.png" alt="74HC74 实现移相器仿真"></p>
<p>值得一提的是，由于此电路的工作原理和双 D 触发器的特性使然，<strong>当使用 74HC74 作为移相器时，其输出频率为输入频率的 1/4</strong>，所以在使用时，需要将输入信号的频率调整到 4 倍，这样才能得到正确的输出信号。例如要产生 9 MHz 的 I/Q 信号，那么输入信号的频率应该为 9 * 4 = 36 MHz，这样才能得到正确的 9 MHz 的 I/Q 信号。</p>
<h1 id="模拟开关与混频器"><a href="#模拟开关与混频器" class="headerlink" title="模拟开关与混频器"></a>模拟开关与混频器</h1><p>混频器的主要功能是将两路信号做乘法运算，其输出信号的频率为两路输入信号频率的和与差。</p>
<p>下面是使用 GNURadio 进行混频的例子，原始信号频率 10 kHz，用于混频的信号频率为 -9 kHz，那么最终能得到混频后的信号频率为 1 kHz。</p>
<p><img data-src="https://c.ibcl.us/Soundcard-SDR_20230601/5.png" alt="GNURadio 实现混频"></p>
<p>又例如使用使用 48 Ksps 采样率的声卡 SDR 接收 9.75 MHz 上的电台，那么就需要将 9.75 MHz 的信号降频到 -24 kHz 至 +24 kHz 的范围之内（声卡左右声道对应 I/Q 信号，每个声道带宽 24 kHz），所以通过计算可得，若要在声卡 SDR 上接收 9.75 MHz 的电台，则需要将 9.75 MHz 的信号降频到 9.75 MHz - 24 kHz = 9.726 MHz 至 9.75 MHz + 24 kHz = 9.774 MHz 的范围内，而这一段频率，就需要由上面合成的 I/Q 信号来提供了。</p>
<p>本文选用 74HC4052 双 4 通道模拟开关来实现混频器的功能，其真值表如下所示。</p>
<table>
<thead>
<tr>
<th align="center">通道选择 - A</th>
<th align="center">通道选择 - B</th>
<th align="center">连通通道 - X</th>
<th align="center">连通通道 - Y</th>
</tr>
</thead>
<tbody><tr>
<td align="center">L</td>
<td align="center">L</td>
<td align="center">X -&gt; X0</td>
<td align="center">Y -&gt; Y0</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">L</td>
<td align="center">X -&gt; X1</td>
<td align="center">Y -&gt; Y1</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">H</td>
<td align="center">X -&gt; X2</td>
<td align="center">Y -&gt; Y2</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">H</td>
<td align="center">X -&gt; X3</td>
<td align="center">Y -&gt; Y3</td>
</tr>
</tbody></table>
<p>其中，上文中由双 D 触发器产生的相位差为 90 度的 I/Q 信号可以作为 74HC4052 的通道选择输入端 A、B；由天线接收到的信号则可以先分成两路，分别输入到 74HC4052 的连通通道输入端 X、Y，这样一来，就可以实现混频器的功能了。下图是 74HC4052 的接线图，<strong>值得一提的是，Xn 和 Yn 的引脚（n = 0, 1, 2, 3）应当相互连接起来，实现所选的输入信号直接连接到输出端口，进而实现信号的直通功能</strong>。</p>
<p><img data-src="https://c.ibcl.us/Soundcard-SDR_20230601/6.png" alt="74HC4052 双 4 通道模拟开关"></p>
<h1 id="放大器及滤波器"><a href="#放大器及滤波器" class="headerlink" title="放大器及滤波器"></a>放大器及滤波器</h1><p>由于混频过后的信号仍然较弱，所以需要经过放大器进行放大，而放大器的输出信号则需要经过滤波器进行滤波，以去除掉不需要的频率分量。本文选用了 LM358 作为放大器，并使用一个电容作为降频滤波器。</p>
<p><img data-src="https://c.ibcl.us/Soundcard-SDR_20230601/7.png" alt="LM358 放大及滤波电路"></p>
<p>透过原理图，可以得知如下几点。</p>
<ol>
<li>为了降低元件耦合到电源端的噪声，运放输入端各连接了一个电容到 GND</li>
<li>反相输入端通过反馈电阻连接到运放的输出端，用于控制增益和频率响应</li>
<li>反馈电阻上还并联了一个电容，实现一个低通滤波器，使得高频噪声能够被滤除</li>
</ol>
<h1 id="完整电路图"><a href="#完整电路图" class="headerlink" title="完整电路图"></a>完整电路图</h1><p>若将上述内容综合起来，其实一个完整的声卡 SDR 电路已经呼之欲出了。最后附上完整电路图，细心的人可能已经发现，其实博主要 DIY 的这款声卡 SDR，就是曾流行一时的 <span class="exturl" data-url="aHR0cDovL3Fyei5sdC9seTFncC9TRFIv">ZetaSDR<i class="fa fa-external-link-alt"></i></span>。另外，在原理图中，时钟输入（即 CLK_IN 标签）将由 SI5351 模块来完成，以实现频率范围调节的功能。</p>
<p><img data-src="https://c.ibcl.us/Soundcard-SDR_20230601/8.svg" alt="ZetaSDR 完整电路图"></p>
]]></content>
      <categories>
        <category>SDR</category>
      </categories>
      <tags>
        <tag>SDR</tag>
        <tag>软件无线电</tag>
        <tag>无线电</tag>
        <tag>GNURadio</tag>
        <tag>模拟电路</tag>
        <tag>数字电路</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写出一份好的收听报告</title>
    <url>/Write-ReceptionReport_20180715/</url>
    <content><![CDATA[<p><em>如何写出一份能让大多数电台接受的，高质量的收听报告？</em></p>
<p>在这篇文章中，你将了解如何撰写一份好的收听报告。</p>
<p><img data-src="https://c.ibcl.us/Write-ReceptionReport_20180715/1.jpg" alt="Reception Report" title="Reception Report"></p>
<span id="more"></span>

<h3 id="收听报告的语言"><a href="#收听报告的语言" class="headerlink" title="收听报告的语言"></a>收听报告的语言</h3><h4 id="国际广播电台"><a href="#国际广播电台" class="headerlink" title="国际广播电台"></a>国际广播电台</h4><p>向一些国际上面的长／中／短波电台寄送收听报告，使用英文当然是最佳选择，毕竟英文是世界通用语言。另外，使用英文也可以使你的报告看上去更加正规。这样做还可以在一定程度上提高电台回复你的几率，因为即使有一些国际广播电台有中文节目，但是负责审阅你的收听报告并签发ＱＳＬ的那位朋友不一定是中国人．．．．．</p>
<h4 id="海外地方电台"><a href="#海外地方电台" class="headerlink" title="海外地方电台"></a>海外地方电台</h4><p>当然也是最好使用英文，除非你精通当地的语言，可以考虑这样做试试。下面是一些比较容易收到当地地方电台回复的**<del>国家</del>**和地区（我可没说全部是国家）：</p>
<ul>
<li>日本</li>
<li>韩国</li>
<li>台湾</li>
<li>香港</li>
<li>美国</li>
<li>欧洲</li>
</ul>
<h4 id="国内对内／对外广播电台"><a href="#国内对内／对外广播电台" class="headerlink" title="国内对内／对外广播电台"></a>国内对内／对外广播电台</h4><p>相比上面两种情况来说，这个这要麻烦一些，因为不少国内的对内／对外电台对自己人的来信重视程度不够，所以要认真书写收听报告。</p>
<p>都是自己人，那还用什么英文？这时用中文写收听报告要比用英文好得多。除了收听报告之外，最好再附上一封信，这样让你的邮件跟其他听众的有所区别、与众不同。</p>
<p>信中要告诉电台你的这项特殊爱好，你从远方收听到这个电台是多么不容易，收听到后你有什么感想（什么地球真小呀、离你们真近呀），电台的节目如何如何，最好*<del>发自内心</del>*（国内电台真恶心），再不然就是节目主持人的语言特点，普通话清晰标准云云；还可就节目主题谈谈看法，但是最好是表扬性质的。</p>
<p>收听报告和信件最好打印，要不然也需要认真书写清晰。</p>
<h4 id="国内地方电台"><a href="#国内地方电台" class="headerlink" title="国内地方电台"></a>国内地方电台</h4><p>最恶心的东西来了，做好心理准备．．．．．．</p>
<p>国内一些地方电台（应该是绝大多数）都不知道 QSL 是个什么玩意儿，博主曾经向重庆之声（1314 kHz），陕西交通广播（1323 kHz），四川人民广播电台新闻频率（1116 khz）等 ６ 个地方电台邮寄过收听报告，苦等了 ３ 个月，杳无音信。而事实上，国内绝大多数的地方电台都没有 QSL，更不知道 QSL 是个什么玩意，所以即使你为他们寄去再厚的报告，可能也只会被他们当作废品处理掉。</p>
<p>那怎么办？潮州听友 <span class="exturl" data-url="aHR0cHM6Ly9yYWRpb2Z1bmhvbmcud29yZHByZXNzLmNvbS8=">Radiofun-Hong<i class="fa fa-external-link-alt"></i></span> 便尝试使用 PFC 卡，得到了江西新闻广播的回复以及电台公章。</p>
<p>所谓 PFC 卡，即为自行印制 QSL，然后与收听报告一同寄给电台，并得到电台的回复。PFC 是 Prepared Form Card 的缩写。<span class="exturl" data-url="aHR0cHM6Ly9iY2xndWlkZS5leGJsb2cuanAvNTIyNTM0My8=">详见 bclguide.exblog.jp/5225343/<i class="fa fa-external-link-alt"></i></span>。</p>
<p>这种收听报告的语言当然要中文，另外，最好再附上一封信，专门介绍 <strong>QSL 是什么</strong>。</p>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzg2ZDVmNDQ0MDEwMng3MmMuaHRtbA==">另外，像 CRI 这样的国家电台已经开始为地方电台代签 QSL<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="收听报告上记录的内容"><a href="#收听报告上记录的内容" class="headerlink" title="收听报告上记录的内容"></a>收听报告上记录的内容</h3><p>报告的内容要详实，以一份英文收听报告为例，基本项目有如下：</p>
<ul>
<li>日期（DATE）</li>
<li>时间（TIME TO TIME）</li>
<li>频率（FREQUENCY）</li>
<li>ＳＩＮＰＯ（亦可作ＳＩＯ）</li>
<li>备注（Comments）</li>
<li>节目细节（Programme Details）</li>
<li>接收设备（Receiver）</li>
<li>天线种类（Antenna）</li>
</ul>
<p>下面依次介绍之。</p>
<h4 id="日期（DATE）"><a href="#日期（DATE）" class="headerlink" title="日期（DATE）"></a>日期（DATE）</h4><p>采用国外的格式，即月份、日期在前，年份在后。今天是 2018 年 7 月 15 日，英文写下来就是 July 15th, 2018，不知道英文月份怎么写的请自行 Google。</p>
<h4 id="时间（TIME-TO-TIME）"><a href="#时间（TIME-TO-TIME）" class="headerlink" title="时间（TIME TO TIME）"></a>时间（TIME TO TIME）</h4><p>除了给国内的电台写报告时可以用北京时间 CST 之外，给其他国家的电台写报告时一律采用格林尼治标准时间 GMT/UTC。比如博主写下这篇文章时是北京时间 20:00，换算成 GMT 即为 12:00。也就是说 GMT=CST-8。<del>如果你的数学跟博主的一样差</del>，那就上 <span class="exturl" data-url="aHR0cHM6Ly90aW1lLmlzLw==">time.is<i class="fa fa-external-link-alt"></i></span> 看时间去吧（</p>
<h4 id="频率（FREQUENCY）"><a href="#频率（FREQUENCY）" class="headerlink" title="频率（FREQUENCY）"></a>频率（FREQUENCY）</h4><p>一般以 kHz 为单位，除非是在 FM。当然，如果硬是要用 MHz 谁又管得着呢？这只是一种相互约定好的习惯罢了。</p>
<h4 id="SINPO（SIO）"><a href="#SINPO（SIO）" class="headerlink" title="SINPO（SIO）"></a>SINPO（SIO）</h4><p>关于 SINPO，这是使用收音机收听短波电台时，用来描述接收质量的一种方法。含义如下：</p>
<ul>
<li>S（Signal strength）：信号强度</li>
<li>I（Interference）：从其他电台传来的干扰</li>
<li>N（Nature Noise）：天电噪声，通常是由于电离层所引起的。</li>
<li>P（Propogation）：传播（大多数情况下就是指衰落）</li>
<li>O（Overall merit）：总体评价</li>
</ul>
<p>以上每种代码都分别由 １ 至 ５ 不同的值来确定不同的级别。</p>
<ul>
<li>在 S 中，１ 是最差，５ 是最好。</li>
<li>在 I 中，１ 是干扰最大，５ 是良好无干扰。</li>
<li>在 N 中，１ 是噪音最大，５ 是良好无噪音。</li>
<li>在 P 中，１ 是衰落起伏最严重，５ 是几乎没有衰落起伏。</li>
<li>在 O 中，１ 是最差，５ 是最好。</li>
</ul>
<p>如果收听到一个非常强和稳定的短波台信号，且该信号没有任何临频干扰及信号衰落（俗称“清晰如调频”），则信号可描述为最高品质，即 55544。</p>
<p>假设有一个强信号，但有轻微干扰和偶尔的衰落便可描述为 54443；另一极端情况，如果收听电台的发射功率非常低，又相距很远，还伴有凶猛的干扰，信号如此坏以至于很难听清电台广播的节目内容，此情况则可描述为 21331。</p>
<p>在收听报告表中所记录的 SINPO 值请努力争取精确和真实，此外，这里的 O 项带有一定的主观性，请酌情而定，千万不要人为地增值。同时，Ｏ 项是不能高于前四项的。</p>
<p>广播电台喜欢知道在该区域内广播信号的实际接收状况。</p>
<p>方便起见，博主制作了一份 SINPO 码的 PDF 文档，欢迎下载查看。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jLmliY2wudXMvV3JpdGUtUmVjZXB0aW9uUmVwb3J0XzIwMTgwNzE1L1NJTlBPX0NvZGUucGRm">SINPO_Code.pdf<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="备注（Comments）"><a href="#备注（Comments）" class="headerlink" title="备注（Comments）"></a>备注（Comments）</h4><p>你接收到的电台附近有干扰吗？如果没有，就请填上 NONE 吧，如果有，在能查明干扰电台的情况下，请填上这个电台的频率，名称。一般情况下，这些都可以在一些频率表中查询到。像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CNR 2, Frenquency: 6090kHz</span><br></pre></td></tr></table></figure>

<h4 id="节目细节（Programme-Details）"><a href="#节目细节（Programme-Details）" class="headerlink" title="节目细节（Programme Details）"></a>节目细节（Programme Details）</h4><p>都有听到了些什么呢？是什么节目呢？对于那些外语的电台，如果听不懂，就只有记录一些零碎的东西了，比如什么时候是一个男性在主持节目，什么时候是一个女性在主持节目，什么时候是一个谈话节目，什么时候在放歌，什么时候在报道新闻，有个什么你能听懂的关键词……</p>
<p>举个例子，这是博主给日本 Mainichi Hoso (MBS) 每日放送的收听报告。</p>
<blockquote>
<p>UTC 08:32, A Japanese song; UTC 08:36, A talking programme; UTC 08:42, The keyword “MBS”; UTC 08:44, Hosted by a female; UTC 08:45, The keyword “Tenki”.</p>
</blockquote>
<h4 id="接收设备（Receiver）"><a href="#接收设备（Receiver）" class="headerlink" title="接收设备（Receiver）"></a>接收设备（Receiver）</h4><p>是什么接收设备？</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My receiver is a ... （E.g.：Sony SW77） made in Japan by the ... company.</span><br></pre></td></tr></table></figure>

<p>意为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我所用的收音机是由日本的...公司制作的....机器（例如：索尼SW77）</span><br></pre></td></tr></table></figure>

<p>当然，直接填写收音机型号也是可以的，只要这个品牌有足够的知名度。博主是 TECSUN PL600。</p>
<h4 id="天线种类（Antenna）"><a href="#天线种类（Antenna）" class="headerlink" title="天线种类（Antenna）"></a>天线种类（Antenna）</h4><p>这个多了去了，环形天线（Loop Antenna）、八木天线（Yagi Antenna）、倒Ｖ天线（Inverted Vee Antenna），如果没这些，甚至可以写“xx Metres Long Wire.”，意为 xx 公尺长的电线。收音机自带的拉杆天线是 Telescopic Antenna。</p>
<h3 id="收听报告的格式"><a href="#收听报告的格式" class="headerlink" title="收听报告的格式"></a>收听报告的格式</h3><p>按照英文书信的格式写就可以了，首先是“From”，再是“To”，然后是正文，即一些简单的问候，问候结束之后便是收听报告的内容了。</p>
<p>内容结束后，写下自己的要求和几句简短的祝福，最后署名“Yours sincerely, XXX”就好了。</p>
<p>给出一个实例。这是博主寄送给日本 RADIO NIKKEI 1 日经放送的收听报告。</p>
<p><img data-src="https://c.ibcl.us/Write-ReceptionReport_20180715/2.jpg" alt="RADIO NIKKEI 1 日经放送" title="RADIO NIKKEI 1 日经放送"></p>
<h3 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h3><ol>
<li>如果电台有专门的收听报告模板，则最好用他们自己的，比如<a href="https://ibcl.us/QSL-RadioLiangyou_20170502/">良友电台</a>就有自己的收听报告模板。</li>
<li>如果是邮寄的收听报告，你可以在信封中塞一些有纪念价值的小物件，如印有你所在地风景的，写上祝福的明信片等。</li>
<li>使用 IRC 能在很大程度上提高电台回复的积极性。</li>
<li>切忌弄虚作假。</li>
<li>最好不要使用网上共享的 SDR 来接收电台并索取 QSL，有时会造成误会。<a href="https://ibcl.us/SDR-QSL_20180308/">参见 ibcl.us/SDR-QSL_20180308/</a></li>
</ol>
<h3 id="附上一份收听报告模板（英文）"><a href="#附上一份收听报告模板（英文）" class="headerlink" title="附上一份收听报告模板（英文）"></a>附上一份收听报告模板（英文）</h3><p><span class="exturl" data-url="aHR0cHM6Ly9jLmliY2wudXMvV3JpdGUtUmVjZXB0aW9uUmVwb3J0XzIwMTgwNzE1L1JlY2VwdGlvbi1SZXBvcnQuZG9jeA==">Reception-Report.docx<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>最后，祝大家玩的开心～</p>
<p><img data-src="https://c.ibcl.us/Write-ReceptionReport_20180715/3.jpg" alt="收听报告老司机" title="收听报告老司机"></p>
]]></content>
      <categories>
        <category>广播</category>
      </categories>
      <tags>
        <tag>广播</tag>
        <tag>原创</tag>
        <tag>收听报告</tag>
      </tags>
  </entry>
  <entry>
    <title>修改 RTL-SDR 驱动使 rtl_tcp 支持从 I/Q 通道直采信号</title>
    <url>/rtltcp-BranchIQ_20190611/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主最近申请到了 WebSDR 的服务端程序，在准备好各种环境之后，却卡在了与 RTL-SDR 的对接上……</p>
<p>WebSDR 的后端一般与 RTL-SDR 驱动自带的 TCP 服务器模块 <code>rtl_tcp</code> 对接并进行调谐。<code>rtl_tcp</code> 的启动很简单，只需要一行命令即可解决。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@yukiho:~# rtl_tcp -a 127.0.0.1 -s 1024000 -g 0 -d 0 -p 1234</span><br></pre></td></tr></table></figure>

<p>在设置好中心频率（9500 kHz），采样率（1.2 Msps）并启动该模块之后，博主却发现 WebSDR 并不能正常地接收短波信号，频谱瀑布一片空白。</p>
<p>这就很迷了。经过一波分析之后，博主得出了结论：</p>
<blockquote>
<p><code>rtl_tcp</code> 命令不能像 <code>rtl_sdr</code> 命令一样使用 I/Q 通道直采接收中短波信号，而此前 OpenWebRX 能实现是因为 Op 采用的是支持 I/Q 通道直采的 <code>rtl_sdr</code> 模块加 netcat 转发数据至 TCP 实现的……</p>
</blockquote>
<p>转发数据确实是一条新的思路，但是操作起来却有些麻烦：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@yukiho:~# rtl_sdr -D2 -s 1024000 -f 9500000 -p 0 -g 0 -| nmux --bufsize 253952 --bufcnt 379 --port 1234 --address 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>此外，由于引入了新的工具 netcat 做数据转发，所以负载也跟着上去了，对于博主的垃圾 Orange Pi Lite 来说简直就是灭顶之灾……</p>
<p>还有更好的方法吗？</p>
<span id="more"></span>

<p>事实上还是有的，通过修改 RTL-SDR 的源码就可以实现 rtl_tcp 支持从 I/Q 通道直采信号。一位国外 HAM SP5TOF 针对 rtl_tcp 模块做了修改，原文是 <span class="exturl" data-url="aHR0cDovL2ludGVsaWdlbnRueS1kb20udnhtLnBsL3NwNXRvZi8/cGFnZV9pZD00MDQ=">Direct Sampling Mode in 820T2 DVB-T on Linux os - SP5TOF - amateur radio station<i class="fa fa-external-link-alt"></i></span>。</p>
<p>经过整理后，博主将修改后的 RTL-SDR 驱动上传到了 GitHub……</p>
<h2 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h2><p>事实上，要对 RTL-SDR 进行一次重新编译。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@yukiho:/home# git clone https://github.com/bclswl0827/rtl-sdr.git</span><br><span class="line">root@yukiho:/home# cd rtl-sdr</span><br><span class="line">root@yukiho:/home/rtl-sdr# mkdir build</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# cd build</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# cmake ../ -DINSTALL_UDEV_RULES</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# make</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# make install</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# ldconfig</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# bash -c &#x27;echo -e &quot;\n# for RTL-SDR:\nblacklist dvb_usb_rtl28xxu\n&quot; &gt;&gt; /etc/modprobe.d/blacklist.conf&#x27;</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# update-initramfs -u</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# rmmod dvb_usb_rtl28xxu</span><br><span class="line">root@yukiho:/home/rtl-sdr/build# reboot</span><br></pre></td></tr></table></figure>

<p>重启系统。</p>
<p>现在，<code>rtl_tcp</code> 就可以直接采集来自 I/Q 通道的中短波信号惹～</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@yukiho:~# rtl_tcp rtl_tcp -a 127.0.0.1 -s 1024000 -g 0 -d 0 -p 1234 -i 2</span><br></pre></td></tr></table></figure>

<p>其中，<code>-i 2</code> 意为使用 Q 通道，TCP 端口为 <code>:1234</code>，在 <code>localhost</code> 下监听。</p>
<p>将配置写入 WebSDR 的配置文件 websdr.cfg，然后运行 WebSDR。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...内容保持不变...</span><br><span class="line">band 31 M</span><br><span class="line">device !rtlsdr 127.0.0.1:1234 0</span><br><span class="line">samplerate 1024000</span><br><span class="line">allowwide</span><br><span class="line">centerfreq 9500</span><br><span class="line">initial 9750 am</span><br><span class="line">antenna 20 Metres Wire</span><br><span class="line">gain 0</span><br><span class="line">...内容保持不变...</span><br></pre></td></tr></table></figure>

<p>频谱瀑布正常显示，即正常运行，完结撒花。</p>
]]></content>
      <categories>
        <category>广播</category>
      </categories>
      <tags>
        <tag>广播</tag>
        <tag>原创</tag>
        <tag>SDR</tag>
        <tag>瞎搞</tag>
      </tags>
  </entry>
  <entry>
    <title>吃灰开发板拿出来，咱们来听听地球吧</title>
    <url>/Earthquake-Sensor_20231009/</url>
    <content><![CDATA[<p><strong>本项目已更名 AnyShake Project，并由博主继续维护。AnyShake Project 网站及文档位于 <span class="exturl" data-url="aHR0cHM6Ly9hbnlzaGFrZS5vcmcv">anyshake.org<i class="fa fa-external-link-alt"></i></span>，GitHub 主页位于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtl">github.com/anyshake<i class="fa fa-external-link-alt"></i></span></strong></p>
<p><strong>由于本文写在项目有起色之初，部分内容可能已经过期或不适用，因此一切请以 AnyShake Project 官网文档给出的内容为准</strong></p>
<p>博主在今年（2023 年）上半年在带领实验室其他成员报名「全国大学生嵌入式芯片与系统设计竞赛」时，在项目选题时却犹豫不止，大多数人都是选择在「智能小车」、「智能机器人」及其相关的项目上下功夫，而博主却想做点不一样的。</p>
<p>在报名截止的前夕，博主突然想起博主的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Rlbmt5dUNoaW1hdGE=">一位朋友曾经给博主提到他买过一台名叫 Raspberry Shake 的地震仪<i class="fa fa-external-link-alt"></i></span>，这台地震仪可以将地震波数据整合或上传到云端，供用户调阅查看，而且<span class="exturl" data-url="aHR0cHM6Ly9saXZlLmJpbGliaWxpLmNvbS8yMjg2Mzc5MA==">他也长期在 Bilibili 上直播地震仪测到的实时数据<i class="fa fa-external-link-alt"></i></span>，在看过他的直播后，博主立刻被这台地震仪所吸引住了。</p>
<p>最后，博主决定用比赛方提供的龙芯开发板，造一台自己的地震仪，但由于 Raspberry Shake 不开源核心代码，所以博主只能自己动手，一切从零开始。</p>
<p>在历经 3 个多月紧张的开发后，博主终于实现了这套系统的基本功能，并一举挺进了全国总决赛，最终拿下了全国一等奖的好成绩。</p>
<p>在获得佳绩后，博主也决定将这一整套系统开源到 GitHub 上，并继续加以维护，<strong>毕竟博主并不是地球物理学专业的学生，所以博主也希望能有更多的专业人士能够参与到这个项目中来，从而使这个项目能够更加完善</strong>。</p>
<p>先晒出几张博主测到的地震波数据图，数据均来自博主设立在重庆北碚区的自研地震仪，由博主的那位朋友托管。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/1.png" alt="CST 2023-07-23 09:00:27 内江威远 M3.3"></p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/2.png" alt="CST 2023-08-10 17:02:47 雅安石棉 M3.4"></p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/3.png" alt="CST 2023-08-29 03:55:32 印尼巴厘海 M7.1"></p>
<span id="more"></span>

<h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p>先贴出博主的项目总体架构图，其中，博主将下位机称作 Explorer，上位机称作 Observer。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/4.svg" alt="项目总体架构图"></p>
<p>下位机中，用于监测地震的传感器是三个速度型地震检波器，自然频率为 4.5 Hz，灵敏度 0.288 V/cm/s。这三个检波器又由两个<strong>水平地震检波器</strong>和一个<strong>垂直地震检波器</strong>组成，负责采集由三个方向（东西、南北、垂直）收集而来的电压数据，并将数据打包传送到上位机进行进一步处理。</p>
<p>上位机部分，在后端软件收到来自下位机的数据后，程序会先对数据做校验，若校验通过，则将数据送入一个缓冲区。与此同时，另外一个协程则负责将缓冲区的数据按秒组装成一帧完整的数据包，并打上精确时标，然后透过零极点配置补偿法对低频做补偿，再将数据包派发给各个模块的订阅者（如 PostgreSQL 存储队列、前端 WebSocket、MiniSEED 存档模块），最后各个模块再根据自己的需求对数据进行处理。</p>
<p>上下位机通信方面，博主使用了串口通信。通信所使用的波特率和各通道的数据包长由用户事先在双方的配置文件中指定好。由于下位机中还涉及到 ADC 采样率的配置，所以可以透过这三个变量，灵活地组合出各种实际采样率。</p>
<p>另外，下位机通常需要摆放在安静的地方，由于博主的上下位机距离较远，所以最后用到了 LoRa 无线模块做透传，实现了无线通信。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/5.jpg" alt="LoRa 模块"></p>
<p>需要注意的是，<strong>由于 LoRa 模块在一定时间内有数据包传输大小的限制，所以只能将通道数据包的长度尽量调小，同时合理增大 ADC 的采样率，采用「小包快发」的方式，在保证数据完整性的前提下，尽可能地提高数据传输效率</strong>。</p>
<p>经过博主实测，使用 LoRa 模块且波特率为 19200 时，这种方案能够达到 90 Sps 的实际采样率，已经满足地震监测的需求（即满足 Nyquist Frequency）。</p>
<p>下图是博主在学校校内设立的站点，使用太阳能供电，无需外接电源，并可长期运行，下位机数据便是透过 LoRa 无线模块传输到上位机的。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/6.jpg" alt="校内测站"></p>
<p><strong>除了使用 LoRa 模块，如果只是近距离的无线通信，则可以使用一些便宜的蓝牙模块，如 JDY-31（前提是上位机也要支援蓝牙，若不支援可以用 USB 蓝牙模块），这种模块的通信距离在 10 M 左右</strong>，当波特率为 115200 时，透过合理配置包长和 ADC 采样率，也能达到 100 Sps 的实际采样率。</p>
<p>蓝牙模块修改波特率一般可以使用 AT 命令，至于具体操作，可以参考<span class="exturl" data-url="aHR0cHM6Ly9tYW51YWxzLnBsdXMvemgtVFcvdHJhbnNtaXNzaW9uLW1vZHVsZS9ibHVldG9vdGgtc3BwLXNlcmlhbC1wb3J0LXRyYW5zcGFyZW50LXRyYW5zbWlzc2lvbi1tb2R1bGUtbWFudWFs">这份手册<i class="fa fa-external-link-alt"></i></span>。</p>
<h1 id="下位机"><a href="#下位机" class="headerlink" title="下位机"></a>下位机</h1><p>项目下位机使用 C++ 编写，在时下流行的 PlatformIO IDE 上进行开发，下位机的代码仓库地址如下：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL2V4cGxvcmVy">GitHub - anyshake/explorer<i class="fa fa-external-link-alt"></i></span></p>
<p>下位机默认运行的平台为 STM32F103C8T6 核心板，但是透过修改 <code>platformio.ini</code> 文件和少许引脚定义（ADC 的 RST 和 DRDY 引脚定义），即可轻易在其他开发板上运行。</p>
<p>在项目刚起步时，博主使用的 ADC 是 16 位的 ADS1115，但是在后来的实际测试中，博主发现 ADS1115 的采样速度和数据精度均无法满足项目需求。而在一番调研后，博主又发现用于地震领域的 ADC 实在太贵，最后只能退而求其次，选择了 24 位的 ADS1256，经过实测，这款 ADC 除了稳定性比较堪忧外，其他方面能勉强满足项目需求，而且价格也比较亲民。</p>
<p>ADS1256 的驱动代码由博主自行编写（读 Datasheet 是一件很痛苦的事情，驱动写完人已经麻了），位于 <code>src/ads1256</code> 目录下。由于 ADS1256 在运行过程中容易受到干扰，导致部分配置寄存器值发生变化，所以博主在代码中加入了一些校验机制，在检测到发生错误时，程序自动进行复位，从而保证数据的准确性。然而这又导致了一个新的问题，那就是每轮采集前都会对配置寄存器做校验，这会消耗不少时间，所以实际采样率也会跟着下降，不过采样率依然能够满足项目需求，所以也就忽略不计了。</p>
<p>下面是博主另外制作的一套下位机成品，使用了蓝牙通信，<strong>其中垂直通道（EHZ）、东西通道（EHE）和南北通道（EHN）以差分形式输入 ADC</strong>。</p>
<table>
<thead>
<tr>
<th align="center">通道名称</th>
<th align="center">差分输入口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EHZ</td>
<td align="center">AIN3、AIN4</td>
</tr>
<tr>
<td align="center">EhE</td>
<td align="center">AIN5、AIN6</td>
</tr>
<tr>
<td align="center">EhN</td>
<td align="center">AIN7、AIN8</td>
</tr>
</tbody></table>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/7.jpg" alt="下位机成品"></p>
<p>配置好下位机参数，刷写好下位机固件并启动设备后，若要透过蓝牙与其建立串口连接，Linux 下可以使用 <code>hcitool</code> 和 <code>rfcomm</code> 命令。</p>
<p>先扫描设备，获取蓝牙设备的 MAC 地址（以 00:00:00:00:00:00 为例）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yuki@yuki-pc:~$ hcitool scan</span><br><span class="line">Scanning ...</span><br><span class="line">        00:00:00:00:00:00       JDY-31-SPP</span><br></pre></td></tr></table></figure>

<p>随即建立串口连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yuki@yuki-pc:~$ sudo rfcomm connect 0 00:00:00:00:00:00</span><br><span class="line">Connected /dev/rfcomm0 to 00:00:00:00:00:00 on channel 1</span><br><span class="line">Press CTRL-C for hangup</span><br></pre></td></tr></table></figure>

<p>不出意外，可以在 <code>/dev</code> 目录下看到多出了一个名为 <code>rfcomm0</code> 的设备，这个设备就是蓝牙串口设备，可以像使用普通串口设备一样使用它。</p>
<h1 id="上位机"><a href="#上位机" class="headerlink" title="上位机"></a>上位机</h1><p>项目上位机使用 B/S 架构，后端使用 Golang + Gin 编写，前端则使用 TypeScript + React + TailwindCSS，代码仓库地址如下：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL29ic2VydmVy">GitHub - anyshake/observer<i class="fa fa-external-link-alt"></i></span></p>
<p>博主已经为这个项目启用了 GitHub Actions，每次有新的提交时，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL29ic2VydmVyL3JlbGVhc2Vz">GitHub 都会自动构建最新的 Release 版本<i class="fa fa-external-link-alt"></i></span>，从而便于一般用户直接下载最新的预编译的版本。预编译提供包含 Linux 下 x86_64、arm64 和 armv7l 三种架构的二进制文件，以及 Windows 下 x86 和 x86_64 两种架构的二进制文件，用户可以根据自己的场景和需求选用。</p>
<p>若要启用历史数据查询功能，在使用上位机前，上位机需要预装 PostgreSQL 数据库（也可以安装在其他服务器远程连接），安装好 PostgreSQL 数据库后，创建一个空白的库，这里以 <code>observer</code> 为库名，用户名以 <code>postgres</code>，密码以 <code>passw0rd</code> 为例。</p>
<p>接下来配置上位机参数，这些参数均位于 <code>config.json</code> 文件中，在用户下载的 Release 预编译版本中，也已经附上了这个文件，用户只需稍加修改其中的参数即可，下面是这些参数字段的介绍。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;station_settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;uuid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a373e39c-8e15-44ae-a1ad-6fb622bc49e6&quot;</span><span class="punctuation">,</span> <span class="comment">// 测站 UUID，自行生成，用于标识站点</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Test Station&quot;</span><span class="punctuation">,</span> <span class="comment">// 测站名字，会显示在测站前端</span></span><br><span class="line">        <span class="attr">&quot;latitude&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="comment">// 测站纬度</span></span><br><span class="line">        <span class="attr">&quot;longitude&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="comment">// 测站经度</span></span><br><span class="line">        <span class="attr">&quot;altitude&quot;</span><span class="punctuation">:</span> <span class="number">0</span> <span class="comment">// 测站海拔</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 测站基础配置</span></span><br><span class="line">    <span class="attr">&quot;geophone_settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ehz&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sensitivity&quot;</span><span class="punctuation">:</span> <span class="number">0.288</span><span class="punctuation">,</span> <span class="comment">// EHZ 检波器灵敏度，单位 V/cm/s</span></span><br><span class="line">            <span class="attr">&quot;damping&quot;</span><span class="punctuation">:</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="comment">// EHZ 检波器阻尼</span></span><br><span class="line">            <span class="attr">&quot;frequency&quot;</span><span class="punctuation">:</span> <span class="number">4.5</span><span class="punctuation">,</span> <span class="comment">// EHZ 检波器自然频率</span></span><br><span class="line">            <span class="attr">&quot;compensation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// EHZ 是否开启低频补偿</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// EHZ 通道配置</span></span><br><span class="line">        <span class="attr">&quot;ehe&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sensitivity&quot;</span><span class="punctuation">:</span> <span class="number">0.288</span><span class="punctuation">,</span> <span class="comment">// EHE 检波器灵敏度，单位 V/cm/s</span></span><br><span class="line">            <span class="attr">&quot;damping&quot;</span><span class="punctuation">:</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="comment">// EHE 检波器阻尼</span></span><br><span class="line">            <span class="attr">&quot;frequency&quot;</span><span class="punctuation">:</span> <span class="number">4.5</span><span class="punctuation">,</span> <span class="comment">// EHE 检波器自然频率</span></span><br><span class="line">            <span class="attr">&quot;compensation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// EHE 是否开启低频补偿</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// EHE 通道配置</span></span><br><span class="line">        <span class="attr">&quot;ehn&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;sensitivity&quot;</span><span class="punctuation">:</span> <span class="number">0.288</span><span class="punctuation">,</span> <span class="comment">// EHN 检波器灵敏度，单位 V/cm/s</span></span><br><span class="line">            <span class="attr">&quot;damping&quot;</span><span class="punctuation">:</span> <span class="number">0.6</span><span class="punctuation">,</span> <span class="comment">// EHN 检波器阻尼</span></span><br><span class="line">            <span class="attr">&quot;frequency&quot;</span><span class="punctuation">:</span> <span class="number">4.5</span><span class="punctuation">,</span> <span class="comment">// EHN 检波器自然频率</span></span><br><span class="line">            <span class="attr">&quot;compensation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// EHN 是否开启低频补偿</span></span><br><span class="line">        <span class="punctuation">&#125;</span> <span class="comment">// EHN 通道配置</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;adc_settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resolution&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span> <span class="comment">// 下位机 ADC 位深</span></span><br><span class="line">        <span class="attr">&quot;fullscale&quot;</span><span class="punctuation">:</span> <span class="number">5.0</span> <span class="comment">// 下位机 ADC 满量程，单位 V</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 下位机 ADC 参数配置</span></span><br><span class="line">    <span class="attr">&quot;serial_settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;packet&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="comment">// 下位机通道数据包长，对应下位机配置字段 PACKET_SIZE</span></span><br><span class="line">        <span class="attr">&quot;baud&quot;</span><span class="punctuation">:</span> <span class="number">19200</span><span class="punctuation">,</span> <span class="comment">// 下位机波特率，对应下位机配置字段 SERIAL_BAUD</span></span><br><span class="line">        <span class="attr">&quot;device&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/ttyUSB0&quot;</span> <span class="comment">// 下位机串口设备，根据实际情况修改</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 串口通信参数配置</span></span><br><span class="line">    <span class="attr">&quot;ntpclient_settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.pool.ntp.org&quot;</span><span class="punctuation">,</span> <span class="comment">// NTP 服务器地址</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">123</span><span class="punctuation">,</span> <span class="comment">// NTP 服务器端口</span></span><br><span class="line">        <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="comment">// NTP 请求超时时间，单位秒</span></span><br><span class="line">        <span class="attr">&quot;interval&quot;</span><span class="punctuation">:</span> <span class="number">5</span> <span class="comment">// NTP 请求间隔，单位秒</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// NTP 客户端参数配置</span></span><br><span class="line">    <span class="attr">&quot;archiver_settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 是否开启 PostgreSQL 存档，若关闭，前端将无法查看历史数据</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span> <span class="comment">// PostgreSQL 存档服务器地址</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">5432</span><span class="punctuation">,</span> <span class="comment">// PostgreSQL 存档服务器端口 </span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;postgres&quot;</span><span class="punctuation">,</span> <span class="comment">// PostgreSQL 用户名</span></span><br><span class="line">        <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;passw0rd&quot;</span><span class="punctuation">,</span> <span class="comment">// PostgreSQL 密码</span></span><br><span class="line">        <span class="attr">&quot;database&quot;</span><span class="punctuation">:</span> <span class="string">&quot;observer&quot;</span> <span class="comment">// PostgreSQL 数据库名</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// MiniSEED 存档参数配置</span></span><br><span class="line">    <span class="attr">&quot;server_settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 上位机前端服务器地址</span></span><br><span class="line">        <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">8073</span><span class="punctuation">,</span> <span class="comment">// 上位机前端服务器端口</span></span><br><span class="line">        <span class="attr">&quot;cors&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// API 是否允许跨域访问</span></span><br><span class="line">        <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="comment">// 是否开启调试模式，正式部署时关闭</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 上位机前端服务器参数配置</span></span><br><span class="line">    <span class="attr">&quot;miniseed_settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 是否开启 MiniSEED 存档，若要启用 SeedLink 服务，则必须开启</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/data/miniseed&quot;</span><span class="punctuation">,</span> <span class="comment">// MiniSEED 存档路径</span></span><br><span class="line">        <span class="attr">&quot;station&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEST&quot;</span><span class="punctuation">,</span> <span class="comment">// MiniSEED 测站名</span></span><br><span class="line">        <span class="attr">&quot;network&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XX&quot;</span><span class="punctuation">,</span> <span class="comment">// MiniSEED 网络名</span></span><br><span class="line">        <span class="attr">&quot;lifecycle&quot;</span><span class="punctuation">:</span> <span class="number">10</span> <span class="comment">// MiniSEED 存档周期，单位天</span></span><br><span class="line">    <span class="punctuation">&#125;</span> <span class="comment">// MiniSEED 存档参数配置</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>若要开启 SeedLink 服务，需要从源码安装 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VhcnRoU2NvcGUvcmluZ3NlcnZlcg==">RingServer<i class="fa fa-external-link-alt"></i></span>，然后在配置文件的 <code>miniseed_settings</code> 字段中将 <code>enable</code> 字段修改为 <code>true</code>，最后参考 <span class="exturl" data-url="aHR0cHM6Ly9zZWlzY29kZS5pcmlzLndhc2hpbmd0b24uZWR1L3Byb2plY3RzL3JpbmdzZXJ2ZXIvd2lraS9Ib3dfdG9fY29uZmlndXJlX3JpbmdzZXJ2ZXJfYXNfYV9TZWVkTGlua19zdHJlYW1pbmdfc2VydmVy">这篇教程<i class="fa fa-external-link-alt"></i></span> 配置好 RingServer，启动后 5 分钟左右即可在 Swarm、SeisComP3 等软件中连接到 SeedLink 服务并查看地震波数据。</p>
<p>还需要注意的是 ADC 配置字段，若下位机开启了一倍以上的 PGA（对应下位机配置字段 <code>GAIN_RATE</code>），则需要对该字段进行修改，将 <code>5</code> 改为实际满量程。以 ADS1256 为例，PGA 与满量程的对应关系如下：</p>
<table>
<thead>
<tr>
<th align="center">PGA</th>
<th align="center">满量程（V）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2.5</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1.25</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">0.625</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">0.3125</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">0.15625</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">0.078125</td>
</tr>
</tbody></table>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>前端首页主要展示当前测站的状况，包含测站名、测站位置、在线时长、解码数量，丢包数量，与标准时间偏移量，CPU 及内存占用率。其中，「已推送讯息量」、「推送失败讯息量」、「等待推送讯息量」是为以后的中心服务器做准备的，目前还没有实际用途。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/8.jpg" alt="前端首页"></p>
<p>波形页面主要展示当前测站的波形图，包含三个通道的波形图，用户可以用拖拽的方式对任意通道的数据进行缩放，在波形图表下方有，还有实时计算的 PGA、PGV 数据、震度数据，另外，震度标准可以自行切换，目前默认为 JMA 标准。</p>
<p>在页面接近顶部的位置，有实时计算得出的下位机采样率，用户在调整下位机采样率时，可以透过这个数据来判断是否达到了预期的采样率。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/9.jpg" alt="前端波形"></p>
<p>若用户在配置文件开启了数据库存档功能，则可以在历史页面查看历史数据，<strong>目前查询方式有两种，一种是按时间段查询，另一种是按地震事件查询</strong>，用户可以根据自己的需求来选择。</p>
<p>第一种方式，用户可以点击页面上的起始和结束时间选择器，来选择自己想要查询的时间段，再点击「调阅波形」按钮，即可查询到该时间段内的所有数据。</p>
<p>第二种方式，用户可以点击「地震反查」按钮，选择一个地震数据来源，然后选择要查询的地震事件，即可将时间段自动填入时间选择器中，用户只需要再点击「调阅波形」按钮即可查询到该地震事件的所有数据。</p>
<p>由于前端只是简单地显示了波形，若要对地震事件的频谱进行分析，可以点击「数据下载」按钮，选择要导出的通道名称，即可将数据导出为 SAC 格式，进而使用相关软件（如 Swarm）进行分析。</p>
<p>若要将地震事件分享给其他人，可以点击「分享」按钮，然后将弹出的链接分享给其他人，其他人打开链接后，起始和结束时间选择器中的时间段将会自动填充为该地震事件的时间段，其他人只需要点击「查询」按钮即可查询到该地震事件的所有数据。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/10.jpg" alt="前端历史"></p>
<p>若用户在配置文件开启了 MiniSEED 存档功能，则可以在数据下载页面导出以天为单位的 MiniSEED 格式的数据。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/11.jpg" alt="前端导出"></p>
<p>最后是启用 SeedLink 后的效果，用户可以在 Swarm 中直接连接 SeedLink 服务，从而实时查看地震波数据（波形 + 频谱）。</p>
<p><img data-src="https://c.ibcl.us/Earthquake-Sensor_20231009/12.jpg" alt="SeedLink"></p>
<h1 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h1><ul>
<li><input disabled="" type="checkbox"> 现在还缺少一个中心服务器，用于接收各个测站的数据，并像 Raspberry Shake 那样，提供一个地震波数据的查询平台</li>
<li><input disabled="" type="checkbox"> 由于博主不是地球物理学专业的学生，所以对于地震波的处理还不是很熟悉，目前的地震波数据处理算法还有待改进</li>
<li><input disabled="" type="checkbox"> 震度计算算法还有待改进，目前只是简单地使用了 PGA、PGV 算出了震度，但是这种算法并不准确</li>
<li><input disabled="" type="checkbox"> 需要用 Go 重新实现 SeedLink 协议，提升系统的可移植性，降低部署成本和难度</li>
<li><input disabled="" type="checkbox"> 下位机的硬件亟待集成化，目前还是一块核心板加上一堆杂七杂八的模块，不够美观</li>
<li><input disabled="" type="checkbox"> 目前项目的低频补偿算法及滤波器非常不完善，需要进一步改进</li>
<li><input disabled="" type="checkbox"> 目前项目的前端只是简单地展示了波形，希望后续加上频谱功能</li>
<li><input disabled="" type="checkbox"> 项目的成本还是有点高，希望能够进一步降低成本</li>
<li><input disabled="" type="checkbox"> 下位机 ADC 稳定性不高，需要进一步改进</li>
</ul>
<h1 id="总体成本"><a href="#总体成本" class="headerlink" title="总体成本"></a>总体成本</h1><p>以蓝牙通信的下位机为例，不计入吃灰开发板的成本，单独一套地震站的成本大概在 400 多 CNY，下面是博主的采购清单。</p>
<table>
<thead>
<tr>
<th align="center">项目名称</th>
<th align="center">数量</th>
<th align="center">单价（元）</th>
<th align="center">总价（元）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LGT-4.5 垂直检波器</td>
<td align="center">1</td>
<td align="center">100</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">LGT-4.5H 水平检波器</td>
<td align="center">2</td>
<td align="center">100</td>
<td align="center">200</td>
</tr>
<tr>
<td align="center">康威电子 ADS1256 模块</td>
<td align="center">1</td>
<td align="center">100</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">STM32F103C8T6 核心板</td>
<td align="center">1</td>
<td align="center">15</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">USB 蓝牙驱动器（酌情）</td>
<td align="center">1</td>
<td align="center">15</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">JDY-31-SPP 蓝牙模块</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
</tbody></table>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p>再贴一次项目地址，欢迎大家 Star 和 Fork，同时，项目的使用说明及二次开发文档也将在近期发布，敬请期待。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL2V4cGxvcmVy">GitHub - anyshake/explorer<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL29ic2VydmVy">GitHub - anyshake/observer<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>2023 年 12 月 18 日更新：项目文档已经开源至 <span class="exturl" data-url="aHR0cHM6Ly9hbnlzaGFrZS5vcmcv">anyshake.org<i class="fa fa-external-link-alt"></i></span> 了</p>
]]></content>
      <categories>
        <category>地震</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>硬件</tag>
        <tag>Golang</tag>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>C / C++</tag>
        <tag>串口</tag>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>偷窥狂养成记：成本 50 块的 GSM 网络嗅探经历</title>
    <url>/GSM-Sniffing_20200826/</url>
    <content><![CDATA[<ul>
<li><em>本文内容仅供参考、学习之用。</em></li>
<li><em>在阅读本文之前，请详细了解相关法律，若因读者对本文内容进行模仿而造成的一切负面影响及后果，<a href="https://ibcl.us/">“I BCL.”</a>一概对其不负责。</em></li>
<li><em>本文内容应情节需求系完全虚构，如有雷同实属巧合。</em></li>
</ul>
<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>一个百无聊赖的午间，博主正躺在床上带着耳机听歌，昏昏欲睡之中，突然收到一条讯息。</p>
<p>冷气与睡意之间，被通知铃声吵醒是一件痛苦的事，但是博主还是打开了萤幕，原来是某位大佬发来的留言。</p>
<blockquote>
<p>大佬：最近忙啥呢？</p>
</blockquote>
<p>既然是大佬主动联系博主，一定是有什么有趣的事情。</p>
<blockquote>
<p>博主：表示现在很闲，大佬是有什么事？</p>
</blockquote>
<p>接着，大佬发来一个链接，对应的地址是一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3B0cmtyeXNpay9nci1nc20=">名为 gr-gsm 开源专案<i class="fa fa-external-link-alt"></i></span>。</p>
<blockquote>
<p>大佬：既然有时间，咱们来玩嗅探 GSM 怎么样？就用你的 RTL-SDR。</p>
</blockquote>
<blockquote>
<p>博主：蛤？</p>
</blockquote>
<p>博主从未想过，自己与成为一个能偷看他人简讯的偷窥狂，仅仅只有 50 块的距离……</p>
<p>这么有趣的体验，怎么能够拒绝？于是博主果断答应了大佬的邀请。</p>
<span id="more"></span>

<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><h2 id="裸奔的-GSM"><a href="#裸奔的-GSM" class="headerlink" title="裸奔的 GSM"></a>裸奔的 GSM</h2><p>由于各种原因，就算 4G LTE 早已普及，也仍然存在大量 GSM 流量。由于 GSM 信号在中国并未被加密，也就是说，只要有相应的设备，就能捕获到空中的 GSM 信号，轻易地在神不知鬼不觉间解码出一条条的简讯。</p>
<p>所以，即便是在 0202 年的今天，网上也仍然有着不少类似“卡还在，可是钱没了”的新闻。</p>
<p><img data-src="https://c.ibcl.us/GSM-Sniffing_20200826/1.jpg" alt="卡还在，可是钱没了 --P 民网" title="卡还在，可是钱没了 --P 民网"></p>
<p>而事实上，GSM 本身就是一种极不安全的协定，简单来说，其自身的缺陷可以归纳为如下 4 点。</p>
<ol>
<li>位置隐私有漏洞：电话在第一次接入网络或是换手（Handover）的情況下，若旧的 VLR（拜访网络）无法正常运作时，新的 VLR 可以要求电话送出 IMSI（用户识别码），以便向 HLR（归属网络）要求认证的资讯。这种情况会暴露电话的真实位置，无法满足隐私需求； </li>
<li>电话无法对 VLR 做认证：在通信协定中，我们总是希望能认证对方的身份，以防对方是假冒的，但目前的 GSM 只做到了 VLR 对电话的认证；</li>
<li>网络主机间不做认证：在 GSM 里，网络主机间是相互信赖的；</li>
<li>可以使用不加密通信：根据一些国家政府、法律、运营商政策的规定，GSM 可以不加密进行通信。</li>
</ol>
<p>对于那些利用伪基站进行攻击，然后截获用户简讯骗取钱财的攻击者来说，他们利用的则是上述漏洞的 2、4 点，即先利用干扰设备使被攻击者的电话网络降级到 2G，然后再利用网银等平台的<strong>简讯获取动态密码登入</strong>或是<strong>以简讯验证找回密码</strong>的功能，通过对 GSM 进行嗅探获取到实时验证码，然后登入被攻击者的账户，最后实现转出被攻击者的资金并跑路。</p>
<p>而在本文，博主则将利用上述漏洞的第 4 点，实现对简讯的嗅探，因为在中国，GSM 就是没有加密的。</p>
<h2 id="嗅探工具"><a href="#嗅探工具" class="headerlink" title="嗅探工具"></a>嗅探工具</h2><p>博主在之前的文章中有提到过不同型号的 RTL-SDR 所能接收的频率范围，所以在此不再赘述。此外，从网络上了解到，中国所使用的 GSM 频率中，GSM 850 和 GSM 900 是包含在大多数的 RTL-SDR 接收范围之内的，对应的频率分别是 850-900 MHz 和 900-999 MHz。其中，GSM 850 是上行数据，GSM 900 是下行数据。</p>
<p>由于上行数据并不好嗅探，所以为了方便起见，本文将以嗅探下行数据（GSM 900）做演示。</p>
<p>天线使用 RTL-SDR 随机所附的天线即可，除了 RTL-SDR 之外，还需要用到一台运行着 Linux 的主机，博主使用的是那台身经百战，运行着 Debian Buster 的斐讯 T1 盒子，事先安装了 LXDE 桌面。</p>
<p>扫描基站频率有多种方案，比如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09yb3M0Mi9JTVNJLWNhdGNoZXI=">IMSI-Catcher<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXZlLW0va2FsaWJyYXRlLXJ0bA==">kalibrate-rtl（用于 RTL-SDR）<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjYXRldS9rYWxpYnJhdGUtaGFja3Jm">kalibrate-hackrf（用于 HackRF）<i class="fa fa-external-link-alt"></i></span>。博主选用的是 kalibrate-rtl。</p>
<p>在扫描完基站频率过后，就要选择一个基站来进行嗅探了，嗅探的工具是 gr-gsm 的 <code>grgsm_livemon_headless</code> 模块。嗅探到的 GSM 流量是以数据流的形式传输的，所以还需要用到 Wireshark 来抓包，筛选出有用的资讯。</p>
<p><img data-src="https://c.ibcl.us/GSM-Sniffing_20200826/2.jpg" alt="全景图" title="全景图"></p>
<p>准备好了硬件，综合以上内容，嗅探 GSM 网络需要以下软件。</p>
<ul>
<li>librtlsdr</li>
<li>kalibrate-rtl</li>
<li>gr-gsm</li>
<li>wireshark</li>
</ul>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p>略去安装 LXDE、更换 APT 镜像源的步骤，由于一些软件需要从源码编译，所以需要准备对应的编译环境。</p>
<p>一并安装需要用到的依赖项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ sudo apt update</span><br><span class="line">yuki@meow:~$ sudo apt install -y cmake libusb-1.0-0-dev build-essential libtool \</span><br><span class="line">  automake autoconf libfftw3-dev pkg-config python-scipy python-docutils \</span><br><span class="line">  libosmocore-dev libboost-all-dev swig doxygen git \</span><br><span class="line">  gnuradio-dev gr-osmosdr libcppunit-dev liblog4cpp5-dev  </span><br></pre></td></tr></table></figure>

<h2 id="librtlsdr"><a href="#librtlsdr" class="headerlink" title="librtlsdr"></a>librtlsdr</h2><p>无论是 gr-gsm 的 <code>grgsm_livemon_headless</code> 模块还是 kalibrate-rtl 的 <code>kal</code> 命令，运行过程中都需要 RTL-SDR 对应的依赖库 librtlsdr 才能运行，而新版的 gr-gsm 需要较新的 librtlsdr 版本，否则会在编译时期报错。不幸的是，部分 Linux 发行版软件仓库中的 librtlsdr 版本过低，所以为了不给后面的操作留坑，从源码编译 librtlsdr 是最保险的做法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ git clone https://github.com/librtlsdr/librtlsdr librtlsdr</span><br><span class="line">yuki@meow:~$ mkdir -p librtlsdr/build</span><br><span class="line">yuki@meow:~$ cd librtlsdr/build</span><br><span class="line">yuki@meow:~/librtlsdr/build$ cmake ../ -DINSTALL_UDEV_RULES=ON -DDETACH_KERNEL_DRIVER=ON</span><br><span class="line">yuki@meow:~/librtlsdr/build$ make -j4</span><br><span class="line">yuki@meow:~/librtlsdr/build$ sudo make install</span><br><span class="line">yuki@meow:~/librtlsdr/build$ sudo ldconfig</span><br><span class="line">yuki@meow:~/librtlsdr/build$ cd ~</span><br></pre></td></tr></table></figure>

<h2 id="kalibrate-rtl"><a href="#kalibrate-rtl" class="headerlink" title="kalibrate-rtl"></a>kalibrate-rtl</h2><p>前面已经提到过，kalibrate-rtl 是扫描基站频率的一个工具，由于 Debian 软件仓库中并没有这个软件，所以需要从源码编译安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ git clone https://github.com/steve-m/kalibrate-rtl.git kalibrate-rtl</span><br><span class="line">yuki@meow:~$ cd kalibrate-rtl</span><br><span class="line">yuki@meow:~/kalibrate-rtl$ ./bootstrap</span><br><span class="line">yuki@meow:~/kalibrate-rtl$ ./configure</span><br><span class="line">yuki@meow:~/kalibrate-rtl$ make -j4</span><br><span class="line">yuki@meow:~/kalibrate-rtl$ sudo make install</span><br><span class="line">yuki@meow:~/kalibrate-rtl$ cd ~</span><br></pre></td></tr></table></figure>

<h2 id="gr-gsm"><a href="#gr-gsm" class="headerlink" title="gr-gsm"></a>gr-gsm</h2><p>gr-gsm 是本次嗅探 GSM 网络的主角。虽然一些 Linux 发行版已经将其加入了其测试版的软件仓库中，但是考虑到稳定性以及使用过程中可能会碰到一些玄学问题，从源码编译安装 gr-gsm 仍然是比较好的做法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ git clone https://github.com/ptrkrysik/gr-gsm.git gr-gsm</span><br><span class="line">yuki@meow:~$ mkdir -p gr-gsm/build</span><br><span class="line">yuki@meow:~$ cd gr-gsm/build</span><br><span class="line">yuki@meow:~/gr-gsm/build$ cmake ../</span><br><span class="line">yuki@meow:~/gr-gsm/build$ make -j4</span><br><span class="line">yuki@meow:~/gr-gsm/build$ sudo make install</span><br><span class="line">yuki@meow:~/gr-gsm/build$ sudo ldconfig</span><br><span class="line">yuki@meow:~/gr-gsm/build$ cd ~</span><br></pre></td></tr></table></figure>

<h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>需要注意的是，Wireshark 有着两个版本，一个使用较新的 Qt 编写，一个使用传统的 GTK+ 编写。Qt 编写的 Wireshark 包名是 <code>wireshark</code>，GTK+ 编写的 Wireshark 包名为 <code>wireshark-gtk</code>。</p>
<p>博主起初在安装 Wireshark 时选用是 Qt 编写的版本，但在安装完成后却发现无法运行，于是博主果断将其换成了 GTK+ 编写的 Wireshark。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ sudo apt install -y wireshark-gtk</span><br></pre></td></tr></table></figure>

<p>如果安装时出现类似 <code>Should non-superusers be able to capture packets?</code> 的对话框，使用 Tab 键选择“Yes”后回车即可。若不慎选错，可以在安装结束后使用 dpkg 再次设置，命令如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ sudo dpkg-reconfigure wireshark-common</span><br></pre></td></tr></table></figure>

<h1 id="开始搞事"><a href="#开始搞事" class="headerlink" title="开始搞事"></a>开始搞事</h1><p>搭建好了嗅探的环境，接下来将 RTL-SDR 插入 USB 口，检查主机是否能识别 RTL-SDR。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ lsusb</span><br><span class="line">Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line">Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub</span><br><span class="line">Bus 001 Device 002: ID 0bda:2838 Realtek Semiconductor Corp. RTL2838 DVB-T</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure>

<p>看到了 RTL2838 DVB-T 的字样，说明一切顺利。</p>
<p>那么，一切可以开始了。</p>
<h2 id="寻找基站频率"><a href="#寻找基站频率" class="headerlink" title="寻找基站频率"></a>寻找基站频率</h2><p>通过 <code>kal</code> 命令，指定 kalibrate-rtl 寻找 GSM 900 频段的基站，并将频率列印在终端上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ kal -s GSM900</span><br><span class="line">Found 1 device(s):</span><br><span class="line">  0:  Generic RTL2832U OEM</span><br><span class="line"></span><br><span class="line">Using device 0: Generic RTL2832U OEM</span><br><span class="line">Found Rafael Micro R820T tuner</span><br><span class="line">Exact sample rate is: 270833.002142 Hz</span><br><span class="line">[R82XX] PLL not locked!</span><br><span class="line">kal: Scanning for GSM-900 base stations.</span><br><span class="line">GSM-900:</span><br><span class="line">	chan: 19 (938.8MHz + 42.551kHz)	power: 50485.25</span><br><span class="line">	chan: 24 (939.8MHz + 42.361kHz)	power: 50187.10</span><br><span class="line">	chan: 30 (941.0MHz + 41.515kHz)	power: 145977.48</span><br></pre></td></tr></table></figure>

<p>由于博主的 RTL-SDR 没有温度补偿晶振（TXCO），所以偏频比较厉害，但是偏频仍然可以通过手动调节 PPM 来矫正。</p>
<p>由上面列印的数值可以得出，博主的垃圾 RTL-SDR 大概偏了 42 kHz，那么 PPM 值可以设置为 42。</p>
<p>再用 <code>kal</code> 命令加上 PPM 参数（-e）扫描一次，争取将偏移的频率控制在 2 kHz 以内，同时记下这个 PPM 值。如果偏移的频率仍然大于 2 kHz，则还需要重复上述操作，调整 PPM 值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ kal -s GSM900 -e 42</span><br><span class="line">Found 1 device(s):</span><br><span class="line">  0:  Generic RTL2832U OEM</span><br><span class="line"></span><br><span class="line">Using device 0: Generic RTL2832U OEM</span><br><span class="line">Found Rafael Micro R820T tuner</span><br><span class="line">Exact sample rate is: 270833.002142 Hz</span><br><span class="line">[R82XX] PLL not locked!</span><br><span class="line">kal: Scanning for GSM-900 base stations.</span><br><span class="line">GSM-900:</span><br><span class="line">	chan: 19 (938.8MHz + 1.521kHz)	power: 50485.25</span><br><span class="line">	chan: 24 (939.8MHz + 1.161kHz)	power: 50187.10</span><br><span class="line">	chan: 30 (941.0MHz + 0.515kHz)	power: 145977.48</span><br></pre></td></tr></table></figure>

<p>根据功率大小，选择一个频率并记下。博主选择的是 941.0 MHz。一般来说，基站功率越大，数据流越容易捕获。</p>
<h2 id="捕获数据流"><a href="#捕获数据流" class="headerlink" title="捕获数据流"></a>捕获数据流</h2><p>综合上面的信息，博主打算嗅探的频率是 941.0 MHz，RTL-SDR 的 PPM 为 42，启动 gr-gsm 时也要代入上述参数。</p>
<p>启动 <code>grgsm_livemon_headless</code> 过后，可以看到终端上在滚动的字符，这就是基站在传输的数据流。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ grgsm_livemon_headless -f 941.0M -p 42</span><br><span class="line">linux; GNU C++ version 7.3.0; Boost_106501; UHD_003.010.003.000-0-unknown</span><br><span class="line"></span><br><span class="line">gr-osmosdr 0.1.4 (0.1.4) gnuradio 3.7.11</span><br><span class="line">built-in source types: file osmosdr fcd rtl rtl_tcp uhd miri hackrf bladerf rfspace airspy airspyhf soapy redpitaya freesrp </span><br><span class="line">Opening nuand bladeRF with the device identifier string: &quot;*:instance=0&quot;</span><br><span class="line"> Serial # e2c2...7a95</span><br><span class="line"> FW v1.9.0 FPGA v0.5.0</span><br><span class="line">Failed ti set out of bound frequency: -399063</span><br><span class="line">Automatic DC correction mode is not implemented.</span><br><span class="line">[INFO @ bladerf.c:773] Clamping bandwidth to 1500000Hz</span><br><span class="line">Using Volk machine:avx_64_mmx</span><br><span class="line">gr::log :INFO controlport - Apache Thrift: -h debian -p 9090</span><br><span class="line"> 2d 06 3f 10 0f 20 4f 71 e1 f4 02 00 v1 af 11 ab 2b 2b 2b 2b 2b 2b 2b</span><br><span class="line"> 2d 06 3f 10 0f 20 4f 71 e1 f4 02 00 v1 af 11 ab 2b 2b 2b 2b 2b 2b 2b</span><br><span class="line"> 2d 06 3f 10 0f 20 4f 71 e1 f4 02 00 v1 af 11 ab 2b 2b 2b 2b 2b 2b 2b</span><br><span class="line"> 31 06 3f 00 79 30 25 08 e2 c1 01 01 0f 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b</span><br></pre></td></tr></table></figure>

<h2 id="成为一个偷窥狂"><a href="#成为一个偷窥狂" class="headerlink" title="成为一个偷窥狂"></a>成为一个偷窥狂</h2><p>gr-gsm 输出的数据流谁也看不懂，所以需要用到 Wireshark 对其进行解码，得到明文。</p>
<p><code>grgsm_livemon_headless</code> 除了直接将数据流输出到终端上，也会将的数据流转发到本地回环（lo）的端口，这样就能很轻易用 Wireshark 进行抓包。</p>
<p>另开一个终端，启动 Wireshark。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ wireshark-gtk -k -i lo -f &#x27;port 4729&#x27;</span><br></pre></td></tr></table></figure>

<p>在启动 Wireshark 时，博主遇到了一些报错，但是经过实践后，博主发现这些报错并不会对解码造成影响。</p>
<p>由于基站输出的数据并不全是简讯，所以还需要通过 Wireshark 的筛选功能，将无用的资讯排除掉，只留下简讯。</p>
<p>在 Wireshark 左上角 Filter 一栏输入 <code>gsm_sms</code> 即可使 Wireshark 仅输出简讯。</p>
<p>等待了大约 15 分钟过后，博主终于看到了一条广告。</p>
<blockquote>
<p>【智享”全千兆”】本月必追：《夏日冲浪店》开门营业花式百出，爱奇艺全网独播；《这！就是街舞》第三季燃爆舞台，优酷全网独播；哔哩哔哩《星<br>际迷航》电影13部全系列上线，一键追剧。戳链接 <span class="exturl" data-url="aHR0cHM6Ly9keC4xMDA4Ni5jbi9wcm9mc2R3cA==">https://dx.10086.cn/profsdwp<i class="fa fa-external-link-alt"></i></span> 立即抢购随心看会员 ，VIP<br>会员与15GB专属追剧流量月月享！</p>
</blockquote>
<p>事实上，由于当今使用简讯进行联系的人已经不多，所以博主嗅探到的四分之三的简讯都是来自运营商，银行的通知和各种广告。</p>
<p>可正当博主觉得玩腻了的时候，Wireshark 传来了这样一条简讯。</p>
<p><img data-src="https://c.ibcl.us/GSM-Sniffing_20200826/3.jpg" alt="沈大哥，我老公在家，不方便给你打电话。" title="沈大哥，我老公在家，不方便给你打电话。"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>正值七夕，博主不间断地嗅探了一天一夜，最后拿到了上百条简讯，除了一大堆广告之外，其中也不乏有小情侣们互传的情话。</p>
<p><img data-src="https://c.ibcl.us/GSM-Sniffing_20200826/4.jpg" alt="简讯" title="简讯"></p>
<p>但在第二天，Wireshark 就再也不能嗅探到任何简讯了。</p>
<p>在检查了 <code>grgsm_livemon_headless</code> 输出的日志过后，博主发现了来自 RTL-SDR 的报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 15 06 21 00 01 f0 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b</span><br><span class="line"> 15 06 21 00 01 f0 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b</span><br><span class="line"> 15 06 21 00 01 f0 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b</span><br><span class="line"> 15 06 21 00 01 f0 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b 2b</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">cb transfer status: 5, canceling...</span><br><span class="line">rtlsdr_read_async returned with -5</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>就算是重新启动 <code>grgsm_livemon_headless</code> 也无济于事。博主怀疑问题出在硬件上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yuki@meow:~$ grgsm_livemon_headless -f 941.0M -p 42</span><br><span class="line">linux; GNU C++ version 7.3.0; Boost_106501; UHD_003.010.003.000-0-unknown</span><br><span class="line"></span><br><span class="line">gr-osmosdr 0.1.4 (0.1.4) gnuradio 3.7.11</span><br><span class="line">built-in source types: file osmosdr fcd rtl rtl_tcp uhd miri hackrf bladerf rfspace airspy airspyhf soapy redpitaya freesrp </span><br><span class="line">Using device #1 Generic RTL2832U OEM</span><br><span class="line">usb_open error -4</span><br><span class="line"></span><br><span class="line">FATAL: Failed to open rtlsdr device.</span><br><span class="line"></span><br><span class="line">Trying to fill up 1 missing channel(s) with null source(s).</span><br><span class="line">This is being done to prevent the application from crashing</span><br><span class="line">due to gnuradio bug #528.</span><br></pre></td></tr></table></figure>

<p>事实上，由于 RTL-SDR 工作时所需电流较大，如果长时间在供电不足的情况下运行，就可能造成 <code>cb transfer status: 5, canceling...</code> 的错误，不光是 RTL-SDR，很多 SDR 都是这样。</p>
<p>解决的方法也很简单，只需要将 RTL-SDR 接入带有外接电源的 USB Hub 即可。</p>
<h1 id="博主的防嗅探小课堂"><a href="#博主的防嗅探小课堂" class="headerlink" title="博主的防嗅探小课堂"></a>博主的防嗅探小课堂</h1><p>从博主的嗅探经历可以看出，虽然博主没有使用干扰设备对附近电话网络进行降级攻击、搭建伪基站等，但仅仅一个 RTL-SDR 亦可见其威力。通过 GSM 嗅探，能够使攻击者处于主动方，而使被攻击者则处于劣势。</p>
<p>同时，资讯安全在大多数人看来，似乎是只要自己不“作”，就不会“翻车”。其实不然，与一般行骗方式不同，受害人不需要点击链接，不需要转发验证码，更不需要主动将验证码之类的敏感资讯转发给任何人。这种攻击一般会选在深夜进行，这就导致了大部分被攻击者都是在早上起床后才发现网银等账户在凌晨被人盗用。</p>
<p>虽然面对这种绕过用户的攻击手段对于普通用户没有绝对有效的方法，如果做好以下防范措施，在一定程度上亦能够防止上述情况发生。</p>
<ol>
<li>睡前启用飞航模式：夜间睡前启用飞航模式，使电话不会连到伪基站，基站获取不到电话状态资讯，也就不会将验证码传送到电话，攻击者亦不能获取到电话号码和验证码简讯；</li>
<li>警惕收讯良好处降级至 2G 网络：由于上述攻击需要借助 2G 网络，故攻击者会先使用干扰设备让电话网络降级到 2G 以拦截通话、简讯和联网数据。所以如果电话在平时收讯良好处突然降级到 2G 网络，就需警惕附近是否有伪基站和 GSM 嗅探；</li>
<li>开通 VoLTE：VoLTE 能让通话和简讯优先使用 4G 网络，而非 2G 网络；</li>
<li>隔离电话卡：准备两张电话卡，一张用于日常使用，另一张专门用于注册各种网络平台，接收验证码简讯，在没有使用需求时，将这张卡禁用。</li>
</ol>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>在与大佬分享完这一切过后，博主陷入了沉思。</p>
<p>七夕节，怎么就没人给博主用简讯传情话？</p>
]]></content>
      <categories>
        <category>广播</category>
      </categories>
      <tags>
        <tag>广播</tag>
        <tag>原创</tag>
        <tag>SDR</tag>
        <tag>瞎搞</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGemini - 一款博主开发的山寨版 ChatGPT</title>
    <url>/Gemini-Client_20240206/</url>
    <content><![CDATA[<p>博主前些日子逛 V2EX 时，经常看到有人讨论各种 ChatGPT 的第三方客户端。作为一个月月被 ChatGPT-4 爆金币的人，自然对这些第三方客户端没有兴趣<del>（毕竟咱可是高贵的官方用户）</del>。直到 Google 发布了 Gemini 模型后，博主才想要体验一下这个 AI 模型到底有多厉害，于是在 GitHub 上搜索起了 Gemini 的第三方客户端。</p>
<p><img data-src="https://c.ibcl.us/Gemini-Client_20240206/1.png" alt="1"></p>
<p>好家伙，第一条结果的 <code>babaohuang/GeminiProChat</code> 居然有 3.5k 颗 Star，看来这个客户端还是挺受欢迎的，可顺着仓库给出的演示 URL 进去，结果却让博主大失所望。</p>
<p><img data-src="https://c.ibcl.us/Gemini-Client_20240206/2.png" alt="2"></p>
<p>这套客户端没有历史记录，发出去的消息也不能再编辑，<strong>另外 Gemini 很重要的识图功能居然也没有实现</strong>，这怎么能行？</p>
<p>鉴于以上种种不好的使用体验，因此博主最后决定自己开发一个山寨版的 ChatGPT 客户端，名字就叫 ChatGemini。</p>
<p>说干就干，博主花了 3 天时间，用 React + TypeScript + TailwindCSS 打造了出一款全新的，有如下功能的 Gemini 客户端，项目一经发布，截止博主写这篇文章时，已经收获了 470 颗 Star。</p>
<ul>
<li>适配移动端</li>
<li>支持多 API 密钥分流</li>
<li>操作逻辑同 ChatGPT</li>
<li>仿 ChatGPT 3.5 界面</li>
<li>支持多轮聊天对话</li>
<li>支持上传图片进行识别</li>
<li>逐字输出（SSE）回应</li>
<li>集成 PHP 版反向代理</li>
<li>自定义 Gemini API 地址</li>
<li>可启用站点通行码防止滥用</li>
<li>聊天内容导出（HTML 和 PDF）</li>
<li>对话内容保存在 IndexedDB 中</li>
<li>在 AI 回应中运行 Python 代码</li>
</ul>
<p><img data-src="https://c.ibcl.us/Gemini-Client_20240206/3.png" alt="3"></p>
<p>这篇文章并不打算将 README 中的内容再复述一遍，因此这里只会记录一些博主在开发过程中的细节。</p>
<span id="more"></span>

<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这是一个基于 Google Gemini 的网页客户端，对标 ChatGPT 3.5，使用逻辑同 ChatGPT 3.5 一致，同时支持在聊天中上传图片，自动调用 Gemini-Pro-Vision 模型进行识图。</p>
<p>这个项目还可自定义 Gemini API 服务器地址，用户可将本项目部署至支持 PHP 的服务器或虚拟主机上，或是自行配置 Nginx 反向代理，透过修改 Gemini API 路径，从而在中国大陆无障碍使用。</p>
<p>项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvQ2hhdEdlbWluaQ==">bclswl0827/ChatGemini<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="框架选型"><a href="#框架选型" class="headerlink" title="框架选型"></a>框架选型</h2><p>博主在看了其他几个第三方 ChatGPT 客户端的代码后，发现有的项目使用了 Next.js，但博主并不打算使用 SSR 方式，因此还是选择了 React + TypeScript 方案。选择 React 也是因为博主对 React 更熟悉，另外，React 也是目前最流行的前端框架之一。</p>
<p>另外，博主还使用了 TailwindCSS，这是一个 CSS 框架，它的特点是不需要写 CSS，只需要在 HTML 中使用类名即可，这样可以大大减少 CSS 的编写量，另外，这款框架也用在了博主的另外一个项目 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FueXNoYWtlL29ic2VydmVy">AnyShake Observer<i class="fa fa-external-link-alt"></i></span> 中。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>项目中有一些需要部署时配置的参数，比如 Gemini API Key、站点通行码等，这些参数都是通过配置文件进行管理的。博主将这些参数放在了 <code>.env</code> 文件中，这样在构建部署时，只需要修改这个文件即可。</p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="left">必填</th>
<th align="left">可选值</th>
<th align="left">默认值</th>
<th align="left">说明</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>REACT_APP_GEMINI_API_KEY</code></td>
<td align="left">是</td>
<td align="left"><code>string</code>|<code>string[]</code></td>
<td align="left">空</td>
<td align="left">填入 Gemini API 密钥，多个以 <code>|</code> 分隔</td>
<td align="left">存在多个密钥时，每次应用加载时随机选用一个</td>
</tr>
<tr>
<td align="center"><code>REACT_APP_GEMINI_API_URL</code></td>
<td align="left">否</td>
<td align="left"><code>string</code></td>
<td align="left">空</td>
<td align="left">自定义 Gemini API 地址，用于反向代理</td>
<td align="left">无</td>
</tr>
<tr>
<td align="center"><code>REACT_APP_GEMINI_API_SSE</code></td>
<td align="left">否</td>
<td align="left"><code>true</code>|<code>false</code></td>
<td align="left"><code>true</code></td>
<td align="left">是否逐字输出 Gemini 回应，即是否使能 SSE</td>
<td align="left">无</td>
</tr>
<tr>
<td align="center"><code>REACT_APP_TITLE_SITE</code></td>
<td align="left">否</td>
<td align="left"><code>string</code></td>
<td align="left"><code>ChatGemini</code></td>
<td align="left">站点标题，将显示在浏览器标签页上</td>
<td align="left">无</td>
</tr>
<tr>
<td align="center"><code>REACT_APP_TITLE_HEADER</code></td>
<td align="left">否</td>
<td align="left"><code>string</code></td>
<td align="left"><code>Gemini Pro</code></td>
<td align="left">应用标题，显示在应用侧边栏和头部</td>
<td align="left">无</td>
</tr>
<tr>
<td align="center"><code>REACT_APP_PASSCODE_MD5</code></td>
<td align="left">否</td>
<td align="left"><code>string</code>|<code>string[]</code></td>
<td align="left">空</td>
<td align="left">MD5 格式通行码，多个以 <code>|</code> 分隔</td>
<td align="left">存在多个通行码时，任意一个通过验证即可登入</td>
</tr>
</tbody></table>
<p>但是博主在后期对项目进行 Docker 打包时，才发现依赖 <code>.env</code> 文件进行应用配置并不是一个好的选择，因为对 <code>.env</code> 文件进行修改后，需要重新构建整个 React 应用才能生效。</p>
<p>而要临时解决这个问题，只能在每次应用启动时都执行 <code>npm run build</code> 命令，生成最新的版本，然后再启动 Nginx 服务。但是这样会导致镜像体积剧增，同时应用启动时间也会变长，并不利于应用的持续部署。博主当时的 <code>entrypoint.sh</code> 长下面这样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">if [ -z &quot;$&#123;REACT_APP_GEMINI_API_KEY&#125;&quot; ]; then</span><br><span class="line">    echo &quot;env REACT_APP_GEMINI_API_KEY is unset or set to the empty string&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; .env</span><br><span class="line">REACT_APP_TITLE_SITE=&quot;$&#123;REACT_APP_TITLE_SITE&#125;&quot;</span><br><span class="line">REACT_APP_TITLE_HEADER=&quot;$&#123;REACT_APP_TITLE_HEADER&#125;&quot;</span><br><span class="line">REACT_APP_GEMINI_API_SSE=&quot;$&#123;REACT_APP_GEMINI_API_SSE&#125;&quot;</span><br><span class="line">REACT_APP_GEMINI_API_KEY=&quot;$&#123;REACT_APP_GEMINI_API_KEY&#125;&quot;</span><br><span class="line">REACT_APP_GEMINI_API_URL=&quot;$&#123;REACT_APP_GEMINI_API_URL&#125;&quot;</span><br><span class="line">REACT_APP_PASSCODE_MD5=&quot;$&#123;REACT_APP_PASSCODE_MD5&#125;&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; /etc/nginx/http.d/default.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080 default_server;</span><br><span class="line">    listen [::]:8080 default_server;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /app/build;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">echo &quot;Nginx is starting...&quot;</span><br><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure>

<p>为了彻底解决这一系列问题，博主最后的解决方案是，若应用检测不到来自 <code>.env</code> 的配置，网页端上则在加载时请求 <code>/env.json</code> 读取配置。这样一来，透过多阶段构建（第一阶段构建 React 应用，第二阶段构建 Nginx 镜像），就能将配置文件和应用分离开来，缩小了镜像体积，也不再会每次启动容器时进行应用构建了。所以，博主优化后的 <code>entrypoint.sh</code> 最终长这样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">if [ -z &quot;$&#123;REACT_APP_GEMINI_API_KEY&#125;&quot; ]; then</span><br><span class="line">    echo &quot;env REACT_APP_GEMINI_API_KEY is unset or set to the empty string!&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Create Nginx config</span></span><br><span class="line">if [ &quot;x$&#123;REACT_APP_GEMINI_API_URL&#125;&quot; = &quot;x__use_nginx__&quot; ]; then</span><br><span class="line">    REACT_APP_GEMINI_API_URL=&quot;/api&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">tee /usr/share/nginx/html/env.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;REACT_APP_PASSCODE_MD5&quot;: &quot;$&#123;REACT_APP_PASSCODE_MD5&#125;&quot;,</span><br><span class="line">    &quot;REACT_APP_TITLE_SITE&quot;: &quot;$&#123;REACT_APP_TITLE_SITE&#125;&quot;,</span><br><span class="line">    &quot;REACT_APP_TITLE_HEADER&quot;: &quot;$&#123;REACT_APP_TITLE_HEADER&#125;&quot;,</span><br><span class="line">    &quot;REACT_APP_GEMINI_API_SSE&quot;: &quot;$&#123;REACT_APP_GEMINI_API_SSE&#125;&quot;,</span><br><span class="line">    &quot;REACT_APP_GEMINI_API_KEY&quot;: &quot;$&#123;REACT_APP_GEMINI_API_KEY&#125;&quot;,</span><br><span class="line">    &quot;REACT_APP_GEMINI_API_URL&quot;: &quot;$&#123;REACT_APP_GEMINI_API_URL&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">echo &quot;Nginx started.&quot;</span><br><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="逐字输出"><a href="#逐字输出" class="headerlink" title="逐字输出"></a>逐字输出</h2><p>ChatGPT 和 Gemini 的回应是逐字输出的，因此每次 AI 的回应都是一小部分，这样做的好处是能更好地模拟真实的聊天场景。</p>
<p>而支撑这个功能的技术，并非常见的 WebSocket，而是 SSE（Server-Sent Events），一种服务器推送技术，允许服务器向客户端主动推送事件，但和 WebSocket 不同之处在于，在 SSE 连接中，客户端不能向服务器推送数据。</p>
<p>在 ChatGemini 中，博主并未直接处理 SSE，而是使用了由 Google 提供的 SDK，这套 SDK 会自动处理 SSE，无需开发者自己去处理。</p>
<p>另外，Google Gemini 的逐字输出功能是可选的，因此 ChatGemini 也提供了一个配置项，用户可以选择是否启用逐字输出功能，而相关的处理函数中，如果检测到用户没有开启逐字输出功能，则会在前端模拟出逐字输出的效果。</p>
<p>需要注意的是，在为项目配置 Nginx 反向代理时，需要关闭 Nginx 的缓冲，否则会导致逐字输出功能失效。</p>
<p>所以，Nginx 反向代理配置文件长这样。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">86400s</span>;</span><br><span class="line">    <span class="attribute">proxy_cache</span> <span class="literal">off</span>; <span class="comment"># 注意关闭缓存</span></span><br><span class="line">    <span class="attribute">proxy_buffering</span> <span class="literal">off</span>; <span class="comment"># 注意关闭缓冲</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> https://generativelanguage.googleapis.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>博主编写 PHP 版本的反向代理中，PHP 的缓冲也是关闭的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">setRuntimeBuffer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">ob_end_clean</span>();</span><br><span class="line">    <span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">ob_implicit_flush</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，若在 PHP 中处理逐字输出，需要使用 PHP cURL 中的 <code>CURLOPT_WRITEFUNCTION</code> 选项，这个选项允许用户自定义一个回调函数，回调函数会在每次接收到数据时被调用，而在回调函数中，数据则会实时再转发给用户。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$this</span>-&gt;curlObject, CURLOPT_RETURNTRANSFER, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$this</span>-&gt;curlObject, CURLOPT_TCP_KEEPALIVE, <span class="number">5</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$this</span>-&gt;curlObject, CURLOPT_TCP_KEEPIDLE, <span class="number">5</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$this</span>-&gt;curlObject, CURLOPT_TCP_KEEPINTVL, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">setRuntimeBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$isHeaderEnd</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$this</span>-&gt;curlObject, CURLOPT_WRITEFUNCTION, function (<span class="variable">$ch</span>, <span class="variable">$data</span>) <span class="keyword">use</span> (&amp;$<span class="title">isHeaderEnd</span>) &#123;</span><br><span class="line">    <span class="title">if</span> ($<span class="title">data</span> === &quot;\<span class="title">r</span>\<span class="title">n</span>&quot; &amp;&amp; !$<span class="title">isHeaderEnd</span>) &#123;</span><br><span class="line">        $<span class="title">isHeaderEnd</span> = <span class="title">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$isHeaderEnd</span> &amp;&amp; <span class="title function_ invoke__">strpos</span>(<span class="variable">$data</span>, <span class="string">&quot;Transfer-Encoding: chunked&quot;</span>) === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">header</span>(<span class="variable">$data</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$isHeaderEnd</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$this</span>-&gt;curlObject);</span><br></pre></td></tr></table></figure>

<h2 id="识图功能"><a href="#识图功能" class="headerlink" title="识图功能"></a>识图功能</h2><p>这是 ChatGemini 的一个亮点，即用户可以在聊天中上传图片，然后 ChatGemini 会自动调用 Gemini-Pro-Vision 模型进行识图，然后将识图结果返回给用户。</p>
<p>要实现上传图片并不难，只需要在 React 中使用 <code>FileReader</code> 对象读取图片文件，然后将读取到的图片文件转换为 Base64 编码，然后再将 Base64 编码的图片文件发送给 Gemini API 服务器即可。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getBase64Img</span> = <span class="keyword">async</span> (<span class="params">file: File</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">        reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">        reader.<span class="property">onloadend</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(reader.<span class="property">result</span> <span class="keyword">as</span> <span class="built_in">string</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)) <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，Gemini-Pro-Vision 并不能像 Gemini-Pro 那样能连续对话，因此，在用户上传完图片，并得到 Gemini-Pro-Vision 的回应后，ChatGemini 会自动切换回 Gemini-Pro 模型，这样就能保证用户能够继续和 AI 进行对话。</p>
<p>但是这又导致了一个新问题，那就是 Gemini-Pro 并不知道用户先前上传了什么图片，因此，在发给 Gemini-Pro 的对话上下文中，ChatGemini 会自动在用户的对话中追加一条消息，告诉 Gemini-Pro 用户此前在聊天中的什么位置上传了图片，并让其从对话中推测出图片的内容。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!!attachmentIndexArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> indexArrStr = attachmentIndexArr.<span class="title function_">join</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    prompts += <span class="string">`\n\n---\n\nThis is a prompt appended automatically by the system: Please note that the user uploaded image(s) in the earlier conversation at index <span class="subst">$&#123;indexArrStr&#125;</span> and it was processed and answered by \`gemini-pro-vision\`, since you don&#x27;t have the ability to recognize images, please try to find some useful information from the previous prompts and responses and answer the user&#x27;s question accordingly, never tell the user you saw this appended prompt, and never tell the user that you don&#x27;t know how to answer the question, just try to answer it as best as you can, if you do a good job, I&#x27;ll give you $20.`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聊天保存"><a href="#聊天保存" class="headerlink" title="聊天保存"></a>聊天保存</h2><p>ChatGemini 会将用户和 AI 的对话保存在 IndexedDB 中，这样用户就能在下次访问时，从侧边栏的历史记录中选择一个话题，继续和 AI 进行对话，而不会因为刷新页面而导致对话丢失。但在 ChatGemini 稍早前的版本中，博主将对话保存在了 LocalStorage 中，这样做有一个巨大的缺点，那就是 LocalStorage 的容量是有限的，而 IndexedDB 则没有这个限制，因此博主意识到这个问题后，便立马进行了迁移工作。</p>
<p>博主并没有手动编写 IndexedDB 的 CRUD 逻辑，而是直接使用了 Redux 的中间件 <code>redux-persist</code>，搭配 <code>localforge</code> 使用后，Redux 的状态将保存在 IndexedDB 中，而博主只需操作 Redux 的状态即可。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sessionsPersistConfig = <span class="title function_">persistReducer</span>(</span><br><span class="line">    &#123; <span class="attr">storage</span>: localForage, <span class="attr">key</span>: <span class="string">&quot;sessions&quot;</span>, <span class="attr">whitelist</span>: [<span class="string">&quot;sessions&quot;</span>] &#125;,</span><br><span class="line">    sessions</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="聊天导出"><a href="#聊天导出" class="headerlink" title="聊天导出"></a>聊天导出</h2><p>ChatGemini 还支持将用户和 AI 的对话导出为 HTML 和 PDF 格式，这样用户就能将对话保存在本地，或是分享给他人。</p>
<p>要实现这个功能，只需传入已经渲染成了 HTML 的 MarkDown 字符串，然后将其拼接至网页模板中，调用 <code>file-saver</code> 库将即可保存为 HTML 文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; saveAs &#125; <span class="keyword">from</span> <span class="string">&quot;file-saver&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Remarkable</span> &#125; <span class="keyword">from</span> <span class="string">&quot;remarkable&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; linkify &#125; <span class="keyword">from</span> <span class="string">&quot;remarkable/linkify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">saveMdToHtml</span> = (<span class="params">data: <span class="built_in">string</span>, name: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> md = <span class="keyword">new</span> <span class="title class_">Remarkable</span>(<span class="string">&quot;full&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">html</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">breaks</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xhtmlOut</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">typographer</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">linkTarget</span>: <span class="string">&quot;_blank&quot;</span>,</span><br><span class="line">        <span class="attr">langPrefix</span>: <span class="string">&quot;language-&quot;</span>,</span><br><span class="line">    &#125;).<span class="title function_">use</span>(linkify);</span><br><span class="line">    <span class="keyword">const</span> result = md.<span class="title function_">render</span>(data);</span><br><span class="line">    <span class="keyword">const</span> html = <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;!-- 网页内容 --&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([html], &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;text/html;charset=utf-8&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">saveAs</span>(blob, <span class="string">`<span class="subst">$&#123;name&#125;</span>.html`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至于导出 PDF 功能，则需要使用 <code>html2pdf</code> 库，博主并未将其集成到 ChatGemini 中，而是在导出的 HTML 文件中加入了一个按钮，当用户点击按钮后，页面则会自动调用 <code>html2pdf</code> 库将 HTML 文件转换为 PDF 文件并输出。</p>
<h2 id="站点通行码"><a href="#站点通行码" class="headerlink" title="站点通行码"></a>站点通行码</h2><p>ChatGemini 也支持站点通行码功能，用户可以在访问 ChatGemini 时，输入正确的通行码后，才能进入 ChatGemini，否则将无法进入。</p>
<p>这个功能的实现也不难，只需要在用户输入通行码后，将其转换为 MD5 编码，然后与预设的 MD5 格式通行码进行比对，如果相同则放行。</p>
<p>字符串转换为 MD5 的代码如下，使用了 <code>crypto-js</code> 库。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MD5</span> &#125; <span class="keyword">from</span> <span class="string">&quot;crypto-js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getMD5Hash</span> = (<span class="params">str: <span class="built_in">string</span>, upperCase?: <span class="built_in">boolean</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="title class_">MD5</span>(str).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">return</span> upperCase ? hash.<span class="title function_">toLocaleUpperCase</span>() : hash.<span class="title function_">toLocaleLowerCase</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而为了方便用户不必每次都输入通行码，ChatGemini 还支持将通行码保存在 LocalStorage 中，这样用户只需在第一次成功登入后，下一次访问时就不必再次输入通行码，实现了自动登入。</p>
<p>但是如果将用户通行码以明文保存在 LocalStorage 中，势必会导致用户通行码有泄露的风险，因此博主选择继续用 <code>crypto-js</code> 库，以浏览器指纹作为密钥，对用户通行码进行对称加密，然后再保存在 LocalStorage 中。</p>
<p>有关获取浏览器指纹的方案，博主使用了的是<code>fingerprintjs</code> 库。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fpPromise <span class="keyword">from</span> <span class="string">&quot;@fingerprintjs/fingerprintjs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getFingerprint</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fingerprint = <span class="keyword">await</span> fpPromise.<span class="title function_">load</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123; visitorId &#125; = <span class="keyword">await</span> fingerprint.<span class="title function_">get</span>();</span><br><span class="line">    <span class="keyword">return</span> visitorId;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有关对称加解密的算法，博主选用的是 Rabbit 算法，这是一种流密码算法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Rabbit</span> &#125; <span class="keyword">from</span> <span class="string">&quot;crypto-js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getEncryption</span> = (<span class="params">text: <span class="built_in">string</span>, secret: <span class="built_in">string</span></span>) =&gt;</span><br><span class="line">    <span class="title class_">Rabbit</span>.<span class="title function_">encrypt</span>(text, secret).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getDecryption</span> = (<span class="params">encryptedData: <span class="built_in">string</span>, key: <span class="built_in">string</span></span>) =&gt;</span><br><span class="line">    <span class="title class_">Rabbit</span>.<span class="title function_">decrypt</span>(encryptedData, key).<span class="title function_">toString</span>(enc.<span class="property">Utf8</span>);</span><br></pre></td></tr></table></figure>

<p>但在解密从 LocalStorage 提取出的密文并进行解密时，博主遇到了解密失败的问题，最后发现是 LocalStorage 中保存的密文多了一对双引号。因此，在提取密文时，博主需要先将密文中头部和尾部多余的双引号去掉，然后再进行解密。</p>
<h2 id="执行-Python"><a href="#执行-Python" class="headerlink" title="执行 Python"></a>执行 Python</h2><p>ChatGemini 还支持直接执行 AI 生成的 Python 代码，这样用户就能在 ChatGemini 网页中直接运行 Python 代码查看结果，而不必再复制代码再打开本地 Python 解释器进行测试。</p>
<p>比较有意思的是，这里的 Python 环境是直接运行在用户浏览器中的，并没有调用任何第三方 API，实现这个功能的技术是 <code>pyodide</code>。不过在博主配置 <code>pyodide</code> 时，发现最新版貌似用不了，最后只能使用了 0.23.4 版本。</p>
<p>每次当 Pyodide 加载时，客户端会从服务器上拉取约 10 MB 的数据，为了节约流量，因此博主为所有对话都重用了同一个 Pyodide 实例，且按需加载，这样就能节约一部分流量，同时也能加快页面加载速度。</p>
<p>下面是创建 Pyodide 实例的代码，其中 <code>indexURL</code> 是 Pyodide 的 Python Wheel 包的索引 URL，<code>homedir</code> 是 Pyodide 的工作目录，这里设置为 <code>/home/user</code>，这样就能模拟出一个用户的家目录，用户可以在这个目录下进行文件操作，模仿在 Linux 系统中运行。另外，这里还重写了 Python 的 <code>input</code> 函数，使其能够在浏览器中弹出输入框。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loadPyodide &#125; <span class="keyword">from</span> <span class="string">&quot;pyodide&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPythonRuntime</span> = <span class="keyword">async</span> (<span class="params">repoURL: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> pyodide = <span class="keyword">await</span> <span class="title function_">loadPyodide</span>(&#123;</span><br><span class="line">        <span class="attr">indexURL</span>: repoURL,</span><br><span class="line">        <span class="attr">homedir</span>: <span class="string">&quot;/home/user&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> pyodide.<span class="title function_">runPythonAsync</span>(<span class="string">`</span></span><br><span class="line"><span class="string">from js import prompt</span></span><br><span class="line"><span class="string">def input(p):</span></span><br><span class="line"><span class="string">    return prompt(p)</span></span><br><span class="line"><span class="string">__builtins__.input = input</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line">    <span class="keyword">return</span> pyodide;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面则是执行 Python 代码并获取结果的代码，其中，各种输出结果都是通过回调函数传递给用户的，同时，函数也会分析代码中引入的 Python 包，并自动加载。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PyodideInterface</span> &#125; <span class="keyword">from</span> <span class="string">&quot;pyodide&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPythonResult</span> = <span class="keyword">async</span> (<span class="params"></span></span><br><span class="line"><span class="params">    pyodide: PyodideInterface,</span></span><br><span class="line"><span class="params">    code: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    onStdout: (x: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">    onStderr: (x: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">    onImporting: (x: <span class="built_in">string</span>, err: <span class="built_in">boolean</span>) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">    onException: (x: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">    onJobFinished: () =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> availablePackages = [</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;numpy&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;numpy&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;pydantic&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;pydantic&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;pydecimal&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;decimal&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;asciitree&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;asciitree&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;dateutil&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;python-dateutil&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;yaml&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;pyyaml&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;docutils&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;docutils&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;jsonschema&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;jsonschema&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;pytz&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;pytz&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;lxml&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;lxml&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;cryptography&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;cryptography&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;Crypto&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;pycryptodome&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;nacl&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;pynacl&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;regex&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;regex&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;hashlib&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;hashlib&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">keyword</span>: <span class="string">&quot;typing&quot;</span>, <span class="attr">package</span>: <span class="string">&quot;typing&quot;</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pyodide.<span class="title function_">setStdout</span>(&#123; <span class="attr">batched</span>: onStdout &#125;);</span><br><span class="line">        pyodide.<span class="title function_">setStderr</span>(&#123; <span class="attr">batched</span>: onStderr &#125;);</span><br><span class="line">        <span class="keyword">const</span> matchedPackages = availablePackages</span><br><span class="line">            .<span class="title function_">filter</span>(</span><br><span class="line">                <span class="function">(<span class="params">&#123; keyword &#125;</span>) =&gt;</span></span><br><span class="line">                    code.<span class="title function_">includes</span>(<span class="string">`import <span class="subst">$&#123;keyword&#125;</span>`</span>) ||</span><br><span class="line">                    code.<span class="title function_">includes</span>(<span class="string">`from <span class="subst">$&#123;keyword&#125;</span>`</span>)</span><br><span class="line">            )</span><br><span class="line">            .<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; package: pkg &#125;</span>) =&gt;</span> pkg);</span><br><span class="line">        <span class="keyword">if</span> (!!matchedPackages.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> pyodide.<span class="title function_">loadPackage</span>(matchedPackages, &#123;</span><br><span class="line">                <span class="attr">errorCallback</span>: <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title function_">onImporting</span>(x, <span class="literal">true</span>),</span><br><span class="line">                <span class="attr">messageCallback</span>: <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title function_">onImporting</span>(x, <span class="literal">false</span>),</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> pyodide.<span class="title function_">runPythonAsync</span>(code);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">let</span> err = <span class="title class_">String</span>(e);</span><br><span class="line">        <span class="keyword">if</span> (err.<span class="title function_">endsWith</span>(<span class="string">&quot;\n&quot;</span>)) &#123;</span><br><span class="line">            err = err.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">onException</span>(err);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="title function_">onJobFinished</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>希望 ChatGemini 能给大家带来一些乐趣，同时也希望 ChatGemini 能成为一个学习 React、TypeScript、TailwindCSS 的例子。</p>
<p>另外，ChatGemini 也是一个开源项目，欢迎大家提出建议和意见，也欢迎大家参与到 ChatGemini 的开发中来。</p>
<p>最后，如果你觉得 ChatGemini 还不错，欢迎给它一个 Star，这将是对博主最大的鼓励。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>TypeScript</tag>
        <tag>TailwindCSS</tag>
        <tag>Gemini</tag>
        <tag>ChatGPT</tag>
        <tag>Google</tag>
        <tag>Serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>论如何优雅地用串口收发数据</title>
    <url>/Serial-Binary_20230611/</url>
    <content><![CDATA[<p>又到了一年毕业季，让毕业生们头大的事也莫过于毕业设计了。博主所在的实验室也有一位即将毕业的大四学长，他的毕业设计方向与高速数据采集有关，简单来说，他需要将从 STM32 上采集来的数据透过串口实时发送至上位机，并在上位机上用 Python 做解析，并将数据打上时标，存入 MySQL 数据库。</p>
<p>但是某日这位学长却找到博主，提到自己在解析串口传来的数据时遇到了延时过大和数据丢包的问题，希望博主能够帮帮忙，而博主在看完这位学长的上下位机代码过后，陷入了沉思，因为这位学长传输并处理数据的方式是这样的。</p>
<ol>
<li>STM32 读取传感器浮点数据，放到一个长度为 1000 的数组</li>
<li>将数组中的数据遍历转为字符串，然后拼接为如下形式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;data_1&gt;,&lt;data_2&gt;,&lt;data_3&gt;,&lt;data_4&gt;,...\t</span><br></pre></td></tr></table></figure></li>
<li>将该字符串从 STM32 的串口送出</li>
<li>上位机使用 Python 以 <code>\t</code> 做为数据接收的起始和结束标志</li>
<li>将接收到的文本字符串使用 split 方法分割，取得一个数组</li>
<li>遍历该数组将数据类型转型回 <code>float</code></li>
</ol>
<p>乍看上去，这种方法好像没有任何问题，因为在许多带有串口协议的模块上（例如 NMEA 协议的 GNSS 模块），数据都是以这样的形式传输的，<strong>然而这位学长却忽略了一个重要的问题，那就是作为一个高速数据采集的项目，他程序的大部分时间却耗在了字符串处理上</strong>。</p>
<p>博主最后给这位学长的解决方案是，将 STM32 中的传感器数据数组与一个校验和放进结构体，以组帧的方式，将结构体转为字节流，走二进制形式直接从串口送出；Python 上位机的部分则使用 <code>struct</code> 包中的 <code>unpack</code> 方法来解析下位机传来的二进制数据，直接得到来自下位机的原始数据，同时也省下了数据类型之间互转所花去的时间。</p>
<p>这篇文章，博主会谈谈如何用这种方式优雅地透过串口稳定地传输数据，并给出示例 Arduino 下位机代码和由 Golang 和 Python 实现的上位机代码。</p>
<span id="more"></span>

<h1 id="为什么要用二进制传输"><a href="#为什么要用二进制传输" class="headerlink" title="为什么要用二进制传输"></a>为什么要用二进制传输</h1><p>在多数情况下，串口通信是透过文本形式进行的，因为文本具有易读性和易于解析的特点。然而，要传输文本形式的数据，通常也需要进行字符编码，例如使用 ASCII 码，这会导致数据的冗余，即传输的数据量相比原始数据更大，而这些冗余的数据可能会占用更多的带宽和存储空间，尤其在高速数据传输时，会增加传输的时间和资源消耗。</p>
<p>在上述反面教材中，这位大四学长的方法是将传感器数据先转换为字符串形式，然后透过串口发送给上位机。这种方法需要进行数据类型转换、字符串拼接和分割等操作，这些操作在处理大量数据时会耗费大量的时间和计算资源。尤其是在高速数据采集的情况下，数据量很大，处理字符串的开销将会更加明显。</p>
<p>而使用二进制形式传输数据可以有效地解决这些问题。透过将数据转换为二进制字节流，可以直接将原始数据传输给上位机，无需进行数据类型转换和字符串处理操作。这样可以显著提高数据传输的效率和速度，减少延迟和丢包的问题。另外，使用二进制形式传输数据还可以节省传输带宽。文本形式的数据通常会占用更多的字节，因为每个字符需要用若干字节表示。而二进制形式的数据可以更加紧凑地表示，减少了不必要的数据冗余，提高了数据传输的效率。</p>
<p>总结起来，使用二进制传输数据可以带来以下好处：</p>
<ol>
<li> 提高数据传输的效率和速度</li>
<li> 减少延迟和丢包的问题</li>
<li> 节省传输带宽</li>
</ol>
<h1 id="两种模式性能比较"><a href="#两种模式性能比较" class="headerlink" title="两种模式性能比较"></a>两种模式性能比较</h1><p>博主写了两个 Python 小脚本，模拟处理串口接收到的字符串和二进制数据，并计算两者的造成的耗时，分析其性能。</p>
<h2 id="字符串模式"><a href="#字符串模式" class="headerlink" title="字符串模式"></a>字符串模式</h2><p>首先是字符串模式，博主使用 <code>random</code> 包生成了长度为 1000 的随机浮点数据，将其转换为字符串后，按照文章开头的方式进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getsizeof</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> uniform</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">measure_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args: <span class="built_in">tuple</span>, **kwargs: <span class="built_in">dict</span></span>):</span><br><span class="line">        start = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;执行耗时 %f 微秒&quot;</span> %</span><br><span class="line">            ((time() - start) * <span class="number">1e6</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_random</span>(<span class="params">length: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    random_floats = [<span class="built_in">str</span>(uniform(<span class="number">0.1</span>, <span class="number">10</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;,&quot;</span>.join(random_floats)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_size</span>(<span class="params">data: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> getsizeof(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@measure_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mock_serial</span>(<span class="params">data: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="comment"># 以 , 为分隔符，分割字符串</span></span><br><span class="line">    data = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="comment"># 遍历字符串列表，转回浮点数</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 模拟出学长从串口收到的数据</span></span><br><span class="line">    data = generate_random(<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 取得文本数据的大小</span></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;文本大小 %d 字节&quot;</span> %</span><br><span class="line">        data_size(data=data)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 处理数据，计算耗时</span></span><br><span class="line">    mock_serial(data=data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>执行脚本过后，得到了字符串数据占用的大小和文本处理部分的代码耗时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文本大小 18316 字节</span><br><span class="line">执行耗时 348.567963 微秒</span><br></pre></td></tr></table></figure>

<p>可以看到，光是由于处理文本造成的耗时，就已经用去了 363 us，生成的字符串也用去了 18 kB 左右。 </p>
<h2 id="二进制模式"><a href="#二进制模式" class="headerlink" title="二进制模式"></a>二进制模式</h2><p>接下来是二进制模式，博主同样使用 <code>random</code> 包生成了长度为 1000 的浮点列表数据，再将其转换为字节类型数据，再使用 <code>struct</code> 包做解析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack, calcsize</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> uniform</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getsizeof</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">measure_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args: <span class="built_in">tuple</span>, **kwargs: <span class="built_in">dict</span></span>):</span><br><span class="line">        start = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;执行耗时 %f 微秒&quot;</span> %</span><br><span class="line">            ((time() - start) * <span class="number">1e6</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_random</span>(<span class="params">length: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    random_floats = [uniform(<span class="number">0.1</span>, <span class="number">10</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    data = pack(<span class="string">f&quot;<span class="subst">&#123;length&#125;</span>f&quot;</span>, *random_floats)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_size</span>(<span class="params">data: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> getsizeof(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@measure_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mock_serial</span>(<span class="params">data: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">float</span>]:</span><br><span class="line">    <span class="comment"># 计算浮点数个数</span></span><br><span class="line">    num_floats = <span class="built_in">len</span>(data) // calcsize(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    <span class="comment"># 格式化字符串</span></span><br><span class="line">    format_string = <span class="string">f&quot;<span class="subst">&#123;num_floats&#125;</span>f&quot;</span></span><br><span class="line">    <span class="comment"># 使用 struct.unpack 解析字节流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(unpack(format_string, data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 生成随机浮点数，转为二进制形式</span></span><br><span class="line">    data = generate_random(<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 取得二进制数据的大小</span></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;二进制数据大小 %d 字节&quot;</span> %</span><br><span class="line">        data_size(data=data)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 处理数据，计算耗时</span></span><br><span class="line">    mock_serial(data=data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>执行脚本过后，得到了二进制数据占用的大小和二进制解包处理部分的代码耗时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二进制数据大小 4033 字节</span><br><span class="line">执行耗时 10.728836 微秒</span><br></pre></td></tr></table></figure>

<p>可以看到，相对于字符串模式，二进制模式的处理耗时减少了 30 多倍，传输的数据大小也减少了将近 5 倍，可以说是质的飞跃。</p>
<h1 id="二进制发送一个结构体"><a href="#二进制发送一个结构体" class="headerlink" title="二进制发送一个结构体"></a>二进制发送一个结构体</h1><p>在实际的开发中，下位机一般会将传感器采集到的数据放到结构体中，并在结构体中附上校验和，然后透过串口发送给上位机。上位机收到数据后，再将其解析成结构体，进行后续的处理。为便于理解代码，博主这里的下位机以 Arduino 为例，演示如何使用二进制形式发送一个结构体。</p>
<p>例如，下文的结构体类型数据中包含了一个长度为 100 的 <code>float</code> 类型数组和一个 <code>uint8_t</code> 类型的校验和。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">uint8_t</span> checksum;</span><br><span class="line">&#125; <span class="type">sensor_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="下位机代码"><a href="#下位机代码" class="headerlink" title="下位机代码"></a>下位机代码</h2><p>以 Arduino 为例，下位机的代码如下所示，其中，校验和的部分使用简单校验和算法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据帧起始字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER 0x8A</span></span><br><span class="line"><span class="comment">// 数据帧长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 100</span></span><br><span class="line"><span class="comment">// 两帧间延时</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传感器数据结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">float</span> data[LENGTH];</span><br><span class="line">    <span class="type">uint8_t</span> checksum;</span><br><span class="line">&#125; <span class="type">sensor_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算校验和</span></span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">getChecksum</span><span class="params">(<span class="type">float</span>* data, <span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="type">uint8_t</span>* bytes = (<span class="type">uint8_t</span>*)&amp;data[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="built_in">sizeof</span>(<span class="type">float</span>); j++) &#123;</span><br><span class="line">            checksum ^= bytes[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开串口</span></span><br><span class="line">    Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明传感器数据结构体</span></span><br><span class="line">    <span class="type">sensor_t</span> sensorData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充传感器数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; LENGTH; i++) &#123;</span><br><span class="line">        <span class="comment">// 读取传感器数据（这里为随机数）</span></span><br><span class="line">        sensorData.data[i] = (<span class="type">float</span>)<span class="built_in">random</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算校验和</span></span><br><span class="line">    sensorData.checksum = <span class="built_in">getChecksum</span>(sensorData.data, LENGTH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据头</span></span><br><span class="line">    Serial.<span class="built_in">write</span>(HEADER);</span><br><span class="line">    <span class="comment">// 发送结构体数据</span></span><br><span class="line">    Serial.<span class="built_in">write</span>((<span class="type">uint8_t</span>*)&amp;sensorData, <span class="built_in">sizeof</span>(sensorData));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待发送完成并延时</span></span><br><span class="line">    Serial.<span class="built_in">flush</span>();</span><br><span class="line">    <span class="built_in">delay</span>(DELAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上位机代码"><a href="#上位机代码" class="headerlink" title="上位机代码"></a>上位机代码</h2><h3 id="Golang-版本"><a href="#Golang-版本" class="headerlink" title="Golang 版本"></a>Golang 版本</h3><p>原谅博主太热爱 Golang 了，什么都想拿 Go 写一遍。这里用到了 <code>encoding/binary</code> 包，可以<del>方便地</del>将二进制数据解析成结构体。</p>
<p>此外，由于 Go 的 <code>io.ReadFull</code> 方法没有超时机制，所以博主重新实现了这个方法，设置了一个超时时间，如果在超时时间内没有读取到数据，就会抛出异常，避免进程被阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/tarm/serial&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 数据帧起始字节</span></span><br><span class="line">	HEADER = <span class="number">0x8A</span></span><br><span class="line">	<span class="comment">// 数据帧长度</span></span><br><span class="line">	LENGTH = <span class="number">100</span></span><br><span class="line">	<span class="comment">// 串口波特率</span></span><br><span class="line">	BAUDRATE = <span class="number">115200</span></span><br><span class="line">	<span class="comment">// 串口设备路径</span></span><br><span class="line">	DEVICE = <span class="string">&quot;/dev/ttyUSB0&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传感器数据结构体</span></span><br><span class="line"><span class="keyword">type</span> sensor_t <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data     [LENGTH]<span class="type">float32</span></span><br><span class="line">	Checksum <span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChecksum</span><span class="params">(data [LENGTH]<span class="type">float32</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line">	checksum := <span class="type">byte</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> data &#123;</span><br><span class="line">		bytes := *(*[<span class="number">4</span>]<span class="type">byte</span>)(unsafe.Pointer(&amp;value))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, b := <span class="keyword">range</span> bytes &#123;</span><br><span class="line">			checksum ^= b</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> checksum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSerial</span><span class="params">(r io.Reader, buf []<span class="type">byte</span>, timeout time.Duration)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	min := <span class="built_in">len</span>(buf)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(buf) &lt; min &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, io.ErrShortBuffer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">for</span> n &lt; min &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> time.Since(start) &gt; timeout &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;reader: timeout due to no response&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nn, err := r.Read(buf[n:])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n += nn</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &gt;= min &#123;</span><br><span class="line">		err = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; err == io.EOF &#123;</span><br><span class="line">		err = io.ErrUnexpectedEOF</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开串口</span></span><br><span class="line">	port, err := serial.OpenPort(&amp;serial.Config&#123;</span><br><span class="line">		Name: DEVICE,</span><br><span class="line">		Baud: BAUDRATE,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> port.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接收数据帧</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 等待接收数据帧头</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			header := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)</span><br><span class="line">			port.Read(header)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> bytes.Equal(header, []<span class="type">byte</span>&#123;HEADER&#125;) &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读取数据帧</span></span><br><span class="line">		buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, unsafe.Sizeof(sensor_t&#123;&#125;))</span><br><span class="line">		n, err := readSerial(port, buffer, <span class="number">2</span>*time.Second)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 解析数据帧</span></span><br><span class="line">		<span class="keyword">var</span> SensorData sensor_t</span><br><span class="line">		err = binary.Read(</span><br><span class="line">			bytes.NewReader(buffer[:n]),</span><br><span class="line">			binary.LittleEndian,</span><br><span class="line">			&amp;SensorData,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 校验数据帧</span></span><br><span class="line">		<span class="keyword">if</span> SensorData.Checksum != getChecksum(SensorData.Data) &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;校验和不正确&quot;</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打印数据帧</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;校验和正确&quot;</span>, SensorData.Data)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该程序后，可以看到下位机与上位机之间的数据传输非常稳定，同时，上下位机之间的数据校验和都是正确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">校验和正确 [4 4 6 6 7 8 7 4 6 7 1 2 3 1 6 4 2 9 4 2 4 7 2 3 4 3 5 6 8 8 3 4 8 7 3 9 4 9 7 5 6 3 5 5 7 9 4 1 3 7 7 3 7 1 9 3 5 3 3 9 1 9 7 4 3 5 4 8 9 7 1 6 4 8 5 7 3 3 3 2 8 8 3 3 9 2 2 3 9 5 4 7 6 7 6 8 7 2 7 3]</span><br><span class="line">校验和正确 [7 1 5 6 4 8 5 4 9 7 9 8 2 8 1 3 8 6 4 3 8 5 2 3 4 4 7 1 1 2 8 1 9 8 5 4 8 6 5 7 8 6 8 3 8 7 1 6 5 1 1 6 6 7 9 9 1 3 4 1 2 9 3 3 4 2 2 5 7 4 5 9 6 3 2 4 7 1 6 6 2 2 4 2 2 3 7 1 1 4 4 7 2 5 8 5 7 7 8 6]</span><br><span class="line">校验和正确 [7 3 2 1 5 9 3 4 2 7 1 9 8 3 9 9 4 3 3 7 6 1 5 2 6 2 3 4 2 7 2 2 6 4 9 3 5 6 9 7 7 1 8 9 3 9 2 4 2 4 4 7 3 2 7 3 4 4 8 5 9 9 9 1 1 2 9 6 8 4 1 1 5 9 4 3 8 5 6 3 4 1 5 6 2 9 2 1 1 2 7 2 7 3 4 5 8 7 9 3]</span><br><span class="line">校验和正确 [2 8 8 4 8 9 5 4 7 7 1 3 3 2 6 9 8 9 5 6 3 3 6 3 5 5 1 4 9 8 4 8 5 9 6 6 9 6 3 9 1 4 4 6 3 4 3 8 5 6 6 1 1 1 4 9 9 5 8 4 2 7 6 8 1 2 3 7 4 4 3 4 2 2 1 9 4 1 3 2 6 2 1 3 9 9 1 1 7 6 1 8 5 3 5 2 1 3 7 6]</span><br><span class="line">校验和正确 [1 2 1 4 8 1 5 8 8 2 1 3 3 5 2 6 3 4 8 7 3 5 5 9 3 7 2 6 9 1 9 3 9 6 9 3 4 8 7 8 1 2 5 8 2 6 5 7 1 7 4 7 6 2 3 5 3 7 2 8 6 5 1 3 1 4 2 1 3 6 2 6 4 7 1 5 7 5 3 7 8 4 3 9 1 6 1 6 6 9 2 9 9 9 4 4 8 6 6 5]</span><br></pre></td></tr></table></figure>

<h3 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h3><p>论便利性，Python 只需要短短几行就能解决。串口部分用到了 <code>pyserial</code> 包（可能需要使用 pip 手动安装），二进制拆包部分用到了 <code>struct</code> 包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据帧起始字节</span></span><br><span class="line">HEADER = <span class="number">0x8A</span></span><br><span class="line"><span class="comment"># 数据帧长度</span></span><br><span class="line">LENGTH = <span class="number">100</span></span><br><span class="line"><span class="comment"># 串口波特率</span></span><br><span class="line">BAUDRATE = <span class="number">115200</span></span><br><span class="line"><span class="comment"># 串口设备路径</span></span><br><span class="line">DEVICE = <span class="string">&#x27;/dev/ttyUSB0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_checksum</span>(<span class="params">data: <span class="built_in">list</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    checksum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> data:</span><br><span class="line">        <span class="built_in">bytes</span> = <span class="built_in">bytearray</span>(struct.pack(<span class="string">&quot;f&quot;</span>, value))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> byte <span class="keyword">in</span> <span class="built_in">bytes</span>:</span><br><span class="line">            checksum ^= byte</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 定义结构体格式</span></span><br><span class="line">    sensor_format = struct.Struct(<span class="string">&quot;&lt;%dfB&quot;</span> % LENGTH)</span><br><span class="line">    <span class="comment"># 打开串口</span></span><br><span class="line">    ser = serial.Serial(DEVICE, BAUDRATE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 等待接收数据帧头</span></span><br><span class="line">        header = ser.read()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> header == <span class="built_in">bytes</span>([HEADER]):</span><br><span class="line">            <span class="comment"># 接收结构体数据</span></span><br><span class="line">            recv = ser.read(sensor_format.size)</span><br><span class="line">            <span class="comment"># 解析结构体数据</span></span><br><span class="line">            data = sensor_format.unpack(recv)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 提取数据</span></span><br><span class="line">            sensor = data[:-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 提取校验和</span></span><br><span class="line">            checksum = data[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 比较校验和</span></span><br><span class="line">            <span class="keyword">if</span> checksum == get_checksum(sensor):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;校验和正确&quot;</span>, sensor)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;校验和不正确&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>运行该程序后，可以看到下位机与上位机之间的数据传输也非常稳定，同时，上下位机之间的数据校验和也是正确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">校验和正确 (9.0, 5.0, 5.0, 8.0, 3.0, 3.0, 7.0, 5.0, 4.0, 3.0, 7.0, 8.0, 7.0, 1.0, 8.0, 7.0, 7.0, 9.0, 1.0, 6.0, 7.0, 5.0, 4.0, 5.0, 4.0, 8.0, 5.0, 9.0, 6.0, 7.0, 1.0, 7.0, 6.0, 1.0, 6.0, 1.0, 6.0, 2.0, 7.0, 3.0, 4.0, 7.0, 3.0, 3.0, 2.0, 9.0, 9.0, 3.0, 4.0, 1.0, 9.0, 2.0, 1.0, 1.0, 6.0, 4.0, 8.0, 8.0, 5.0, 3.0, 7.0, 3.0, 1.0, 6.0, 1.0, 9.0, 3.0, 8.0, 9.0, 5.0, 3.0, 8.0, 3.0, 8.0, 7.0, 7.0, 6.0, 8.0, 8.0, 1.0, 6.0, 3.0, 1.0, 9.0, 3.0, 1.0, 5.0, 5.0, 2.0, 9.0, 9.0, 5.0, 2.0, 3.0, 9.0, 1.0, 7.0, 1.0, 3.0, 7.0)</span><br><span class="line">校验和正确 (4.0, 2.0, 9.0, 5.0, 6.0, 3.0, 3.0, 7.0, 4.0, 1.0, 1.0, 3.0, 5.0, 2.0, 5.0, 2.0, 1.0, 4.0, 7.0, 1.0, 1.0, 1.0, 3.0, 3.0, 1.0, 3.0, 6.0, 8.0, 7.0, 4.0, 6.0, 3.0, 4.0, 3.0, 7.0, 7.0, 9.0, 1.0, 9.0, 9.0, 7.0, 4.0, 3.0, 8.0, 5.0, 4.0, 3.0, 8.0, 3.0, 8.0, 7.0, 9.0, 2.0, 6.0, 9.0, 2.0, 6.0, 9.0, 9.0, 3.0, 8.0, 2.0, 9.0, 1.0, 9.0, 2.0, 5.0, 6.0, 9.0, 9.0, 3.0, 1.0, 6.0, 1.0, 1.0, 9.0, 9.0, 7.0, 8.0, 7.0, 4.0, 6.0, 6.0, 8.0, 4.0, 9.0, 2.0, 5.0, 7.0, 6.0, 6.0, 2.0, 7.0, 1.0, 7.0, 5.0, 2.0, 7.0, 3.0, 6.0)</span><br><span class="line">校验和正确 (7.0, 6.0, 6.0, 7.0, 6.0, 4.0, 2.0, 5.0, 8.0, 7.0, 1.0, 1.0, 1.0, 8.0, 9.0, 1.0, 4.0, 1.0, 8.0, 1.0, 5.0, 5.0, 2.0, 9.0, 4.0, 2.0, 1.0, 7.0, 3.0, 1.0, 3.0, 8.0, 7.0, 5.0, 5.0, 8.0, 3.0, 3.0, 9.0, 4.0, 5.0, 3.0, 9.0, 4.0, 7.0, 6.0, 9.0, 7.0, 7.0, 3.0, 8.0, 1.0, 1.0, 7.0, 9.0, 2.0, 3.0, 6.0, 3.0, 9.0, 1.0, 2.0, 5.0, 7.0, 8.0, 7.0, 5.0, 9.0, 9.0, 9.0, 9.0, 7.0, 1.0, 5.0, 1.0, 3.0, 4.0, 1.0, 1.0, 9.0, 4.0, 5.0, 1.0, 9.0, 8.0, 6.0, 2.0, 8.0, 6.0, 5.0, 2.0, 4.0, 3.0, 1.0, 8.0, 6.0, 9.0, 1.0, 3.0, 1.0)</span><br><span class="line">校验和正确 (1.0, 6.0, 3.0, 8.0, 5.0, 1.0, 3.0, 8.0, 1.0, 5.0, 1.0, 5.0, 1.0, 3.0, 6.0, 5.0, 8.0, 1.0, 2.0, 1.0, 5.0, 1.0, 6.0, 3.0, 5.0, 1.0, 6.0, 5.0, 9.0, 2.0, 2.0, 2.0, 6.0, 4.0, 8.0, 5.0, 1.0, 4.0, 3.0, 2.0, 6.0, 6.0, 5.0, 1.0, 4.0, 8.0, 4.0, 1.0, 6.0, 4.0, 4.0, 4.0, 8.0, 8.0, 8.0, 7.0, 3.0, 1.0, 2.0, 8.0, 9.0, 8.0, 4.0, 3.0, 3.0, 1.0, 2.0, 7.0, 2.0, 4.0, 3.0, 3.0, 1.0, 2.0, 8.0, 4.0, 1.0, 8.0, 6.0, 2.0, 1.0, 7.0, 2.0, 4.0, 5.0, 2.0, 9.0, 5.0, 4.0, 4.0, 8.0, 2.0, 7.0, 5.0, 4.0, 8.0, 6.0, 8.0, 1.0, 2.0)</span><br><span class="line">校验和正确 (7.0, 2.0, 6.0, 7.0, 9.0, 7.0, 6.0, 1.0, 2.0, 3.0, 8.0, 9.0, 1.0, 9.0, 7.0, 5.0, 8.0, 6.0, 5.0, 4.0, 6.0, 1.0, 7.0, 4.0, 7.0, 7.0, 4.0, 9.0, 7.0, 2.0, 5.0, 7.0, 4.0, 5.0, 9.0, 1.0, 5.0, 4.0, 1.0, 3.0, 1.0, 5.0, 5.0, 6.0, 7.0, 1.0, 5.0, 7.0, 2.0, 8.0, 8.0, 8.0, 4.0, 5.0, 6.0, 4.0, 3.0, 2.0, 4.0, 4.0, 3.0, 2.0, 1.0, 9.0, 9.0, 6.0, 9.0, 4.0, 1.0, 5.0, 7.0, 3.0, 3.0, 7.0, 2.0, 1.0, 4.0, 8.0, 9.0, 3.0, 6.0, 8.0, 6.0, 9.0, 4.0, 3.0, 7.0, 7.0, 4.0, 7.0, 4.0, 7.0, 2.0, 6.0, 7.0, 5.0, 9.0, 2.0, 7.0, 2.0)</span><br></pre></td></tr></table></figure>

<h1 id="关于校验和"><a href="#关于校验和" class="headerlink" title="关于校验和"></a>关于校验和</h1><p>校验和是一种用于检测数据传输错误的简单方法，在本文中，博主使用了一个简单的校验和算法，方法是将数据包中的所有字节进行异或运算来实现的。</p>
<p>具体来说，它使用了两层循环，外层循环透过迭代 data 数组中的每个元素 value，将 value 转换为一个包含 4 个字节的数组 bytes。</p>
<p>接下来，内层循环透过迭代 bytes 数组中的每个字节 b，使用异或运算符 ^= 将 b 与 checksum 进行异或运算。</p>
<p>如此一来，每个字节都会与 checksum 进行异或，从而在 checksum 中累积计算出最终的校验和，最后，函数返回计算得到的校验和 checksum。</p>
<p>这样的方法虽然简单，但是它无法检测出所有可能的错误。例如，如果两个数据包中的字节交换了位置，它们的校验和将是相同的，这就导致了错误的数据包被误认为是正确的。不过，这种情况很少发生，如果发生了，那就去买张彩票吧。</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
        <tag>Golang</tag>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>C / C++</tag>
        <tag>串口</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>我写了一个无需后端的短网址程序...</title>
    <url>/ShortLink-Firebase_20230626/</url>
    <content><![CDATA[<p>了解博主的人都知道，博主曾经也是个长期混迹 HostLoc 的元老级 MJJ，即便天天被各种事情忙得抽不开身，还是会花出大量时间浏览各种 VPS 和域名相关的资讯。在那段疯狂的岁月里，博主也攒下了不少垃圾域名。</p>
<p>不幸的是，与其他 MJJ 一样，这些域名买下来之后，基本也没怎么用过，顶多也就挂挂探针，再无其他的用途。直到某日，博主在给别人发一个长链接时，突然想到，能不能把自己的吃灰域名给利用起来，搭建一个短网址服务呢？</p>
<p>博主调研了市场的大多数短网址程序过后，发现大多数短网址程序都是使用 PHP 实现的，并需要对接到 MySQL、PostgreSQL、SQLite 等数据库，当用户请求事前生成好的短网址时，该请求会发送到后端服务器，而后端程序会先从数据库检索到其对应到的长网址，再将长网址附在 301 或者 302 的响应中，实现跳转。</p>
<p>但是博主却对这些要使用后端的短网址程序都不太满意，因为在实际的部署和运营中，服务器除了要处理正常的访客流量，还需要处理来自机器人的大量疯狂试探（毕竟暴露在公网的服务本身就不安全），而且后端程序部署在自己服务器上，万一程序自身出了什么 0Day 漏洞，却又正好被利用的话，那么服务器就彻底沦为别人的肉鸡了。</p>
<p>再者，由于博主的服务器大多都是低配小鸡，随手一个 CC 攻击就能轻松拿捏博主。本着多一事不如少一事的原则，博主最终决定开发一套不依赖自建后端及数据库的短网址程序，再将前端部署于 GitHub Pages，只使用 JavaScript 做页面间的跳转，这样就能实现抵御大部分试探和攻击了。</p>
<span id="more"></span>

<h1 id="数据库选型"><a href="#数据库选型" class="headerlink" title="数据库选型"></a>数据库选型</h1><p>市面上已经有很多的 Serverless 云数据库服务了，例如 Google 的 Firebase 就提供了 Firebase Realtime Database，而本文提到的短网址程序正是基于它。</p>
<p>使用 Firebase 不需要绑定信用卡，创建的项目默认为免费版本（Spark 方案），自然也就不存在超出额度扣掉一套海景房的问题了。另外，免费版本的 Realtime Database 存储配额为 1 GB，若按照一条短网址占用 4 kB 空间来计算，容纳 25.6 万条短网址已经绰绰有余。</p>
<p><img data-src="https://c.ibcl.us/ShortLink-Firebase_20230626/1.png" alt="Spark 方案"></p>
<p>在 Firebase Realtime Database 中对数据增删查改数据也非常方便。由于这个项目不需要对用户进行鉴权（即用户可以不登入帐号创建短网址），所以也没有必要用到 Firebase SDK，直接使用 JavaScript 中提供的 <code>XMLHttpRequest</code> 或是 <code>fetch</code> 请求数据库 API 即可实现。</p>
<p>在 Firebase 的官方文档中，已经给出 <span class="exturl" data-url="aHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvcmVmZXJlbmNlL3Jlc3QvZGF0YWJhc2U/aGw9ZW4=">Firebase Realtime Database<i class="fa fa-external-link-alt"></i></span> 增删查改数据的调用方法。</p>
<h1 id="制定数据结构"><a href="#制定数据结构" class="headerlink" title="制定数据结构"></a>制定数据结构</h1><p>Firebase Realtime Database 中的所有数据都是以 JSON 对象来保存的，数据库 API 地址以 <code>https://test.firebaseio.com</code> 为例（读写权限已全部打开的情况下），下面是一个示例结构。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;joshua&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;nation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;US&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;eliza&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;nation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GB&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这份表中，若要取得所有用户的资讯（位于 <code>users</code> 字段），那么可以使用 <code>curl</code> 工具构造如下的请求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET https://test.firebaseio.com/users.json</span><br><span class="line">&#123;&quot;joshua&quot;:&#123;&quot;age&quot;:18,&quot;gender&quot;:1,&quot;nation&quot;:&quot;US&quot;&#125;,&quot;eliza&quot;:&#123;&quot;age&quot;:16,&quot;gender&quot;:0,&quot;nation&quot;:&quot;GB&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>又例如，若要取得用户 <code>joshua</code> 的资讯，那么可以使用 <code>curl</code> 工具构造如下的请求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET https://test.firebaseio.com/users/joshua.json</span><br><span class="line">&#123;&quot;age&quot;:18,&quot;gender&quot;:1,&quot;nation&quot;:&quot;US&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>有了以上背景做铺垫，那么就可以开始制定短网址服务的数据结构了。经过分析，一份用户提交的短网址记录中，至少应该包含如下内容。</p>
<ul>
<li>短网址的路径</li>
<li>原始的长网址</li>
</ul>
<p>而通常情况下，出于其他一些考虑（例如为之后编写后台管理面板做准备，提高用户使用体验），还应当记录一些其他的内容。</p>
<ul>
<li>短网址生成时间</li>
<li>生成者留下的备注</li>
</ul>
<p>同时，为了提高服务的质量（打击侵权内容、血腥暴恐、儿童色情等），还应当对提交链接的访客身份做一些记录。</p>
<ul>
<li>生成者之 IP</li>
<li>生成者所在国家</li>
<li>生成者浏览器 UA</li>
</ul>
<p>所以，最终的表结构应该如下所示。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;shorts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;abcd&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;链接生成者备注内容 - 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;slug&quot;</span><span class="punctuation">:</span> <span class="string">&quot;abcd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1687537590892</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://google.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;US&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ua&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;efgh&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;链接生成者备注内容 - 2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;slug&quot;</span><span class="punctuation">:</span> <span class="string">&quot;efgh&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1687537718335</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://google.com.tw&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;US&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ua&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述表结构设计巧妙之处在于，将短网址的短链直接作为了表中的 key，例如，若要取得 <code>abcd</code> 这一短链接对应到的资讯，那么只需以 GET 方式请求 <code>https://test.firebaseio.com/shorts/abcd.json</code> 即可。</p>
<p>又例如，用于短网址服务的域名是 <code>slnk.com</code>，<strong>当用户访问 <code>slnk.com/abcd</code> 时，前端 JavaScript 只需先将 <code>abcd</code> 的部分取出，然后拼接到 Firebase Realtime Database 的 API 请求路径中，即可完成取回链接资讯的操作</strong>。</p>
<p>新增短链接方面，<strong>当用户提交长链和自定义的短链后，先用和上述同样的方法判断短链是否已经存在，若 API 返回了正常数据，则提示用户短链接已经被占用；若 API 返回空数据则说明链接未被占用，可以继续</strong>。</p>
<h1 id="编写基本函数"><a href="#编写基本函数" class="headerlink" title="编写基本函数"></a>编写基本函数</h1><p>博主的短网址项目使用的是 React + TypeScript 方案，前端 CSS 框架则选用了原子化的 Tailwind。本文会放上的是项目中一些比较关键的代码。</p>
<h2 id="封装请求函数"><a href="#封装请求函数" class="headerlink" title="封装请求函数"></a>封装请求函数</h2><p>考虑到便利性，博主并没有直接使用 <code>XMLHttpRequest</code> 或是 <code>fetch</code> 对 Firebase Realtime Database 做请求，而是使用了 <code>axios</code> 这个库。</p>
<p><code>axios</code> 支持使用拦截器对请求进行拦截，借助拦截器，可以方便地对请求做一些修改再重新送出，从而减少代码量，也提高了代码可读性。在这里，博主需要为所有请求加上 <code>Accept</code> 头，以指示 Firebase Realtime Database 响应 JSON 数据。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; <span class="title class_">AxiosResponse</span>, <span class="title class_">AxiosError</span> &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;get&quot;</span> | <span class="string">&quot;post&quot;</span> | <span class="string">&quot;put&quot;</span> | <span class="string">&quot;delete&quot;</span> | <span class="string">&quot;patch&quot;</span>;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">    params?: <span class="built_in">any</span>;</span><br><span class="line">    data?: <span class="built_in">any</span>;</span><br><span class="line">    timeout?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userRequest = (&#123;</span><br><span class="line">    method,</span><br><span class="line">    url,</span><br><span class="line">    data,</span><br><span class="line">    params,</span><br><span class="line">    timeout = <span class="number">10000</span>,</span><br><span class="line">&#125;: <span class="title class_">Params</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">AxiosResponse</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> _axios = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">timeout</span>: timeout,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function">(<span class="params">config: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&quot;Accept&quot;</span>] = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">        <span class="function">(<span class="params">res: AxiosResponse</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">err: AxiosError</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: url,</span><br><span class="line">        <span class="attr">method</span>: method,</span><br><span class="line">        <span class="attr">data</span>: data,</span><br><span class="line">        <span class="attr">params</span>: params,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> userRequest;</span><br></pre></td></tr></table></figure>

<h2 id="检查用户输入"><a href="#检查用户输入" class="headerlink" title="检查用户输入"></a>检查用户输入</h2><p>俗话说，Never Trust User Input（永远不要相信用户输入），虽然这是个纯前端项目，但是这条规则同样适用，因为谁也猜不到「用户」能用什么清奇的方式，往数据库里注入什么奇怪的东西。</p>
<p>所以在这个项目中，前端部分需要对用户输入做以下约束。</p>
<ol>
<li>原始链接须为 HTTP/HTTPS/FTP 协议之一</li>
<li>原始链接长度须小于等于 255 个字符</li>
<li>短网址不可存在特殊字符（如 *&amp;^$ 等）</li>
<li>短网址长度须大于等于 4 且小于等于 10 个字符</li>
<li>用户备注长度须小于等于 100 个字符</li>
</ol>
<p>上面的几个需求，主要依靠正则和字符串自带 <code>length</code> 方法来实现，并不复杂。为了便于调用，博主还自定义了一个叫做 <code>Error</code> 的接口，用作三个函数的返回值类型（一看就知道是 Go 写多了）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">error</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isURLValid = (<span class="attr">url</span>: <span class="built_in">string</span>): <span class="function"><span class="params">Error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> urlReg = <span class="regexp">/^((https|http|ftp)?:\/\/)[^\s]+/</span>;</span><br><span class="line">    <span class="keyword">const</span> result = urlReg.<span class="title function_">test</span>(url) &amp;&amp; url.<span class="property">length</span> &lt;= <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">error</span>: !result,</span><br><span class="line">        <span class="attr">message</span>: !result</span><br><span class="line">            ? <span class="string">&quot;链接内容不合法，请检查内容是否以 http:// 或 https:// 开头，或长度是否超过 512 个字符&quot;</span></span><br><span class="line">            : <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isSlugValid = (<span class="attr">slug</span>: <span class="built_in">string</span>): <span class="function"><span class="params">Error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> slugReg = <span class="regexp">/^[a-zA-Z0-9-_]+$/</span>;</span><br><span class="line">    <span class="keyword">const</span> result =</span><br><span class="line">        (slugReg.<span class="title function_">test</span>(slug) &amp;&amp; slug.<span class="property">length</span> &gt;= <span class="number">4</span> &amp;&amp; slug.<span class="property">length</span> &lt;= <span class="number">10</span>) ||</span><br><span class="line">        slug.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">error</span>: !result,</span><br><span class="line">        <span class="attr">message</span>: !result</span><br><span class="line">            ? <span class="string">&quot;短链不合法，请检查内容是否存在特殊字符，长度是否少于 4 个或超过 10 个字符&quot;</span></span><br><span class="line">            : <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isRemarkValid = (<span class="attr">remark</span>: <span class="built_in">string</span>): <span class="function"><span class="params">Error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = remark.<span class="property">length</span> &lt;= <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">error</span>: !result,</span><br><span class="line">        <span class="attr">message</span>: !result ? <span class="string">&quot;备注不合法，请缩短备注长度至 100 个字符以内&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; isURLValid, isSlugValid, isRemarkValid &#125;;</span><br></pre></td></tr></table></figure>

<p>这样就结束了吗？当然不是！写到这里，博主想起以前混 HostLoc 时，曾刷到一篇关于「如何透过 F12 开 Vultr 2.5 刀小鸡」的帖子，贴子中就是直接透过修改前端代码绕过的限制。</p>
<p>既然有这经验了，博主肯定也不会再犯这种低级错误，所以不光要在前端要限制用户输入，数据库一侧也要限制用户输入。</p>
<p>幸亏 Firebase Realtime Database 拥有比较强大的规则管理功能，所以在数据库端也能轻松约束用户输入的内容，从而避免用户对应用抓包后自行构造恶意请求。</p>
<p><img data-src="https://c.ibcl.us/ShortLink-Firebase_20230626/2.png" alt="Firebase Realtime Database 规则管理"></p>
<p>博主也已经整理出了与上文所述前端规则相同的数据库规则，此外，这段规则还包含了对 <code>timestamp</code> 字段的校验，将用户与标准时间的误差控制在了 5 分钟之内。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;shorts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;$query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.isString() &amp;&amp; newData.val().length &lt;= 100&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;slug&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.isString() &amp;&amp; newData.val().length &gt;= 4 &amp;&amp; newData.val().length &lt;= 10 &amp;&amp; newData.val().matches(/^[a-zA-Z0-9]+$/)&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.isString() &amp;&amp; newData.val().matches(/^(https|http|ftp):\\/\\//) &amp;&amp; newData.val().length &lt;= 255&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.isNumber() &amp;&amp; now - newData.val() &lt; 30000&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;ua&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.isString() &amp;&amp; newData.val().length &lt;= 255&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.isString() &amp;&amp; newData.val().length &lt;= 96&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.isString() &amp;&amp; (newData.val().matches(/^((25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/) || newData.val().matches(/^([\\da-fA-F]&#123;1,4&#125;:)&#123;7&#125;[\\da-fA-F]&#123;1,4&#125;$/))&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.hasChildren([&#x27;country&#x27;, &#x27;ip&#x27;, &#x27;ua&#x27;])&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;.indexOn&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;timestamp&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;.validate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newData.hasChildren([&#x27;url&#x27;,&#x27;slug&#x27;,&#x27;timestamp&#x27;,&#x27;remark&#x27;,&#x27;user&#x27;])&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;.read&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auth != null&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;.write&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auth != null&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="取得用户资讯"><a href="#取得用户资讯" class="headerlink" title="取得用户资讯"></a>取得用户资讯</h2><p>这个项目仅收集用户的浏览器 UA、IP 位址和所在国家，以避免用户滥用以及用来分发侵权内容、血腥暴恐、儿童色情等。由于需要用到第三方的查询 API，为了避免单点故障，所以博主的方案是内建一系列同类 API，每次从第一个 API 询问起，到获得用户 IP 及国家为止。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> userRequest <span class="keyword">from</span> <span class="string">&quot;./userRequest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="attr">ua</span>: <span class="built_in">string</span> | <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attr">country</span>: <span class="built_in">string</span> | <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    <span class="attr">ip</span>: <span class="built_in">string</span> | <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserInfo = <span class="keyword">async</span> (): <span class="title class_">Promise</span>&lt;<span class="title class_">Result</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> ipAPIs = [</span><br><span class="line">        <span class="string">&quot;https://ipwho.is&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://ipinfo.io/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://ipapi.co/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://ip.nf/me.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://ip-api.io/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://freeipapi.com/api/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://api.wolfx.jp/geoip.php&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://www.geoplugin.net/json.gp&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; userAgent &#125; = navigator;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> api <span class="keyword">of</span> ipAPIs) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">userRequest</span>(&#123;</span><br><span class="line">                <span class="attr">url</span>: api,</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="comment">// Possible keys for country</span></span><br><span class="line">                country_name,</span><br><span class="line">                countryName,</span><br><span class="line">                country,</span><br><span class="line">                geoplugin_countryName,</span><br><span class="line">                <span class="comment">// Possible keys for ip</span></span><br><span class="line">                ip,</span><br><span class="line">                query,</span><br><span class="line">                ipAddress,</span><br><span class="line">                geoplugin_request,</span><br><span class="line">            &#125; = res.<span class="property">data</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">ua</span>: userAgent,</span><br><span class="line">                <span class="attr">country</span>:</span><br><span class="line">                    country ||</span><br><span class="line">                    countryName ||</span><br><span class="line">                    country_name ||</span><br><span class="line">                    geoplugin_countryName,</span><br><span class="line">                <span class="attr">ip</span>: ip || query || ipAddress || geoplugin_request,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">ua</span>: userAgent,</span><br><span class="line">        <span class="attr">country</span>: <span class="string">&quot;Unknown&quot;</span>,</span><br><span class="line">        <span class="attr">ip</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getUserInfo;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，这段代码使用了异步编程的方法，可以有效避免陷入「回调地狱」。</p>
<h2 id="数据库-CURD"><a href="#数据库-CURD" class="headerlink" title="数据库 CURD"></a>数据库 CURD</h2><p>其实前文也已经提到，对 Firebase Realtime Database 的增删查改操作，就是一堆 HTTP 请求，没有什么太大的难度，只需要做好相应的错误处理即可。</p>
<p>在这一部分的代码中，博主也都是使用的异步编程方式。</p>
<h3 id="增加短链"><a href="#增加短链" class="headerlink" title="增加短链"></a>增加短链</h3><p>这里使用 PUT 方法，带上相应数据结构即可，由于已经对传入到数据库的值做了约束，所以前端提交的值也必须符合规范。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> userRequest <span class="keyword">from</span> <span class="string">&quot;./userRequest&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Result</span> <span class="keyword">as</span> <span class="title class_">UserInfo</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./getUserInfo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">slug</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">remark</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">firebase</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">user</span>: <span class="title class_">UserInfo</span> | <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addShortLink = <span class="keyword">async</span> (&#123;</span><br><span class="line">    url,</span><br><span class="line">    slug,</span><br><span class="line">    remark,</span><br><span class="line">    firebase,</span><br><span class="line">    user,</span><br><span class="line">&#125;: <span class="title class_">Params</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> dbURL = <span class="string">`<span class="subst">$&#123;firebase&#125;</span>/shorts/<span class="subst">$&#123;slug&#125;</span>.json`</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">userRequest</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;put&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: dbURL,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">url</span>: url,</span><br><span class="line">            <span class="attr">slug</span>: slug,</span><br><span class="line">            <span class="attr">remark</span>: remark,</span><br><span class="line">            <span class="attr">timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">            <span class="attr">user</span>: user,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;短链生成失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slug;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> addShortLink;</span><br></pre></td></tr></table></figure>

<h3 id="删除短链"><a href="#删除短链" class="headerlink" title="删除短链"></a>删除短链</h3><p>删除短链使用 <code>DELETE</code> 方法，传入要删除的短链即可。不得不说 Google 的规范真的很优秀，完全是照着 RESTful 来的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> userRequest <span class="keyword">from</span> <span class="string">&quot;./userRequest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">    <span class="attr">slug</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">firebase</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeShortLink = <span class="keyword">async</span> (&#123; slug, firebase &#125;: <span class="title class_">Params</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> dbURL = <span class="string">`<span class="subst">$&#123;firebase&#125;</span>/shorts/<span class="subst">$&#123;slug&#125;</span>.json`</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">userRequest</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;delete&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: dbURL,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;短链删除失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slug;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> removeShortLink;</span><br></pre></td></tr></table></figure>

<h3 id="查询短链"><a href="#查询短链" class="headerlink" title="查询短链"></a>查询短链</h3><p>查询短链使用 <code>GET</code> 方法即可，同样是只需要传入要查询的短链。如果没有查询到相关数据，Firebase Realtime Database 则会返回 <code>Null</code>，代码中只需根据这一区别抛出相关错误即可。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> userRequest <span class="keyword">from</span> <span class="string">&quot;./userRequest&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Result</span> <span class="keyword">as</span> <span class="title class_">UserInfo</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./getUserInfo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">    <span class="attr">slug</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">firebase</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="attr">remark</span>: <span class="built_in">string</span> | <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span> | <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attr">slug</span>: <span class="built_in">string</span> | <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attr">user</span>: <span class="title class_">UserInfo</span>;</span><br><span class="line">    <span class="attr">timestamp</span>: <span class="built_in">number</span> | -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getShortLink = <span class="keyword">async</span> (&#123; slug, firebase &#125;: <span class="title class_">Params</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Result</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> dbURL = <span class="string">`<span class="subst">$&#123;firebase&#125;</span>/shorts/<span class="subst">$&#123;slug&#125;</span>.json`</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">userRequest</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: dbURL,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">data</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;查无此短链&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; remark, url, timestamp, user &#125; = res.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">timestamp</span>: timestamp,</span><br><span class="line">        <span class="attr">remark</span>: remark,</span><br><span class="line">        <span class="attr">url</span>: url,</span><br><span class="line">        <span class="attr">slug</span>: slug,</span><br><span class="line">        <span class="attr">user</span>: user,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getShortLink;</span><br></pre></td></tr></table></figure>

<h3 id="修改短链"><a href="#修改短链" class="headerlink" title="修改短链"></a>修改短链</h3><p>虽然项目用不到，但是博主还是写上了，这里用的是 <code>PATCH</code> 方法，只需要传入一组或多组待修改的字段即可。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> userRequest <span class="keyword">from</span> <span class="string">&quot;./userRequest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">    url?: <span class="built_in">string</span>;</span><br><span class="line">    slug?: <span class="built_in">string</span>;</span><br><span class="line">    remark?: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">firebase</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updateShortLink = <span class="keyword">async</span> (&#123;</span><br><span class="line">    url,</span><br><span class="line">    slug,</span><br><span class="line">    remark,</span><br><span class="line">    firebase,</span><br><span class="line">&#125;: <span class="title class_">Params</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> dbURL = <span class="string">`<span class="subst">$&#123;firebase&#125;</span>/shorts/<span class="subst">$&#123;slug&#125;</span>.json`</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">userRequest</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;patch&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: dbURL,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">url</span>: url,</span><br><span class="line">            <span class="attr">slug</span>: slug,</span><br><span class="line">            <span class="attr">remark</span>: remark,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;短链更新失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> updateShortLink;</span><br></pre></td></tr></table></figure>

<h1 id="完整项目仓库"><a href="#完整项目仓库" class="headerlink" title="完整项目仓库"></a>完整项目仓库</h1><p>项目完整代码已经开源到了 GitHub 上，名为 FireShort，使用 MIT 协议<del>（毕竟博主向来是个很大方的人）</del>。</p>
<p>链接在此 =&gt; <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JjbHN3bDA4MjcvRmlyZVNob3J0">bclswl0827/FireShort: FireShort: 基于 Firebase 的 Serveless 纯前端短链接生成工具<i class="fa fa-external-link-alt"></i></span></p>
<p>同时，博主也开放了一个演示站点 <span class="exturl" data-url="aHR0cHM6Ly9sdjkudXMv">lv9.us<i class="fa fa-external-link-alt"></i></span> 供体验。</p>
<p><img data-src="https://c.ibcl.us/ShortLink-Firebase_20230626/3.png" alt="FireShort - 1"></p>
<p><img data-src="https://c.ibcl.us/ShortLink-Firebase_20230626/4.png" alt="FireShort - 2"></p>
<h1 id="一点奇技淫巧"><a href="#一点奇技淫巧" class="headerlink" title="一点奇技淫巧"></a>一点奇技淫巧</h1><p>程序写完过后，博主果断将生成的 <code>dist</code> 推送到了 GitHub Pages 上，准备好好欣赏自己的成果。</p>
<p>离谱的是，当博主满心欢喜生成好短链接，去到另外一个窗口打开这个链接过后，看到的却是 404。</p>
<p><img data-src="https://c.ibcl.us/ShortLink-Firebase_20230626/5.png" alt="FireShort - 3"></p>
<p>原来这是因为 React 的前端路由分为 Hash 和 History 两种模式。前者的路径形式行如 <code>example.org/#/test</code>，而后者的路径形式行如 <code>example.org/test</code>，可是这一形式又与传统的后端路由一样，因而导致在不支持 History 模式的服务器上就会产生 404 错误。</p>
<p>看上去貌似只能用 Hash 模式了，但是 Hash 模式真的很丑！难道好不容易生成了一个短网址，还得按着 Shift 再打出一组 <code>/#</code> 吗？</p>
<p>经过博主一天一夜的思考，最后灵光一闪：既然 GitHub Pages 能够支持自定义 404 页面，那么利用 404 页面来跳转去到 Hash 路由不就好了吗？</p>
<p>于是，就有了这样的一个 <code>404.html</code> 文件（源码路径位于 <code>public/404.html</code>）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh_CN&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;快打开查看吧～&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/logo192.png&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;manifest&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/manifest.json&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>给你分享了一个链接<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>您需要使用支持 JavaSctipt 的浏览器才能正常加载本站<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            (<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> protocol = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> host = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">host</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> path = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (path !== <span class="string">&quot;/404.html&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">`<span class="subst">$&#123;protocol&#125;</span>//<span class="subst">$&#123;host&#125;</span>/#<span class="subst">$&#123;path&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">`<span class="subst">$&#123;protocol&#125;</span>//<span class="subst">$&#123;host&#125;</span>/`</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;)();</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样一来，当访问 <code>/test</code> 之后，便会被自动带到 Hash 路由下的 <code>/#/test</code>，问题完美解决。</p>
<p>博主还煞费苦心地给这种方法取了个新名字，叫 <code>redirect</code> 模式（源码中 <code>src/config.tsx</code> 即可设定），真是辛苦博主了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这份代码其实是博主去年疫情期间打发时间写的，之后也没有再改过。这几天准备炒点冷饭，但是发现之前写的代码根本没法看，遂狠心花了一天时间，用 TypeScript 重构了一遍，终于舒服了。</p>
<p>哎，又了结一桩心事！</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>TypeScript</tag>
        <tag>Serverless</tag>
        <tag>Firebase</tag>
        <tag>实时数据库</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
</search>
